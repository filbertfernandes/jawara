/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nipplejs";
exports.ids = ["vendor-chunks/nipplejs"];
exports.modules = {

/***/ "(ssr)/./node_modules/nipplejs/dist/nipplejs.js":
/*!************************************************!*\
  !*** ./node_modules/nipplejs/dist/nipplejs.js ***!
  \************************************************/
/***/ ((module) => {

eval("(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;\n'use strict';\n\n// Constants\nvar isTouch = !!('ontouchstart' in window);\nvar isPointer = window.PointerEvent ? true : false;\nvar isMSPointer = window.MSPointerEvent ? true : false;\nvar events = {\n    touch: {\n        start: 'touchstart',\n        move: 'touchmove',\n        end: 'touchend, touchcancel'\n    },\n    mouse: {\n        start: 'mousedown',\n        move: 'mousemove',\n        end: 'mouseup'\n    },\n    pointer: {\n        start: 'pointerdown',\n        move: 'pointermove',\n        end: 'pointerup, pointercancel'\n    },\n    MSPointer: {\n        start: 'MSPointerDown',\n        move: 'MSPointerMove',\n        end: 'MSPointerUp'\n    }\n};\nvar toBind;\nvar secondBind = {};\nif (isPointer) {\n    toBind = events.pointer;\n} else if (isMSPointer) {\n    toBind = events.MSPointer;\n} else if (isTouch) {\n    toBind = events.touch;\n    secondBind = events.mouse;\n} else {\n    toBind = events.mouse;\n}\n\n///////////////////////\n///      UTILS      ///\n///////////////////////\n\nvar u = {};\nu.distance = function (p1, p2) {\n    var dx = p2.x - p1.x;\n    var dy = p2.y - p1.y;\n\n    return Math.sqrt((dx * dx) + (dy * dy));\n};\n\nu.angle = function(p1, p2) {\n    var dx = p2.x - p1.x;\n    var dy = p2.y - p1.y;\n\n    return u.degrees(Math.atan2(dy, dx));\n};\n\nu.findCoord = function(p, d, a) {\n    var b = {x: 0, y: 0};\n    a = u.radians(a);\n    b.x = p.x - d * Math.cos(a);\n    b.y = p.y - d * Math.sin(a);\n    return b;\n};\n\nu.radians = function(a) {\n    return a * (Math.PI / 180);\n};\n\nu.degrees = function(a) {\n    return a * (180 / Math.PI);\n};\n\nu.bindEvt = function (el, arg, handler) {\n    var types = arg.split(/[ ,]+/g);\n    var type;\n    for (var i = 0; i < types.length; i += 1) {\n        type = types[i];\n        if (el.addEventListener) {\n            el.addEventListener(type, handler, false);\n        } else if (el.attachEvent) {\n            el.attachEvent(type, handler);\n        }\n    }\n};\n\nu.unbindEvt = function (el, arg, handler) {\n    var types = arg.split(/[ ,]+/g);\n    var type;\n    for (var i = 0; i < types.length; i += 1) {\n        type = types[i];\n        if (el.removeEventListener) {\n            el.removeEventListener(type, handler);\n        } else if (el.detachEvent) {\n            el.detachEvent(type, handler);\n        }\n    }\n};\n\nu.trigger = function (el, type, data) {\n    var evt = new CustomEvent(type, data);\n    el.dispatchEvent(evt);\n};\n\nu.prepareEvent = function (evt) {\n    evt.preventDefault();\n    return evt.type.match(/^touch/) ? evt.changedTouches : evt;\n};\n\nu.getScroll = function () {\n    var x = (window.pageXOffset !== undefined) ?\n        window.pageXOffset :\n        (document.documentElement || document.body.parentNode || document.body)\n            .scrollLeft;\n\n    var y = (window.pageYOffset !== undefined) ?\n        window.pageYOffset :\n        (document.documentElement || document.body.parentNode || document.body)\n            .scrollTop;\n    return {\n        x: x,\n        y: y\n    };\n};\n\nu.applyPosition = function (el, pos) {\n    if (pos.top || pos.right || pos.bottom || pos.left) {\n        el.style.top = pos.top;\n        el.style.right = pos.right;\n        el.style.bottom = pos.bottom;\n        el.style.left = pos.left;\n    } else {\n        el.style.left = pos.x + 'px';\n        el.style.top = pos.y + 'px';\n    }\n};\n\nu.getTransitionStyle = function (property, values, time) {\n    var obj = u.configStylePropertyObject(property);\n    for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (typeof values === 'string') {\n                obj[i] = values + ' ' + time;\n            } else {\n                var st = '';\n                for (var j = 0, max = values.length; j < max; j += 1) {\n                    st += values[j] + ' ' + time + ', ';\n                }\n                obj[i] = st.slice(0, -2);\n            }\n        }\n    }\n    return obj;\n};\n\nu.getVendorStyle = function (property, value) {\n    var obj = u.configStylePropertyObject(property);\n    for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            obj[i] = value;\n        }\n    }\n    return obj;\n};\n\nu.configStylePropertyObject = function (prop) {\n    var obj = {};\n    obj[prop] = '';\n    var vendors = ['webkit', 'Moz', 'o'];\n    vendors.forEach(function (vendor) {\n        obj[vendor + prop.charAt(0).toUpperCase() + prop.slice(1)] = '';\n    });\n    return obj;\n};\n\nu.extend = function (objA, objB) {\n    for (var i in objB) {\n        if (objB.hasOwnProperty(i)) {\n            objA[i] = objB[i];\n        }\n    }\n    return objA;\n};\n\n// Overwrite only what's already present\nu.safeExtend = function (objA, objB) {\n    var obj = {};\n    for (var i in objA) {\n        if (objA.hasOwnProperty(i) && objB.hasOwnProperty(i)) {\n            obj[i] = objB[i];\n        } else if (objA.hasOwnProperty(i)) {\n            obj[i] = objA[i];\n        }\n    }\n    return obj;\n};\n\n// Map for array or unique item.\nu.map = function (ar, fn) {\n    if (ar.length) {\n        for (var i = 0, max = ar.length; i < max; i += 1) {\n            fn(ar[i]);\n        }\n    } else {\n        fn(ar);\n    }\n};\n\n///////////////////////\n///   SUPER CLASS   ///\n///////////////////////\n\nfunction Super () {};\n\n// Basic event system.\nSuper.prototype.on = function (arg, cb) {\n    var self = this;\n    var types = arg.split(/[ ,]+/g);\n    var type;\n    self._handlers_ = self._handlers_ || {};\n\n    for (var i = 0; i < types.length; i += 1) {\n        type = types[i];\n        self._handlers_[type] = self._handlers_[type] || [];\n        self._handlers_[type].push(cb);\n    }\n    return self;\n};\n\nSuper.prototype.off = function (type, cb) {\n    var self = this;\n    self._handlers_ = self._handlers_ || {};\n\n    if (type === undefined) {\n        self._handlers_ = {};\n    } else if (cb === undefined) {\n        self._handlers_[type] = null;\n    } else if (self._handlers_[type] &&\n            self._handlers_[type].indexOf(cb) >= 0) {\n        self._handlers_[type].splice(self._handlers_[type].indexOf(cb), 1);\n    }\n\n    return self;\n};\n\nSuper.prototype.trigger = function (arg, data) {\n    var self = this;\n    var types = arg.split(/[ ,]+/g);\n    var type;\n    self._handlers_ = self._handlers_ || {};\n\n    for (var i = 0; i < types.length; i += 1) {\n        type = types[i];\n        if (self._handlers_[type] && self._handlers_[type].length) {\n            self._handlers_[type].forEach(function (handler) {\n                handler.call(self, {\n                    type: type,\n                    target: self\n                }, data);\n            });\n        }\n    }\n};\n\n// Configuration\nSuper.prototype.config = function (options) {\n    var self = this;\n    self.options = self.defaults || {};\n    if (options) {\n        self.options = u.safeExtend(self.options, options);\n    }\n};\n\n// Bind internal events.\nSuper.prototype.bindEvt = function (el, type) {\n    var self = this;\n    self._domHandlers_ = self._domHandlers_ || {};\n\n    self._domHandlers_[type] = function () {\n        if (typeof self['on' + type] === 'function') {\n            self['on' + type].apply(self, arguments);\n        } else {\n            console.warn('[WARNING] : Missing \"on' + type + '\" handler.');\n        }\n    };\n\n    u.bindEvt(el, toBind[type], self._domHandlers_[type]);\n\n    if (secondBind[type]) {\n        // Support for both touch and mouse at the same time.\n        u.bindEvt(el, secondBind[type], self._domHandlers_[type]);\n    }\n\n    return self;\n};\n\n// Unbind dom events.\nSuper.prototype.unbindEvt = function (el, type) {\n    var self = this;\n    self._domHandlers_ = self._domHandlers_ || {};\n\n    u.unbindEvt(el, toBind[type], self._domHandlers_[type]);\n\n    if (secondBind[type]) {\n        // Support for both touch and mouse at the same time.\n        u.unbindEvt(el, secondBind[type], self._domHandlers_[type]);\n    }\n\n    delete self._domHandlers_[type];\n\n    return this;\n};\n\n///////////////////////\n///   THE NIPPLE    ///\n///////////////////////\n\nfunction Nipple (collection, options) {\n    this.identifier = options.identifier;\n    this.position = options.position;\n    this.frontPosition = options.frontPosition;\n    this.collection = collection;\n\n    // Defaults\n    this.defaults = {\n        size: 100,\n        threshold: 0.1,\n        color: 'white',\n        fadeTime: 250,\n        dataOnly: false,\n        restJoystick: true,\n        restOpacity: 0.5,\n        mode: 'dynamic',\n        zone: document.body,\n        lockX: false,\n        lockY: false\n    };\n\n    this.config(options);\n\n    // Overwrites\n    if (this.options.mode === 'dynamic') {\n        this.options.restOpacity = 0;\n    }\n\n    this.id = Nipple.id;\n    Nipple.id += 1;\n    this.buildEl()\n        .stylize();\n\n    // Nipple's API.\n    this.instance = {\n        el: this.ui.el,\n        on: this.on.bind(this),\n        off: this.off.bind(this),\n        show: this.show.bind(this),\n        hide: this.hide.bind(this),\n        add: this.addToDom.bind(this),\n        remove: this.removeFromDom.bind(this),\n        destroy: this.destroy.bind(this),\n        resetDirection: this.resetDirection.bind(this),\n        computeDirection: this.computeDirection.bind(this),\n        trigger: this.trigger.bind(this),\n        position: this.position,\n        frontPosition: this.frontPosition,\n        ui: this.ui,\n        identifier: this.identifier,\n        id: this.id,\n        options: this.options\n    };\n\n    return this.instance;\n};\n\nNipple.prototype = new Super();\nNipple.constructor = Nipple;\nNipple.id = 0;\n\n// Build the dom element of the Nipple instance.\nNipple.prototype.buildEl = function (options) {\n    this.ui = {};\n\n    if (this.options.dataOnly) {\n        return this;\n    }\n\n    this.ui.el = document.createElement('div');\n    this.ui.back = document.createElement('div');\n    this.ui.front = document.createElement('div');\n\n    this.ui.el.className = 'nipple collection_' + this.collection.id;\n    this.ui.back.className = 'back';\n    this.ui.front.className = 'front';\n\n    this.ui.el.setAttribute('id', 'nipple_' + this.collection.id +\n        '_' + this.id);\n\n    this.ui.el.appendChild(this.ui.back);\n    this.ui.el.appendChild(this.ui.front);\n\n    return this;\n};\n\n// Apply CSS to the Nipple instance.\nNipple.prototype.stylize = function () {\n    if (this.options.dataOnly) {\n        return this;\n    }\n    var animTime = this.options.fadeTime + 'ms';\n    var borderStyle = u.getVendorStyle('borderRadius', '50%');\n    var transitStyle = u.getTransitionStyle('transition', 'opacity', animTime);\n    var styles = {};\n    styles.el = {\n        position: 'absolute',\n        opacity: this.options.restOpacity,\n        display: 'block',\n        'zIndex': 999\n    };\n\n    styles.back = {\n        position: 'absolute',\n        display: 'block',\n        width: this.options.size + 'px',\n        height: this.options.size + 'px',\n        marginLeft: -this.options.size / 2 + 'px',\n        marginTop: -this.options.size / 2 + 'px',\n        background: this.options.color,\n        'opacity': '.5'\n    };\n\n    styles.front = {\n        width: this.options.size / 2 + 'px',\n        height: this.options.size / 2 + 'px',\n        position: 'absolute',\n        display: 'block',\n        marginLeft: -this.options.size / 4 + 'px',\n        marginTop: -this.options.size / 4 + 'px',\n        background: this.options.color,\n        'opacity': '.5'\n    };\n\n    u.extend(styles.el, transitStyle);\n    u.extend(styles.back, borderStyle);\n    u.extend(styles.front, borderStyle);\n\n    this.applyStyles(styles);\n\n    return this;\n};\n\nNipple.prototype.applyStyles = function (styles) {\n    // Apply styles\n    for (var i in this.ui) {\n        if (this.ui.hasOwnProperty(i)) {\n            for (var j in styles[i]) {\n                this.ui[i].style[j] = styles[i][j];\n            }\n        }\n    }\n\n    return this;\n};\n\n// Inject the Nipple instance into DOM.\nNipple.prototype.addToDom = function () {\n    // We're not adding it if we're dataOnly or already in dom.\n    if (this.options.dataOnly || document.body.contains(this.ui.el)) {\n        return this;\n    }\n    this.options.zone.appendChild(this.ui.el);\n    return this;\n};\n\n// Remove the Nipple instance from DOM.\nNipple.prototype.removeFromDom = function () {\n    if (this.options.dataOnly || !document.body.contains(this.ui.el)) {\n        return this;\n    }\n    this.options.zone.removeChild(this.ui.el);\n    return this;\n};\n\n// Entirely destroy this nipple\nNipple.prototype.destroy = function () {\n    clearTimeout(this.removeTimeout);\n    clearTimeout(this.showTimeout);\n    clearTimeout(this.restTimeout);\n    this.trigger('destroyed', this.instance);\n    this.removeFromDom();\n    this.off();\n};\n\n// Fade in the Nipple instance.\nNipple.prototype.show = function (cb) {\n    var self = this;\n\n    if (self.options.dataOnly) {\n        return self;\n    }\n\n    clearTimeout(self.removeTimeout);\n    clearTimeout(self.showTimeout);\n    clearTimeout(self.restTimeout);\n\n    self.addToDom();\n\n    self.restCallback();\n\n    setTimeout(function () {\n        self.ui.el.style.opacity = 1;\n    }, 0);\n\n    self.showTimeout = setTimeout(function () {\n        self.trigger('shown', self.instance);\n        if (typeof cb === 'function') {\n            cb.call(this);\n        }\n    }, self.options.fadeTime);\n\n    return self;\n};\n\n// Fade out the Nipple instance.\nNipple.prototype.hide = function (cb) {\n    var self = this;\n\n    if (self.options.dataOnly) {\n        return self;\n    }\n\n    self.ui.el.style.opacity = self.options.restOpacity;\n\n    clearTimeout(self.removeTimeout);\n    clearTimeout(self.showTimeout);\n    clearTimeout(self.restTimeout);\n\n    self.removeTimeout = setTimeout(\n        function () {\n            var display = self.options.mode === 'dynamic' ? 'none' : 'block';\n            self.ui.el.style.display = display;\n            if (typeof cb === 'function') {\n                cb.call(self);\n            }\n\n            self.trigger('hidden', self.instance);\n        },\n        self.options.fadeTime\n    );\n    if (self.options.restJoystick) {\n        self.restPosition();\n    }\n\n    return self;\n};\n\nNipple.prototype.restPosition = function (cb) {\n    var self = this;\n    self.frontPosition = {\n        x: 0,\n        y: 0\n    };\n    var animTime = self.options.fadeTime + 'ms';\n\n    var transitStyle = {};\n    transitStyle.front = u.getTransitionStyle('transition',\n        ['top', 'left'], animTime);\n\n    var styles = {front: {}};\n    styles.front = {\n        left: self.frontPosition.x + 'px',\n        top: self.frontPosition.y + 'px'\n    };\n\n    self.applyStyles(transitStyle);\n    self.applyStyles(styles);\n\n    self.restTimeout = setTimeout(\n        function () {\n            if (typeof cb === 'function') {\n                cb.call(self);\n            }\n            self.restCallback();\n        },\n        self.options.fadeTime\n    );\n};\n\nNipple.prototype.restCallback = function () {\n    var self = this;\n    var transitStyle = {};\n    transitStyle.front = u.getTransitionStyle('transition', 'none', '');\n    self.applyStyles(transitStyle);\n    self.trigger('rested', self.instance);\n};\n\nNipple.prototype.resetDirection = function () {\n    // Fully rebuild the object to let the iteration possible.\n    this.direction = {\n        x: false,\n        y: false,\n        angle: false\n    };\n};\n\nNipple.prototype.computeDirection = function (obj) {\n    var rAngle = obj.angle.radian;\n    var angle45 = Math.PI / 4;\n    var angle90 = Math.PI / 2;\n    var direction, directionX, directionY;\n\n    // Angular direction\n    //     \\  UP /\n    //      \\   /\n    // LEFT       RIGHT\n    //      /   \\\n    //     /DOWN \\\n    //\n    if (\n        rAngle > angle45 &&\n        rAngle < (angle45 * 3) &&\n        !obj.lockX\n    ) {\n        direction = 'up';\n    } else if (\n        rAngle > -angle45 &&\n        rAngle <= angle45 &&\n        !obj.lockY\n    ) {\n        direction = 'left';\n    } else if (\n        rAngle > (-angle45 * 3) &&\n        rAngle <= -angle45 &&\n        !obj.lockX\n    ) {\n        direction = 'down';\n    } else if (!obj.lockY) {\n        direction = 'right';\n    }\n\n    // Plain direction\n    //    UP                 |\n    // _______               | RIGHT\n    //                  LEFT |\n    //   DOWN                |\n    if (!obj.lockY) {\n        if (rAngle > -angle90 && rAngle < angle90) {\n            directionX = 'left';\n        } else {\n            directionX = 'right';\n        }\n    }\n\n    if (!obj.lockX) {\n        if (rAngle > 0) {\n            directionY = 'up';\n        } else {\n            directionY = 'down';\n        }\n    }\n\n    if (obj.force > this.options.threshold) {\n        var oldDirection = {};\n        for (var i in this.direction) {\n            if (this.direction.hasOwnProperty(i)) {\n                oldDirection[i] = this.direction[i];\n            }\n        }\n\n        var same = {};\n\n        this.direction = {\n            x: directionX,\n            y: directionY,\n            angle: direction\n        };\n\n        obj.direction = this.direction;\n\n        for (var i in oldDirection) {\n            if (oldDirection[i] === this.direction[i]) {\n                same[i] = true;\n            }\n        }\n\n        // If all 3 directions are the same, we don't trigger anything.\n        if (same.x && same.y && same.angle) {\n            return obj;\n        }\n\n        if (!same.x || !same.y) {\n            this.trigger('plain', obj);\n        }\n\n        if (!same.x) {\n            this.trigger('plain:' + directionX, obj);\n        }\n\n        if (!same.y) {\n            this.trigger('plain:' + directionY, obj);\n        }\n\n        if (!same.angle) {\n            this.trigger('dir dir:' + direction, obj);\n        }\n    }\n    return obj;\n};\n\n/* global Nipple, Super */\n\n///////////////////////////\n///   THE COLLECTION    ///\n///////////////////////////\n\nfunction Collection (manager, options) {\n    var self = this;\n    self.nipples = [];\n    self.idles = [];\n    self.actives = [];\n    self.ids = [];\n    self.pressureIntervals = {};\n    self.manager = manager;\n    self.id = Collection.id;\n    Collection.id += 1;\n\n    // Defaults\n    self.defaults = {\n        zone: document.body,\n        multitouch: false,\n        maxNumberOfNipples: 10,\n        mode: 'dynamic',\n        position: {top: 0, left: 0},\n        catchDistance: 200,\n        size: 100,\n        threshold: 0.1,\n        color: 'white',\n        fadeTime: 250,\n        dataOnly: false,\n        restJoystick: true,\n        restOpacity: 0.5,\n        lockX: false,\n        lockY: false\n    };\n\n    self.config(options);\n\n    // Overwrites\n    if (self.options.mode === 'static' || self.options.mode === 'semi') {\n        self.options.multitouch = false;\n    }\n\n    if (!self.options.multitouch) {\n        self.options.maxNumberOfNipples = 1;\n    }\n\n    self.updateBox();\n    self.prepareNipples();\n    self.bindings();\n    self.begin();\n\n    return self.nipples;\n}\n\nCollection.prototype = new Super();\nCollection.constructor = Collection;\nCollection.id = 0;\n\nCollection.prototype.prepareNipples = function () {\n    var self = this;\n    var nips = self.nipples;\n\n    // Public API Preparation.\n    nips.on = self.on.bind(self);\n    nips.off = self.off.bind(self);\n    nips.options = self.options;\n    nips.destroy = self.destroy.bind(self);\n    nips.ids = self.ids;\n    nips.id = self.id;\n    nips.processOnMove = self.processOnMove.bind(self);\n    nips.processOnEnd = self.processOnEnd.bind(self);\n    nips.get = function (id) {\n        if (id === undefined) {\n            return nips[0];\n        }\n        for (var i = 0, max = nips.length; i < max; i += 1) {\n            if (nips[i].identifier === id) {\n                return nips[i];\n            }\n        }\n        return false;\n    };\n};\n\nCollection.prototype.bindings = function () {\n    var self = this;\n    // Touch start event.\n    self.bindEvt(self.options.zone, 'start');\n    // Avoid native touch actions (scroll, zoom etc...) on the zone.\n    self.options.zone.style.touchAction = 'none';\n    self.options.zone.style.msTouchAction = 'none';\n};\n\nCollection.prototype.begin = function () {\n    var self = this;\n    var opts = self.options;\n\n    // We place our static nipple\n    // if needed.\n    if (opts.mode === 'static') {\n        var nipple = self.createNipple(\n            opts.position,\n            self.manager.getIdentifier()\n        );\n        // Add it to the dom.\n        nipple.add();\n        // Store it in idles.\n        self.idles.push(nipple);\n    }\n};\n\n// Nipple Factory\nCollection.prototype.createNipple = function (position, identifier) {\n    var self = this;\n    var scroll = u.getScroll();\n    var toPutOn = {};\n    var opts = self.options;\n\n    if (position.x && position.y) {\n        toPutOn = {\n            x: position.x -\n                (scroll.x + self.box.left),\n            y: position.y -\n                (scroll.y + self.box.top)\n        };\n    } else if (\n            position.top ||\n            position.right ||\n            position.bottom ||\n            position.left\n        ) {\n\n        // We need to compute the position X / Y of the joystick.\n        var dumb = document.createElement('DIV');\n        dumb.style.display = 'hidden';\n        dumb.style.top = position.top;\n        dumb.style.right = position.right;\n        dumb.style.bottom = position.bottom;\n        dumb.style.left = position.left;\n        dumb.style.position = 'absolute';\n\n        opts.zone.appendChild(dumb);\n        var dumbBox = dumb.getBoundingClientRect();\n        opts.zone.removeChild(dumb);\n\n        toPutOn = position;\n        position = {\n            x: dumbBox.left + scroll.x,\n            y: dumbBox.top + scroll.y\n        };\n    }\n\n    var nipple = new Nipple(self, {\n        color: opts.color,\n        size: opts.size,\n        threshold: opts.threshold,\n        fadeTime: opts.fadeTime,\n        dataOnly: opts.dataOnly,\n        restJoystick: opts.restJoystick,\n        restOpacity: opts.restOpacity,\n        mode: opts.mode,\n        identifier: identifier,\n        position: position,\n        zone: opts.zone,\n        frontPosition: {\n            x: 0,\n            y: 0\n        }\n    });\n\n    if (!opts.dataOnly) {\n        u.applyPosition(nipple.ui.el, toPutOn);\n        u.applyPosition(nipple.ui.front, nipple.frontPosition);\n    }\n    self.nipples.push(nipple);\n    self.trigger('added ' + nipple.identifier + ':added', nipple);\n    self.manager.trigger('added ' + nipple.identifier + ':added', nipple);\n\n    self.bindNipple(nipple);\n\n    return nipple;\n};\n\nCollection.prototype.updateBox = function () {\n    var self = this;\n    self.box = self.options.zone.getBoundingClientRect();\n};\n\nCollection.prototype.bindNipple = function (nipple) {\n    var self = this;\n    var type;\n    // Bubble up identified events.\n    var handler = function (evt, data) {\n        // Identify the event type with the nipple's id.\n        type = evt.type + ' ' + data.id + ':' + evt.type;\n        self.trigger(type, data);\n    };\n\n    // When it gets destroyed.\n    nipple.on('destroyed', self.onDestroyed.bind(self));\n\n    // Other events that will get bubbled up.\n    nipple.on('shown hidden rested dir plain', handler);\n    nipple.on('dir:up dir:right dir:down dir:left', handler);\n    nipple.on('plain:up plain:right plain:down plain:left', handler);\n};\n\nCollection.prototype.pressureFn = function (touch, nipple, identifier) {\n    var self = this;\n    var previousPressure = 0;\n    clearInterval(self.pressureIntervals[identifier]);\n    // Create an interval that will read the pressure every 100ms\n    self.pressureIntervals[identifier] = setInterval(function () {\n        var pressure = touch.force || touch.pressure ||\n            touch.webkitForce || 0;\n        if (pressure !== previousPressure) {\n            nipple.trigger('pressure', pressure);\n            self.trigger('pressure ' +\n                nipple.identifier + ':pressure', pressure);\n            previousPressure = pressure;\n        }\n    }.bind(self), 100);\n};\n\nCollection.prototype.onstart = function (evt) {\n    var self = this;\n    var opts = self.options;\n    evt = u.prepareEvent(evt);\n\n    // Update the box position\n    self.updateBox();\n\n    var process = function (touch) {\n        // If we can create new nipples\n        // meaning we don't have more active nipples than we should.\n        if (self.actives.length < opts.maxNumberOfNipples) {\n            self.processOnStart(touch);\n        }\n    };\n\n    u.map(evt, process);\n\n    // We ask upstream to bind the document\n    // on 'move' and 'end'\n    self.manager.bindDocument();\n    return false;\n};\n\nCollection.prototype.processOnStart = function (evt) {\n    var self = this;\n    var opts = self.options;\n    var indexInIdles;\n    var identifier = self.manager.getIdentifier(evt);\n    var pressure = evt.force || evt.pressure || evt.webkitForce || 0;\n    var position = {\n        x: evt.pageX,\n        y: evt.pageY\n    };\n\n    var nipple = self.getOrCreate(identifier, position);\n\n    // Update its touch identifier\n    if (nipple.identifier !== identifier) {\n        self.manager.removeIdentifier(nipple.identifier);\n    }\n    nipple.identifier = identifier;\n\n    var process = function (nip) {\n        // Trigger the start.\n        nip.trigger('start', nip);\n        self.trigger('start ' + nip.id + ':start', nip);\n\n        nip.show();\n        if (pressure > 0) {\n            self.pressureFn(evt, nip, nip.identifier);\n        }\n        // Trigger the first move event.\n        self.processOnMove(evt);\n    };\n\n    // Transfer it from idles to actives.\n    if ((indexInIdles = self.idles.indexOf(nipple)) >= 0) {\n        self.idles.splice(indexInIdles, 1);\n    }\n\n    // Store the nipple in the actives array\n    self.actives.push(nipple);\n    self.ids.push(nipple.identifier);\n\n    if (opts.mode !== 'semi') {\n        process(nipple);\n    } else {\n        // In semi we check the distance of the touch\n        // to decide if we have to reset the nipple\n        var distance = u.distance(position, nipple.position);\n        if (distance <= opts.catchDistance) {\n            process(nipple);\n        } else {\n            nipple.destroy();\n            self.processOnStart(evt);\n            return;\n        }\n    }\n\n    return nipple;\n};\n\nCollection.prototype.getOrCreate = function (identifier, position) {\n    var self = this;\n    var opts = self.options;\n    var nipple;\n\n    // If we're in static or semi, we might already have an active.\n    if (/(semi|static)/.test(opts.mode)) {\n        // Get the active one.\n        // TODO: Multi-touche for semi and static will start here.\n        // Return the nearest one.\n        nipple = self.idles[0];\n        if (nipple) {\n            self.idles.splice(0, 1);\n            return nipple;\n        }\n\n        if (opts.mode === 'semi') {\n            // If we're in semi mode, we need to create one.\n            return self.createNipple(position, identifier);\n        }\n\n        console.warn('Coudln\\'t find the needed nipple.');\n        return false;\n    }\n    // In dynamic, we create a new one.\n    nipple = self.createNipple(position, identifier);\n    return nipple;\n};\n\nCollection.prototype.processOnMove = function (evt) {\n    var self = this;\n    var opts = self.options;\n    var identifier = self.manager.getIdentifier(evt);\n    var nipple = self.nipples.get(identifier);\n\n    if (!nipple) {\n        // This is here just for safety.\n        // It shouldn't happen.\n        console.error('Found zombie joystick with ID ' + identifier);\n        self.manager.removeIdentifier(identifier);\n        return;\n    }\n\n    nipple.identifier = identifier;\n\n    var size = nipple.options.size / 2;\n    var pos = {\n        x: evt.pageX,\n        y: evt.pageY\n    };\n\n    var dist = u.distance(pos, nipple.position);\n    var angle = u.angle(pos, nipple.position);\n    var rAngle = u.radians(angle);\n    var force = dist / size;\n\n    // If distance is bigger than nipple's size\n    // we clamp the position.\n    if (dist > size) {\n        dist = size;\n        pos = u.findCoord(nipple.position, dist, angle);\n    }\n\n    var xPosition = pos.x - nipple.position.x\n    var yPosition = pos.y - nipple.position.y\n\n    if (opts.lockX){\n        yPosition = 0\n    }\n    if (opts.lockY) {\n        xPosition = 0\n    }\n\n    nipple.frontPosition = {\n        x: xPosition,\n        y: yPosition\n    };\n\n    if (!opts.dataOnly) {\n        u.applyPosition(nipple.ui.front, nipple.frontPosition);\n    }\n\n    // Prepare event's datas.\n    var toSend = {\n        identifier: nipple.identifier,\n        position: pos,\n        force: force,\n        pressure: evt.force || evt.pressure || evt.webkitForce || 0,\n        distance: dist,\n        angle: {\n            radian: rAngle,\n            degree: angle\n        },\n        instance: nipple,\n        lockX: opts.lockX,\n        lockY: opts.lockY\n    };\n\n    // Compute the direction's datas.\n    toSend = nipple.computeDirection(toSend);\n\n    // Offset angles to follow units circle.\n    toSend.angle = {\n        radian: u.radians(180 - angle),\n        degree: 180 - angle\n    };\n\n    // Send everything to everyone.\n    nipple.trigger('move', toSend);\n    self.trigger('move ' + nipple.id + ':move', toSend);\n};\n\nCollection.prototype.processOnEnd = function (evt) {\n    var self = this;\n    var opts = self.options;\n    var identifier = self.manager.getIdentifier(evt);\n    var nipple = self.nipples.get(identifier);\n    var removedIdentifier = self.manager.removeIdentifier(nipple.identifier);\n\n    if (!nipple) {\n        return;\n    }\n\n    if (!opts.dataOnly) {\n        nipple.hide(function () {\n            if (opts.mode === 'dynamic') {\n                nipple.trigger('removed', nipple);\n                self.trigger('removed ' + nipple.id + ':removed', nipple);\n                self.manager\n                    .trigger('removed ' + nipple.id + ':removed', nipple);\n                nipple.destroy();\n            }\n        });\n    }\n\n    // Clear the pressure interval reader\n    clearInterval(self.pressureIntervals[nipple.identifier]);\n\n    // Reset the direciton of the nipple, to be able to trigger a new direction\n    // on start.\n    nipple.resetDirection();\n\n    nipple.trigger('end', nipple);\n    self.trigger('end ' + nipple.id + ':end', nipple);\n\n    // Remove identifier from our bank.\n    if (self.ids.indexOf(nipple.identifier) >= 0) {\n        self.ids.splice(self.ids.indexOf(nipple.identifier), 1);\n    }\n\n    // Clean our actives array.\n    if (self.actives.indexOf(nipple) >= 0) {\n        self.actives.splice(self.actives.indexOf(nipple), 1);\n    }\n\n    if (/(semi|static)/.test(opts.mode)) {\n        // Transfer nipple from actives to idles\n        // if we're in semi or static mode.\n        self.idles.push(nipple);\n    } else if (self.nipples.indexOf(nipple) >= 0) {\n        // Only if we're not in semi or static mode\n        // we can remove the instance.\n        self.nipples.splice(self.nipples.indexOf(nipple), 1);\n    }\n\n    // We unbind move and end.\n    self.manager.unbindDocument();\n\n    // We add back the identifier of the idle nipple;\n    if (/(semi|static)/.test(opts.mode)) {\n        self.manager.ids[removedIdentifier.id] = removedIdentifier.identifier;\n    }\n};\n\n// Remove destroyed nipple from the lists\nCollection.prototype.onDestroyed = function(evt, nipple) {\n    var self = this;\n    if (self.nipples.indexOf(nipple) >= 0) {\n        self.nipples.splice(self.nipples.indexOf(nipple), 1);\n    }\n    if (self.actives.indexOf(nipple) >= 0) {\n        self.actives.splice(self.actives.indexOf(nipple), 1);\n    }\n    if (self.idles.indexOf(nipple) >= 0) {\n        self.idles.splice(self.idles.indexOf(nipple), 1);\n    }\n    if (self.ids.indexOf(nipple.identifier) >= 0) {\n        self.ids.splice(self.ids.indexOf(nipple.identifier), 1);\n    }\n\n    // Remove the identifier from our bank\n    self.manager.removeIdentifier(nipple.identifier);\n\n    // We unbind move and end.\n    self.manager.unbindDocument();\n};\n\n// Cleanly destroy the manager\nCollection.prototype.destroy = function () {\n    var self = this;\n    self.unbindEvt(self.options.zone, 'start');\n\n    // Destroy nipples.\n    self.nipples.forEach(function(nipple) {\n        nipple.destroy();\n    });\n\n    // Clean 3DTouch intervals.\n    for (var i in self.pressureIntervals) {\n        if (self.pressureIntervals.hasOwnProperty(i)) {\n            clearInterval(self.pressureIntervals[i]);\n        }\n    }\n\n    // Notify the manager passing the instance\n    self.trigger('destroyed', self.nipples);\n    // We unbind move and end.\n    self.manager.unbindDocument();\n    // Unbind everything.\n    self.off();\n};\n\n/* global u, Super, Collection */\n\n///////////////////////\n///     MANAGER     ///\n///////////////////////\n\nfunction Manager (options) {\n    var self = this;\n    self.ids = {};\n    self.index = 0;\n    self.collections = [];\n\n    self.config(options);\n    self.prepareCollections();\n\n    // Listen for resize, to reposition every joysticks\n    var resizeTimer;\n    u.bindEvt(window, 'resize', function (evt) {\n        clearTimeout(resizeTimer);\n        resizeTimer = setTimeout(function () {\n            var pos;\n            var scroll = u.getScroll();\n            self.collections.forEach(function (collection) {\n                collection.forEach(function (nipple) {\n                    pos = nipple.el.getBoundingClientRect();\n                    nipple.position = {\n                        x: scroll.x + pos.left,\n                        y: scroll.y + pos.top\n                    };\n                });\n            });\n        }, 100);\n    });\n\n    return self.collections;\n};\n\nManager.prototype = new Super();\nManager.constructor = Manager;\n\nManager.prototype.prepareCollections = function () {\n    var self = this;\n    // Public API Preparation.\n    self.collections.create = self.create.bind(self);\n    // Listen to anything\n    self.collections.on = self.on.bind(self);\n    // Unbind general events\n    self.collections.off = self.off.bind(self);\n    // Destroy everything\n    self.collections.destroy = self.destroy.bind(self);\n    // Get any nipple\n    self.collections.get = function (id) {\n        var nipple;\n        self.collections.every(function (collection) {\n            if (nipple = collection.get(id)) {\n                return false;\n            }\n            return true;\n        });\n        return nipple;\n    };\n};\n\nManager.prototype.create = function (options) {\n    return this.createCollection(options);\n};\n\n// Collection Factory\nManager.prototype.createCollection = function (options) {\n    var self = this;\n    var collection = new Collection(self, options);\n\n    self.bindCollection(collection);\n    self.collections.push(collection);\n\n    return collection;\n};\n\nManager.prototype.bindCollection = function (collection) {\n    var self = this;\n    var type;\n    // Bubble up identified events.\n    var handler = function (evt, data) {\n        // Identify the event type with the nipple's identifier.\n        type = evt.type + ' ' + data.id + ':' + evt.type;\n        self.trigger(type, data);\n    };\n\n    // When it gets destroyed we clean.\n    collection.on('destroyed', self.onDestroyed.bind(self));\n\n    // Other events that will get bubbled up.\n    collection.on('shown hidden rested dir plain', handler);\n    collection.on('dir:up dir:right dir:down dir:left', handler);\n    collection.on('plain:up plain:right plain:down plain:left', handler);\n};\n\nManager.prototype.bindDocument = function () {\n    var self = this;\n    // Bind only if not already binded\n    if (!self.binded) {\n        self.bindEvt(document, 'move')\n            .bindEvt(document, 'end');\n        self.binded = true;\n    }\n};\n\nManager.prototype.unbindDocument = function (force) {\n    var self = this;\n    // If there are no touch left\n    // unbind the document.\n    if (!Object.keys(self.ids).length || force === true) {\n        self.unbindEvt(document, 'move')\n            .unbindEvt(document, 'end');\n        self.binded = false;\n    }\n};\n\nManager.prototype.getIdentifier = function (evt) {\n    var id;\n    // If no event, simple increment\n    if (!evt) {\n        id = this.index;\n    } else {\n        // Extract identifier from event object.\n        // Unavailable in mouse events so replaced by latest increment.\n        id = evt.identifier === undefined ? evt.pointerId : evt.identifier;\n        if (id === undefined) {\n            id = this.latest || 0;\n        }\n    }\n\n    if (this.ids[id] === undefined) {\n        this.ids[id] = this.index;\n        this.index += 1;\n    }\n\n    // Keep the latest id used in case we're using an unidentified mouseEvent\n    this.latest = id;\n    return this.ids[id];\n};\n\nManager.prototype.removeIdentifier = function (identifier) {\n    var removed = {};\n    for (var id in this.ids) {\n        if (this.ids[id] === identifier) {\n            removed.id = id;\n            removed.identifier = this.ids[id];\n            delete this.ids[id];\n            break;\n        }\n    }\n    return removed;\n};\n\nManager.prototype.onmove = function (evt) {\n    var self = this;\n    self.onAny('move', evt);\n    return false;\n};\n\nManager.prototype.onend = function (evt) {\n    var self = this;\n    self.onAny('end', evt);\n    return false;\n};\n\nManager.prototype.oncancel = function (evt) {\n    var self = this;\n    self.onAny('end', evt);\n    return false;\n};\n\nManager.prototype.onAny = function (which, evt) {\n    var self = this;\n    var id;\n    var processFn = 'processOn' + which.charAt(0).toUpperCase() +\n        which.slice(1);\n    evt = u.prepareEvent(evt);\n    var processColl = function (e, id, coll) {\n        if (coll.ids.indexOf(id) >= 0) {\n            coll[processFn](e);\n            // Mark the event to avoid cleaning it later.\n            e._found_ = true;\n        }\n    };\n    var processEvt = function (e) {\n        id = self.getIdentifier(e);\n        u.map(self.collections, processColl.bind(null, e, id));\n        // If the event isn't handled by any collection,\n        // we need to clean its identifier.\n        if (!e._found_) {\n            self.removeIdentifier(id);\n        }\n    };\n\n    u.map(evt, processEvt);\n\n    return false;\n};\n\n// Cleanly destroy the manager\nManager.prototype.destroy = function () {\n    var self = this;\n    self.unbindDocument(true);\n    self.ids = {};\n    self.index = 0;\n    self.collections.forEach(function(collection) {\n        collection.destroy();\n    });\n    self.off();\n};\n\n// When a collection gets destroyed\n// we clean behind.\nManager.prototype.onDestroyed = function (evt, coll) {\n    var self = this;\n    if (self.collections.indexOf(coll) < 0) {\n        return false;\n    }\n    self.collections.splice(self.collections.indexOf(coll), 1);\n};\n\nvar factory = new Manager();\nreturn {\n    create: function (options) {\n        return factory.create(options);\n    },\n    factory: factory\n};\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmlwcGxlanMvZGlzdC9uaXBwbGVqcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLEdBQUcsSUFBc0QsRUFBRSxtQkFBbUIsS0FBSyxVQUFpTyxDQUFDLGFBQWE7QUFDL1U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qYXdhcmEvLi9ub2RlX21vZHVsZXMvbmlwcGxlanMvZGlzdC9uaXBwbGVqcy5qcz80OTA1Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLm5pcHBsZWpzID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztcbid1c2Ugc3RyaWN0JztcblxuLy8gQ29uc3RhbnRzXG52YXIgaXNUb3VjaCA9ICEhKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG52YXIgaXNQb2ludGVyID0gd2luZG93LlBvaW50ZXJFdmVudCA/IHRydWUgOiBmYWxzZTtcbnZhciBpc01TUG9pbnRlciA9IHdpbmRvdy5NU1BvaW50ZXJFdmVudCA/IHRydWUgOiBmYWxzZTtcbnZhciBldmVudHMgPSB7XG4gICAgdG91Y2g6IHtcbiAgICAgICAgc3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgbW92ZTogJ3RvdWNobW92ZScsXG4gICAgICAgIGVuZDogJ3RvdWNoZW5kLCB0b3VjaGNhbmNlbCdcbiAgICB9LFxuICAgIG1vdXNlOiB7XG4gICAgICAgIHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgICAgICAgbW92ZTogJ21vdXNlbW92ZScsXG4gICAgICAgIGVuZDogJ21vdXNldXAnXG4gICAgfSxcbiAgICBwb2ludGVyOiB7XG4gICAgICAgIHN0YXJ0OiAncG9pbnRlcmRvd24nLFxuICAgICAgICBtb3ZlOiAncG9pbnRlcm1vdmUnLFxuICAgICAgICBlbmQ6ICdwb2ludGVydXAsIHBvaW50ZXJjYW5jZWwnXG4gICAgfSxcbiAgICBNU1BvaW50ZXI6IHtcbiAgICAgICAgc3RhcnQ6ICdNU1BvaW50ZXJEb3duJyxcbiAgICAgICAgbW92ZTogJ01TUG9pbnRlck1vdmUnLFxuICAgICAgICBlbmQ6ICdNU1BvaW50ZXJVcCdcbiAgICB9XG59O1xudmFyIHRvQmluZDtcbnZhciBzZWNvbmRCaW5kID0ge307XG5pZiAoaXNQb2ludGVyKSB7XG4gICAgdG9CaW5kID0gZXZlbnRzLnBvaW50ZXI7XG59IGVsc2UgaWYgKGlzTVNQb2ludGVyKSB7XG4gICAgdG9CaW5kID0gZXZlbnRzLk1TUG9pbnRlcjtcbn0gZWxzZSBpZiAoaXNUb3VjaCkge1xuICAgIHRvQmluZCA9IGV2ZW50cy50b3VjaDtcbiAgICBzZWNvbmRCaW5kID0gZXZlbnRzLm1vdXNlO1xufSBlbHNlIHtcbiAgICB0b0JpbmQgPSBldmVudHMubW91c2U7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gICAgICBVVElMUyAgICAgIC8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIHUgPSB7fTtcbnUuZGlzdGFuY2UgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gICAgdmFyIGR5ID0gcDIueSAtIHAxLnk7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KChkeCAqIGR4KSArIChkeSAqIGR5KSk7XG59O1xuXG51LmFuZ2xlID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gICAgdmFyIGR5ID0gcDIueSAtIHAxLnk7XG5cbiAgICByZXR1cm4gdS5kZWdyZWVzKE1hdGguYXRhbjIoZHksIGR4KSk7XG59O1xuXG51LmZpbmRDb29yZCA9IGZ1bmN0aW9uKHAsIGQsIGEpIHtcbiAgICB2YXIgYiA9IHt4OiAwLCB5OiAwfTtcbiAgICBhID0gdS5yYWRpYW5zKGEpO1xuICAgIGIueCA9IHAueCAtIGQgKiBNYXRoLmNvcyhhKTtcbiAgICBiLnkgPSBwLnkgLSBkICogTWF0aC5zaW4oYSk7XG4gICAgcmV0dXJuIGI7XG59O1xuXG51LnJhZGlhbnMgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGEgKiAoTWF0aC5QSSAvIDE4MCk7XG59O1xuXG51LmRlZ3JlZXMgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGEgKiAoMTgwIC8gTWF0aC5QSSk7XG59O1xuXG51LmJpbmRFdnQgPSBmdW5jdGlvbiAoZWwsIGFyZywgaGFuZGxlcikge1xuICAgIHZhciB0eXBlcyA9IGFyZy5zcGxpdCgvWyAsXSsvZyk7XG4gICAgdmFyIHR5cGU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbC5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQodHlwZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG51LnVuYmluZEV2dCA9IGZ1bmN0aW9uIChlbCwgYXJnLCBoYW5kbGVyKSB7XG4gICAgdmFyIHR5cGVzID0gYXJnLnNwbGl0KC9bICxdKy9nKTtcbiAgICB2YXIgdHlwZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgaWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAoZWwuZGV0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGVsLmRldGFjaEV2ZW50KHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudS50cmlnZ2VyID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBkYXRhKSB7XG4gICAgdmFyIGV2dCA9IG5ldyBDdXN0b21FdmVudCh0eXBlLCBkYXRhKTtcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG59O1xuXG51LnByZXBhcmVFdmVudCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gZXZ0LnR5cGUubWF0Y2goL150b3VjaC8pID8gZXZ0LmNoYW5nZWRUb3VjaGVzIDogZXZ0O1xufTtcblxudS5nZXRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHggPSAod2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQpID9cbiAgICAgICAgd2luZG93LnBhZ2VYT2Zmc2V0IDpcbiAgICAgICAgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keSlcbiAgICAgICAgICAgIC5zY3JvbGxMZWZ0O1xuXG4gICAgdmFyIHkgPSAod2luZG93LnBhZ2VZT2Zmc2V0ICE9PSB1bmRlZmluZWQpID9cbiAgICAgICAgd2luZG93LnBhZ2VZT2Zmc2V0IDpcbiAgICAgICAgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keSlcbiAgICAgICAgICAgIC5zY3JvbGxUb3A7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH07XG59O1xuXG51LmFwcGx5UG9zaXRpb24gPSBmdW5jdGlvbiAoZWwsIHBvcykge1xuICAgIGlmIChwb3MudG9wIHx8IHBvcy5yaWdodCB8fCBwb3MuYm90dG9tIHx8IHBvcy5sZWZ0KSB7XG4gICAgICAgIGVsLnN0eWxlLnRvcCA9IHBvcy50b3A7XG4gICAgICAgIGVsLnN0eWxlLnJpZ2h0ID0gcG9zLnJpZ2h0O1xuICAgICAgICBlbC5zdHlsZS5ib3R0b20gPSBwb3MuYm90dG9tO1xuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IHBvcy54ICsgJ3B4JztcbiAgICAgICAgZWwuc3R5bGUudG9wID0gcG9zLnkgKyAncHgnO1xuICAgIH1cbn07XG5cbnUuZ2V0VHJhbnNpdGlvblN0eWxlID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZXMsIHRpbWUpIHtcbiAgICB2YXIgb2JqID0gdS5jb25maWdTdHlsZVByb3BlcnR5T2JqZWN0KHByb3BlcnR5KTtcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBvYmpbaV0gPSB2YWx1ZXMgKyAnICcgKyB0aW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3QgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbWF4ID0gdmFsdWVzLmxlbmd0aDsgaiA8IG1heDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ICs9IHZhbHVlc1tqXSArICcgJyArIHRpbWUgKyAnLCAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmpbaV0gPSBzdC5zbGljZSgwLCAtMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnUuZ2V0VmVuZG9yU3R5bGUgPSBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlKSB7XG4gICAgdmFyIG9iaiA9IHUuY29uZmlnU3R5bGVQcm9wZXJ0eU9iamVjdChwcm9wZXJ0eSk7XG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgb2JqW2ldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnUuY29uZmlnU3R5bGVQcm9wZXJ0eU9iamVjdCA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIG9ialtwcm9wXSA9ICcnO1xuICAgIHZhciB2ZW5kb3JzID0gWyd3ZWJraXQnLCAnTW96JywgJ28nXTtcbiAgICB2ZW5kb3JzLmZvckVhY2goZnVuY3Rpb24gKHZlbmRvcikge1xuICAgICAgICBvYmpbdmVuZG9yICsgcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSldID0gJyc7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnUuZXh0ZW5kID0gZnVuY3Rpb24gKG9iakEsIG9iakIpIHtcbiAgICBmb3IgKHZhciBpIGluIG9iakIpIHtcbiAgICAgICAgaWYgKG9iakIuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIG9iakFbaV0gPSBvYmpCW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmpBO1xufTtcblxuLy8gT3ZlcndyaXRlIG9ubHkgd2hhdCdzIGFscmVhZHkgcHJlc2VudFxudS5zYWZlRXh0ZW5kID0gZnVuY3Rpb24gKG9iakEsIG9iakIpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgZm9yICh2YXIgaSBpbiBvYmpBKSB7XG4gICAgICAgIGlmIChvYmpBLmhhc093blByb3BlcnR5KGkpICYmIG9iakIuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIG9ialtpXSA9IG9iakJbaV07XG4gICAgICAgIH0gZWxzZSBpZiAob2JqQS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgb2JqW2ldID0gb2JqQVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcblxuLy8gTWFwIGZvciBhcnJheSBvciB1bmlxdWUgaXRlbS5cbnUubWFwID0gZnVuY3Rpb24gKGFyLCBmbikge1xuICAgIGlmIChhci5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IGFyLmxlbmd0aDsgaSA8IG1heDsgaSArPSAxKSB7XG4gICAgICAgICAgICBmbihhcltpXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmbihhcik7XG4gICAgfVxufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAgIFNVUEVSIENMQVNTICAgLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBTdXBlciAoKSB7fTtcblxuLy8gQmFzaWMgZXZlbnQgc3lzdGVtLlxuU3VwZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGFyZywgY2IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR5cGVzID0gYXJnLnNwbGl0KC9bICxdKy9nKTtcbiAgICB2YXIgdHlwZTtcbiAgICBzZWxmLl9oYW5kbGVyc18gPSBzZWxmLl9oYW5kbGVyc18gfHwge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgc2VsZi5faGFuZGxlcnNfW3R5cGVdID0gc2VsZi5faGFuZGxlcnNfW3R5cGVdIHx8IFtdO1xuICAgICAgICBzZWxmLl9oYW5kbGVyc19bdHlwZV0ucHVzaChjYik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufTtcblxuU3VwZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLl9oYW5kbGVyc18gPSBzZWxmLl9oYW5kbGVyc18gfHwge307XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGYuX2hhbmRsZXJzXyA9IHt9O1xuICAgIH0gZWxzZSBpZiAoY2IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLl9oYW5kbGVyc19bdHlwZV0gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoc2VsZi5faGFuZGxlcnNfW3R5cGVdICYmXG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVyc19bdHlwZV0uaW5kZXhPZihjYikgPj0gMCkge1xuICAgICAgICBzZWxmLl9oYW5kbGVyc19bdHlwZV0uc3BsaWNlKHNlbGYuX2hhbmRsZXJzX1t0eXBlXS5pbmRleE9mKGNiKSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG59O1xuXG5TdXBlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChhcmcsIGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR5cGVzID0gYXJnLnNwbGl0KC9bICxdKy9nKTtcbiAgICB2YXIgdHlwZTtcbiAgICBzZWxmLl9oYW5kbGVyc18gPSBzZWxmLl9oYW5kbGVyc18gfHwge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgaWYgKHNlbGYuX2hhbmRsZXJzX1t0eXBlXSAmJiBzZWxmLl9oYW5kbGVyc19bdHlwZV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVyc19bdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbChzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogc2VsZlxuICAgICAgICAgICAgICAgIH0sIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBDb25maWd1cmF0aW9uXG5TdXBlci5wcm90b3R5cGUuY29uZmlnID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5vcHRpb25zID0gc2VsZi5kZWZhdWx0cyB8fCB7fTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBzZWxmLm9wdGlvbnMgPSB1LnNhZmVFeHRlbmQoc2VsZi5vcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG59O1xuXG4vLyBCaW5kIGludGVybmFsIGV2ZW50cy5cblN1cGVyLnByb3RvdHlwZS5iaW5kRXZ0ID0gZnVuY3Rpb24gKGVsLCB0eXBlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuX2RvbUhhbmRsZXJzXyA9IHNlbGYuX2RvbUhhbmRsZXJzXyB8fCB7fTtcblxuICAgIHNlbGYuX2RvbUhhbmRsZXJzX1t0eXBlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmWydvbicgKyB0eXBlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2VsZlsnb24nICsgdHlwZV0uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW1dBUk5JTkddIDogTWlzc2luZyBcIm9uJyArIHR5cGUgKyAnXCIgaGFuZGxlci4nKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB1LmJpbmRFdnQoZWwsIHRvQmluZFt0eXBlXSwgc2VsZi5fZG9tSGFuZGxlcnNfW3R5cGVdKTtcblxuICAgIGlmIChzZWNvbmRCaW5kW3R5cGVdKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIGJvdGggdG91Y2ggYW5kIG1vdXNlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgIHUuYmluZEV2dChlbCwgc2Vjb25kQmluZFt0eXBlXSwgc2VsZi5fZG9tSGFuZGxlcnNfW3R5cGVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbn07XG5cbi8vIFVuYmluZCBkb20gZXZlbnRzLlxuU3VwZXIucHJvdG90eXBlLnVuYmluZEV2dCA9IGZ1bmN0aW9uIChlbCwgdHlwZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLl9kb21IYW5kbGVyc18gPSBzZWxmLl9kb21IYW5kbGVyc18gfHwge307XG5cbiAgICB1LnVuYmluZEV2dChlbCwgdG9CaW5kW3R5cGVdLCBzZWxmLl9kb21IYW5kbGVyc19bdHlwZV0pO1xuXG4gICAgaWYgKHNlY29uZEJpbmRbdHlwZV0pIHtcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgYm90aCB0b3VjaCBhbmQgbW91c2UgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgdS51bmJpbmRFdnQoZWwsIHNlY29uZEJpbmRbdHlwZV0sIHNlbGYuX2RvbUhhbmRsZXJzX1t0eXBlXSk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHNlbGYuX2RvbUhhbmRsZXJzX1t0eXBlXTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLyAgIFRIRSBOSVBQTEUgICAgLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBOaXBwbGUgKGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICB0aGlzLmlkZW50aWZpZXIgPSBvcHRpb25zLmlkZW50aWZpZXI7XG4gICAgdGhpcy5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgdGhpcy5mcm9udFBvc2l0aW9uID0gb3B0aW9ucy5mcm9udFBvc2l0aW9uO1xuICAgIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG5cbiAgICAvLyBEZWZhdWx0c1xuICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICAgIHNpemU6IDEwMCxcbiAgICAgICAgdGhyZXNob2xkOiAwLjEsXG4gICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICBmYWRlVGltZTogMjUwLFxuICAgICAgICBkYXRhT25seTogZmFsc2UsXG4gICAgICAgIHJlc3RKb3lzdGljazogdHJ1ZSxcbiAgICAgICAgcmVzdE9wYWNpdHk6IDAuNSxcbiAgICAgICAgbW9kZTogJ2R5bmFtaWMnLFxuICAgICAgICB6b25lOiBkb2N1bWVudC5ib2R5LFxuICAgICAgICBsb2NrWDogZmFsc2UsXG4gICAgICAgIGxvY2tZOiBmYWxzZVxuICAgIH07XG5cbiAgICB0aGlzLmNvbmZpZyhvcHRpb25zKTtcblxuICAgIC8vIE92ZXJ3cml0ZXNcbiAgICBpZiAodGhpcy5vcHRpb25zLm1vZGUgPT09ICdkeW5hbWljJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVzdE9wYWNpdHkgPSAwO1xuICAgIH1cblxuICAgIHRoaXMuaWQgPSBOaXBwbGUuaWQ7XG4gICAgTmlwcGxlLmlkICs9IDE7XG4gICAgdGhpcy5idWlsZEVsKClcbiAgICAgICAgLnN0eWxpemUoKTtcblxuICAgIC8vIE5pcHBsZSdzIEFQSS5cbiAgICB0aGlzLmluc3RhbmNlID0ge1xuICAgICAgICBlbDogdGhpcy51aS5lbCxcbiAgICAgICAgb246IHRoaXMub24uYmluZCh0aGlzKSxcbiAgICAgICAgb2ZmOiB0aGlzLm9mZi5iaW5kKHRoaXMpLFxuICAgICAgICBzaG93OiB0aGlzLnNob3cuYmluZCh0aGlzKSxcbiAgICAgICAgaGlkZTogdGhpcy5oaWRlLmJpbmQodGhpcyksXG4gICAgICAgIGFkZDogdGhpcy5hZGRUb0RvbS5iaW5kKHRoaXMpLFxuICAgICAgICByZW1vdmU6IHRoaXMucmVtb3ZlRnJvbURvbS5iaW5kKHRoaXMpLFxuICAgICAgICBkZXN0cm95OiB0aGlzLmRlc3Ryb3kuYmluZCh0aGlzKSxcbiAgICAgICAgcmVzZXREaXJlY3Rpb246IHRoaXMucmVzZXREaXJlY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgICAgY29tcHV0ZURpcmVjdGlvbjogdGhpcy5jb21wdXRlRGlyZWN0aW9uLmJpbmQodGhpcyksXG4gICAgICAgIHRyaWdnZXI6IHRoaXMudHJpZ2dlci5iaW5kKHRoaXMpLFxuICAgICAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbixcbiAgICAgICAgZnJvbnRQb3NpdGlvbjogdGhpcy5mcm9udFBvc2l0aW9uLFxuICAgICAgICB1aTogdGhpcy51aSxcbiAgICAgICAgaWRlbnRpZmllcjogdGhpcy5pZGVudGlmaWVyLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xufTtcblxuTmlwcGxlLnByb3RvdHlwZSA9IG5ldyBTdXBlcigpO1xuTmlwcGxlLmNvbnN0cnVjdG9yID0gTmlwcGxlO1xuTmlwcGxlLmlkID0gMDtcblxuLy8gQnVpbGQgdGhlIGRvbSBlbGVtZW50IG9mIHRoZSBOaXBwbGUgaW5zdGFuY2UuXG5OaXBwbGUucHJvdG90eXBlLmJ1aWxkRWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMudWkgPSB7fTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGF0YU9ubHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy51aS5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMudWkuYmFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMudWkuZnJvbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHRoaXMudWkuZWwuY2xhc3NOYW1lID0gJ25pcHBsZSBjb2xsZWN0aW9uXycgKyB0aGlzLmNvbGxlY3Rpb24uaWQ7XG4gICAgdGhpcy51aS5iYWNrLmNsYXNzTmFtZSA9ICdiYWNrJztcbiAgICB0aGlzLnVpLmZyb250LmNsYXNzTmFtZSA9ICdmcm9udCc7XG5cbiAgICB0aGlzLnVpLmVsLnNldEF0dHJpYnV0ZSgnaWQnLCAnbmlwcGxlXycgKyB0aGlzLmNvbGxlY3Rpb24uaWQgK1xuICAgICAgICAnXycgKyB0aGlzLmlkKTtcblxuICAgIHRoaXMudWkuZWwuYXBwZW5kQ2hpbGQodGhpcy51aS5iYWNrKTtcbiAgICB0aGlzLnVpLmVsLmFwcGVuZENoaWxkKHRoaXMudWkuZnJvbnQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBBcHBseSBDU1MgdG8gdGhlIE5pcHBsZSBpbnN0YW5jZS5cbk5pcHBsZS5wcm90b3R5cGUuc3R5bGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRhdGFPbmx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgYW5pbVRpbWUgPSB0aGlzLm9wdGlvbnMuZmFkZVRpbWUgKyAnbXMnO1xuICAgIHZhciBib3JkZXJTdHlsZSA9IHUuZ2V0VmVuZG9yU3R5bGUoJ2JvcmRlclJhZGl1cycsICc1MCUnKTtcbiAgICB2YXIgdHJhbnNpdFN0eWxlID0gdS5nZXRUcmFuc2l0aW9uU3R5bGUoJ3RyYW5zaXRpb24nLCAnb3BhY2l0eScsIGFuaW1UaW1lKTtcbiAgICB2YXIgc3R5bGVzID0ge307XG4gICAgc3R5bGVzLmVsID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgb3BhY2l0eTogdGhpcy5vcHRpb25zLnJlc3RPcGFjaXR5LFxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAnekluZGV4JzogOTk5XG4gICAgfTtcblxuICAgIHN0eWxlcy5iYWNrID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgd2lkdGg6IHRoaXMub3B0aW9ucy5zaXplICsgJ3B4JyxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLm9wdGlvbnMuc2l6ZSArICdweCcsXG4gICAgICAgIG1hcmdpbkxlZnQ6IC10aGlzLm9wdGlvbnMuc2l6ZSAvIDIgKyAncHgnLFxuICAgICAgICBtYXJnaW5Ub3A6IC10aGlzLm9wdGlvbnMuc2l6ZSAvIDIgKyAncHgnLFxuICAgICAgICBiYWNrZ3JvdW5kOiB0aGlzLm9wdGlvbnMuY29sb3IsXG4gICAgICAgICdvcGFjaXR5JzogJy41J1xuICAgIH07XG5cbiAgICBzdHlsZXMuZnJvbnQgPSB7XG4gICAgICAgIHdpZHRoOiB0aGlzLm9wdGlvbnMuc2l6ZSAvIDIgKyAncHgnLFxuICAgICAgICBoZWlnaHQ6IHRoaXMub3B0aW9ucy5zaXplIC8gMiArICdweCcsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBtYXJnaW5MZWZ0OiAtdGhpcy5vcHRpb25zLnNpemUgLyA0ICsgJ3B4JyxcbiAgICAgICAgbWFyZ2luVG9wOiAtdGhpcy5vcHRpb25zLnNpemUgLyA0ICsgJ3B4JyxcbiAgICAgICAgYmFja2dyb3VuZDogdGhpcy5vcHRpb25zLmNvbG9yLFxuICAgICAgICAnb3BhY2l0eSc6ICcuNSdcbiAgICB9O1xuXG4gICAgdS5leHRlbmQoc3R5bGVzLmVsLCB0cmFuc2l0U3R5bGUpO1xuICAgIHUuZXh0ZW5kKHN0eWxlcy5iYWNrLCBib3JkZXJTdHlsZSk7XG4gICAgdS5leHRlbmQoc3R5bGVzLmZyb250LCBib3JkZXJTdHlsZSk7XG5cbiAgICB0aGlzLmFwcGx5U3R5bGVzKHN0eWxlcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk5pcHBsZS5wcm90b3R5cGUuYXBwbHlTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgLy8gQXBwbHkgc3R5bGVzXG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLnVpKSB7XG4gICAgICAgIGlmICh0aGlzLnVpLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqIGluIHN0eWxlc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMudWlbaV0uc3R5bGVbal0gPSBzdHlsZXNbaV1bal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIEluamVjdCB0aGUgTmlwcGxlIGluc3RhbmNlIGludG8gRE9NLlxuTmlwcGxlLnByb3RvdHlwZS5hZGRUb0RvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBXZSdyZSBub3QgYWRkaW5nIGl0IGlmIHdlJ3JlIGRhdGFPbmx5IG9yIGFscmVhZHkgaW4gZG9tLlxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGF0YU9ubHkgfHwgZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnVpLmVsKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLnpvbmUuYXBwZW5kQ2hpbGQodGhpcy51aS5lbCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBSZW1vdmUgdGhlIE5pcHBsZSBpbnN0YW5jZSBmcm9tIERPTS5cbk5pcHBsZS5wcm90b3R5cGUucmVtb3ZlRnJvbURvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRhdGFPbmx5IHx8ICFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMudWkuZWwpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMuem9uZS5yZW1vdmVDaGlsZCh0aGlzLnVpLmVsKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIEVudGlyZWx5IGRlc3Ryb3kgdGhpcyBuaXBwbGVcbk5pcHBsZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZW1vdmVUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5zaG93VGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzdFRpbWVvdXQpO1xuICAgIHRoaXMudHJpZ2dlcignZGVzdHJveWVkJywgdGhpcy5pbnN0YW5jZSk7XG4gICAgdGhpcy5yZW1vdmVGcm9tRG9tKCk7XG4gICAgdGhpcy5vZmYoKTtcbn07XG5cbi8vIEZhZGUgaW4gdGhlIE5pcHBsZSBpbnN0YW5jZS5cbk5pcHBsZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChzZWxmLm9wdGlvbnMuZGF0YU9ubHkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHNlbGYucmVtb3ZlVGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KHNlbGYuc2hvd1RpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dChzZWxmLnJlc3RUaW1lb3V0KTtcblxuICAgIHNlbGYuYWRkVG9Eb20oKTtcblxuICAgIHNlbGYucmVzdENhbGxiYWNrKCk7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi51aS5lbC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICB9LCAwKTtcblxuICAgIHNlbGYuc2hvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdzaG93bicsIHNlbGYuaW5zdGFuY2UpO1xuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYi5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSwgc2VsZi5vcHRpb25zLmZhZGVUaW1lKTtcblxuICAgIHJldHVybiBzZWxmO1xufTtcblxuLy8gRmFkZSBvdXQgdGhlIE5pcHBsZSBpbnN0YW5jZS5cbk5pcHBsZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChzZWxmLm9wdGlvbnMuZGF0YU9ubHkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgc2VsZi51aS5lbC5zdHlsZS5vcGFjaXR5ID0gc2VsZi5vcHRpb25zLnJlc3RPcGFjaXR5O1xuXG4gICAgY2xlYXJUaW1lb3V0KHNlbGYucmVtb3ZlVGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KHNlbGYuc2hvd1RpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dChzZWxmLnJlc3RUaW1lb3V0KTtcblxuICAgIHNlbGYucmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5ID0gc2VsZi5vcHRpb25zLm1vZGUgPT09ICdkeW5hbWljJyA/ICdub25lJyA6ICdibG9jayc7XG4gICAgICAgICAgICBzZWxmLnVpLmVsLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoc2VsZik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignaGlkZGVuJywgc2VsZi5pbnN0YW5jZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGYub3B0aW9ucy5mYWRlVGltZVxuICAgICk7XG4gICAgaWYgKHNlbGYub3B0aW9ucy5yZXN0Sm95c3RpY2spIHtcbiAgICAgICAgc2VsZi5yZXN0UG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbn07XG5cbk5pcHBsZS5wcm90b3R5cGUucmVzdFBvc2l0aW9uID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuZnJvbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgIH07XG4gICAgdmFyIGFuaW1UaW1lID0gc2VsZi5vcHRpb25zLmZhZGVUaW1lICsgJ21zJztcblxuICAgIHZhciB0cmFuc2l0U3R5bGUgPSB7fTtcbiAgICB0cmFuc2l0U3R5bGUuZnJvbnQgPSB1LmdldFRyYW5zaXRpb25TdHlsZSgndHJhbnNpdGlvbicsXG4gICAgICAgIFsndG9wJywgJ2xlZnQnXSwgYW5pbVRpbWUpO1xuXG4gICAgdmFyIHN0eWxlcyA9IHtmcm9udDoge319O1xuICAgIHN0eWxlcy5mcm9udCA9IHtcbiAgICAgICAgbGVmdDogc2VsZi5mcm9udFBvc2l0aW9uLnggKyAncHgnLFxuICAgICAgICB0b3A6IHNlbGYuZnJvbnRQb3NpdGlvbi55ICsgJ3B4J1xuICAgIH07XG5cbiAgICBzZWxmLmFwcGx5U3R5bGVzKHRyYW5zaXRTdHlsZSk7XG4gICAgc2VsZi5hcHBseVN0eWxlcyhzdHlsZXMpO1xuXG4gICAgc2VsZi5yZXN0VGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yZXN0Q2FsbGJhY2soKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZi5vcHRpb25zLmZhZGVUaW1lXG4gICAgKTtcbn07XG5cbk5pcHBsZS5wcm90b3R5cGUucmVzdENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHJhbnNpdFN0eWxlID0ge307XG4gICAgdHJhbnNpdFN0eWxlLmZyb250ID0gdS5nZXRUcmFuc2l0aW9uU3R5bGUoJ3RyYW5zaXRpb24nLCAnbm9uZScsICcnKTtcbiAgICBzZWxmLmFwcGx5U3R5bGVzKHRyYW5zaXRTdHlsZSk7XG4gICAgc2VsZi50cmlnZ2VyKCdyZXN0ZWQnLCBzZWxmLmluc3RhbmNlKTtcbn07XG5cbk5pcHBsZS5wcm90b3R5cGUucmVzZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRnVsbHkgcmVidWlsZCB0aGUgb2JqZWN0IHRvIGxldCB0aGUgaXRlcmF0aW9uIHBvc3NpYmxlLlxuICAgIHRoaXMuZGlyZWN0aW9uID0ge1xuICAgICAgICB4OiBmYWxzZSxcbiAgICAgICAgeTogZmFsc2UsXG4gICAgICAgIGFuZ2xlOiBmYWxzZVxuICAgIH07XG59O1xuXG5OaXBwbGUucHJvdG90eXBlLmNvbXB1dGVEaXJlY3Rpb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJBbmdsZSA9IG9iai5hbmdsZS5yYWRpYW47XG4gICAgdmFyIGFuZ2xlNDUgPSBNYXRoLlBJIC8gNDtcbiAgICB2YXIgYW5nbGU5MCA9IE1hdGguUEkgLyAyO1xuICAgIHZhciBkaXJlY3Rpb24sIGRpcmVjdGlvblgsIGRpcmVjdGlvblk7XG5cbiAgICAvLyBBbmd1bGFyIGRpcmVjdGlvblxuICAgIC8vICAgICBcXCAgVVAgL1xuICAgIC8vICAgICAgXFwgICAvXG4gICAgLy8gTEVGVCAgICAgICBSSUdIVFxuICAgIC8vICAgICAgLyAgIFxcXG4gICAgLy8gICAgIC9ET1dOIFxcXG4gICAgLy9cbiAgICBpZiAoXG4gICAgICAgIHJBbmdsZSA+IGFuZ2xlNDUgJiZcbiAgICAgICAgckFuZ2xlIDwgKGFuZ2xlNDUgKiAzKSAmJlxuICAgICAgICAhb2JqLmxvY2tYXG4gICAgKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICd1cCc7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgckFuZ2xlID4gLWFuZ2xlNDUgJiZcbiAgICAgICAgckFuZ2xlIDw9IGFuZ2xlNDUgJiZcbiAgICAgICAgIW9iai5sb2NrWVxuICAgICkge1xuICAgICAgICBkaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgckFuZ2xlID4gKC1hbmdsZTQ1ICogMykgJiZcbiAgICAgICAgckFuZ2xlIDw9IC1hbmdsZTQ1ICYmXG4gICAgICAgICFvYmoubG9ja1hcbiAgICApIHtcbiAgICAgICAgZGlyZWN0aW9uID0gJ2Rvd24nO1xuICAgIH0gZWxzZSBpZiAoIW9iai5sb2NrWSkge1xuICAgICAgICBkaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgIH1cblxuICAgIC8vIFBsYWluIGRpcmVjdGlvblxuICAgIC8vICAgIFVQICAgICAgICAgICAgICAgICB8XG4gICAgLy8gX19fX19fXyAgICAgICAgICAgICAgIHwgUklHSFRcbiAgICAvLyAgICAgICAgICAgICAgICAgIExFRlQgfFxuICAgIC8vICAgRE9XTiAgICAgICAgICAgICAgICB8XG4gICAgaWYgKCFvYmoubG9ja1kpIHtcbiAgICAgICAgaWYgKHJBbmdsZSA+IC1hbmdsZTkwICYmIHJBbmdsZSA8IGFuZ2xlOTApIHtcbiAgICAgICAgICAgIGRpcmVjdGlvblggPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXJlY3Rpb25YID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghb2JqLmxvY2tYKSB7XG4gICAgICAgIGlmIChyQW5nbGUgPiAwKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb25ZID0gJ3VwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpcmVjdGlvblkgPSAnZG93bic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2JqLmZvcmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCkge1xuICAgICAgICB2YXIgb2xkRGlyZWN0aW9uID0ge307XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbi5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIG9sZERpcmVjdGlvbltpXSA9IHRoaXMuZGlyZWN0aW9uW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNhbWUgPSB7fTtcblxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IGRpcmVjdGlvblgsXG4gICAgICAgICAgICB5OiBkaXJlY3Rpb25ZLFxuICAgICAgICAgICAgYW5nbGU6IGRpcmVjdGlvblxuICAgICAgICB9O1xuXG4gICAgICAgIG9iai5kaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcblxuICAgICAgICBmb3IgKHZhciBpIGluIG9sZERpcmVjdGlvbikge1xuICAgICAgICAgICAgaWYgKG9sZERpcmVjdGlvbltpXSA9PT0gdGhpcy5kaXJlY3Rpb25baV0pIHtcbiAgICAgICAgICAgICAgICBzYW1lW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGFsbCAzIGRpcmVjdGlvbnMgYXJlIHRoZSBzYW1lLCB3ZSBkb24ndCB0cmlnZ2VyIGFueXRoaW5nLlxuICAgICAgICBpZiAoc2FtZS54ICYmIHNhbWUueSAmJiBzYW1lLmFuZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzYW1lLnggfHwgIXNhbWUueSkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdwbGFpbicsIG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNhbWUueCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdwbGFpbjonICsgZGlyZWN0aW9uWCwgb2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2FtZS55KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3BsYWluOicgKyBkaXJlY3Rpb25ZLCBvYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzYW1lLmFuZ2xlKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2RpciBkaXI6JyArIGRpcmVjdGlvbiwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcblxuLyogZ2xvYmFsIE5pcHBsZSwgU3VwZXIgKi9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gICBUSEUgQ09MTEVDVElPTiAgICAvLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBDb2xsZWN0aW9uIChtYW5hZ2VyLCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYubmlwcGxlcyA9IFtdO1xuICAgIHNlbGYuaWRsZXMgPSBbXTtcbiAgICBzZWxmLmFjdGl2ZXMgPSBbXTtcbiAgICBzZWxmLmlkcyA9IFtdO1xuICAgIHNlbGYucHJlc3N1cmVJbnRlcnZhbHMgPSB7fTtcbiAgICBzZWxmLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHNlbGYuaWQgPSBDb2xsZWN0aW9uLmlkO1xuICAgIENvbGxlY3Rpb24uaWQgKz0gMTtcblxuICAgIC8vIERlZmF1bHRzXG4gICAgc2VsZi5kZWZhdWx0cyA9IHtcbiAgICAgICAgem9uZTogZG9jdW1lbnQuYm9keSxcbiAgICAgICAgbXVsdGl0b3VjaDogZmFsc2UsXG4gICAgICAgIG1heE51bWJlck9mTmlwcGxlczogMTAsXG4gICAgICAgIG1vZGU6ICdkeW5hbWljJyxcbiAgICAgICAgcG9zaXRpb246IHt0b3A6IDAsIGxlZnQ6IDB9LFxuICAgICAgICBjYXRjaERpc3RhbmNlOiAyMDAsXG4gICAgICAgIHNpemU6IDEwMCxcbiAgICAgICAgdGhyZXNob2xkOiAwLjEsXG4gICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICBmYWRlVGltZTogMjUwLFxuICAgICAgICBkYXRhT25seTogZmFsc2UsXG4gICAgICAgIHJlc3RKb3lzdGljazogdHJ1ZSxcbiAgICAgICAgcmVzdE9wYWNpdHk6IDAuNSxcbiAgICAgICAgbG9ja1g6IGZhbHNlLFxuICAgICAgICBsb2NrWTogZmFsc2VcbiAgICB9O1xuXG4gICAgc2VsZi5jb25maWcob3B0aW9ucyk7XG5cbiAgICAvLyBPdmVyd3JpdGVzXG4gICAgaWYgKHNlbGYub3B0aW9ucy5tb2RlID09PSAnc3RhdGljJyB8fCBzZWxmLm9wdGlvbnMubW9kZSA9PT0gJ3NlbWknKSB7XG4gICAgICAgIHNlbGYub3B0aW9ucy5tdWx0aXRvdWNoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMubXVsdGl0b3VjaCkge1xuICAgICAgICBzZWxmLm9wdGlvbnMubWF4TnVtYmVyT2ZOaXBwbGVzID0gMTtcbiAgICB9XG5cbiAgICBzZWxmLnVwZGF0ZUJveCgpO1xuICAgIHNlbGYucHJlcGFyZU5pcHBsZXMoKTtcbiAgICBzZWxmLmJpbmRpbmdzKCk7XG4gICAgc2VsZi5iZWdpbigpO1xuXG4gICAgcmV0dXJuIHNlbGYubmlwcGxlcztcbn1cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBuZXcgU3VwZXIoKTtcbkNvbGxlY3Rpb24uY29uc3RydWN0b3IgPSBDb2xsZWN0aW9uO1xuQ29sbGVjdGlvbi5pZCA9IDA7XG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnByZXBhcmVOaXBwbGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbmlwcyA9IHNlbGYubmlwcGxlcztcblxuICAgIC8vIFB1YmxpYyBBUEkgUHJlcGFyYXRpb24uXG4gICAgbmlwcy5vbiA9IHNlbGYub24uYmluZChzZWxmKTtcbiAgICBuaXBzLm9mZiA9IHNlbGYub2ZmLmJpbmQoc2VsZik7XG4gICAgbmlwcy5vcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIG5pcHMuZGVzdHJveSA9IHNlbGYuZGVzdHJveS5iaW5kKHNlbGYpO1xuICAgIG5pcHMuaWRzID0gc2VsZi5pZHM7XG4gICAgbmlwcy5pZCA9IHNlbGYuaWQ7XG4gICAgbmlwcy5wcm9jZXNzT25Nb3ZlID0gc2VsZi5wcm9jZXNzT25Nb3ZlLmJpbmQoc2VsZik7XG4gICAgbmlwcy5wcm9jZXNzT25FbmQgPSBzZWxmLnByb2Nlc3NPbkVuZC5iaW5kKHNlbGYpO1xuICAgIG5pcHMuZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlwc1swXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gbmlwcy5sZW5ndGg7IGkgPCBtYXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKG5pcHNbaV0uaWRlbnRpZmllciA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmlwc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn07XG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmJpbmRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBUb3VjaCBzdGFydCBldmVudC5cbiAgICBzZWxmLmJpbmRFdnQoc2VsZi5vcHRpb25zLnpvbmUsICdzdGFydCcpO1xuICAgIC8vIEF2b2lkIG5hdGl2ZSB0b3VjaCBhY3Rpb25zIChzY3JvbGwsIHpvb20gZXRjLi4uKSBvbiB0aGUgem9uZS5cbiAgICBzZWxmLm9wdGlvbnMuem9uZS5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJztcbiAgICBzZWxmLm9wdGlvbnMuem9uZS5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xufTtcblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvcHRzID0gc2VsZi5vcHRpb25zO1xuXG4gICAgLy8gV2UgcGxhY2Ugb3VyIHN0YXRpYyBuaXBwbGVcbiAgICAvLyBpZiBuZWVkZWQuXG4gICAgaWYgKG9wdHMubW9kZSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgdmFyIG5pcHBsZSA9IHNlbGYuY3JlYXRlTmlwcGxlKFxuICAgICAgICAgICAgb3B0cy5wb3NpdGlvbixcbiAgICAgICAgICAgIHNlbGYubWFuYWdlci5nZXRJZGVudGlmaWVyKClcbiAgICAgICAgKTtcbiAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBkb20uXG4gICAgICAgIG5pcHBsZS5hZGQoKTtcbiAgICAgICAgLy8gU3RvcmUgaXQgaW4gaWRsZXMuXG4gICAgICAgIHNlbGYuaWRsZXMucHVzaChuaXBwbGUpO1xuICAgIH1cbn07XG5cbi8vIE5pcHBsZSBGYWN0b3J5XG5Db2xsZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVOaXBwbGUgPSBmdW5jdGlvbiAocG9zaXRpb24sIGlkZW50aWZpZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNjcm9sbCA9IHUuZ2V0U2Nyb2xsKCk7XG4gICAgdmFyIHRvUHV0T24gPSB7fTtcbiAgICB2YXIgb3B0cyA9IHNlbGYub3B0aW9ucztcblxuICAgIGlmIChwb3NpdGlvbi54ICYmIHBvc2l0aW9uLnkpIHtcbiAgICAgICAgdG9QdXRPbiA9IHtcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uLnggLVxuICAgICAgICAgICAgICAgIChzY3JvbGwueCArIHNlbGYuYm94LmxlZnQpLFxuICAgICAgICAgICAgeTogcG9zaXRpb24ueSAtXG4gICAgICAgICAgICAgICAgKHNjcm9sbC55ICsgc2VsZi5ib3gudG9wKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBwb3NpdGlvbi50b3AgfHxcbiAgICAgICAgICAgIHBvc2l0aW9uLnJpZ2h0IHx8XG4gICAgICAgICAgICBwb3NpdGlvbi5ib3R0b20gfHxcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlZnRcbiAgICAgICAgKSB7XG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBwb3NpdGlvbiBYIC8gWSBvZiB0aGUgam95c3RpY2suXG4gICAgICAgIHZhciBkdW1iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICAgIGR1bWIuc3R5bGUuZGlzcGxheSA9ICdoaWRkZW4nO1xuICAgICAgICBkdW1iLnN0eWxlLnRvcCA9IHBvc2l0aW9uLnRvcDtcbiAgICAgICAgZHVtYi5zdHlsZS5yaWdodCA9IHBvc2l0aW9uLnJpZ2h0O1xuICAgICAgICBkdW1iLnN0eWxlLmJvdHRvbSA9IHBvc2l0aW9uLmJvdHRvbTtcbiAgICAgICAgZHVtYi5zdHlsZS5sZWZ0ID0gcG9zaXRpb24ubGVmdDtcbiAgICAgICAgZHVtYi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICAgICAgb3B0cy56b25lLmFwcGVuZENoaWxkKGR1bWIpO1xuICAgICAgICB2YXIgZHVtYkJveCA9IGR1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIG9wdHMuem9uZS5yZW1vdmVDaGlsZChkdW1iKTtcblxuICAgICAgICB0b1B1dE9uID0gcG9zaXRpb247XG4gICAgICAgIHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogZHVtYkJveC5sZWZ0ICsgc2Nyb2xsLngsXG4gICAgICAgICAgICB5OiBkdW1iQm94LnRvcCArIHNjcm9sbC55XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG5pcHBsZSA9IG5ldyBOaXBwbGUoc2VsZiwge1xuICAgICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgICAgc2l6ZTogb3B0cy5zaXplLFxuICAgICAgICB0aHJlc2hvbGQ6IG9wdHMudGhyZXNob2xkLFxuICAgICAgICBmYWRlVGltZTogb3B0cy5mYWRlVGltZSxcbiAgICAgICAgZGF0YU9ubHk6IG9wdHMuZGF0YU9ubHksXG4gICAgICAgIHJlc3RKb3lzdGljazogb3B0cy5yZXN0Sm95c3RpY2ssXG4gICAgICAgIHJlc3RPcGFjaXR5OiBvcHRzLnJlc3RPcGFjaXR5LFxuICAgICAgICBtb2RlOiBvcHRzLm1vZGUsXG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgem9uZTogb3B0cy56b25lLFxuICAgICAgICBmcm9udFBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIW9wdHMuZGF0YU9ubHkpIHtcbiAgICAgICAgdS5hcHBseVBvc2l0aW9uKG5pcHBsZS51aS5lbCwgdG9QdXRPbik7XG4gICAgICAgIHUuYXBwbHlQb3NpdGlvbihuaXBwbGUudWkuZnJvbnQsIG5pcHBsZS5mcm9udFBvc2l0aW9uKTtcbiAgICB9XG4gICAgc2VsZi5uaXBwbGVzLnB1c2gobmlwcGxlKTtcbiAgICBzZWxmLnRyaWdnZXIoJ2FkZGVkICcgKyBuaXBwbGUuaWRlbnRpZmllciArICc6YWRkZWQnLCBuaXBwbGUpO1xuICAgIHNlbGYubWFuYWdlci50cmlnZ2VyKCdhZGRlZCAnICsgbmlwcGxlLmlkZW50aWZpZXIgKyAnOmFkZGVkJywgbmlwcGxlKTtcblxuICAgIHNlbGYuYmluZE5pcHBsZShuaXBwbGUpO1xuXG4gICAgcmV0dXJuIG5pcHBsZTtcbn07XG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZUJveCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5ib3ggPSBzZWxmLm9wdGlvbnMuem9uZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn07XG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmJpbmROaXBwbGUgPSBmdW5jdGlvbiAobmlwcGxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0eXBlO1xuICAgIC8vIEJ1YmJsZSB1cCBpZGVudGlmaWVkIGV2ZW50cy5cbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChldnQsIGRhdGEpIHtcbiAgICAgICAgLy8gSWRlbnRpZnkgdGhlIGV2ZW50IHR5cGUgd2l0aCB0aGUgbmlwcGxlJ3MgaWQuXG4gICAgICAgIHR5cGUgPSBldnQudHlwZSArICcgJyArIGRhdGEuaWQgKyAnOicgKyBldnQudHlwZTtcbiAgICAgICAgc2VsZi50cmlnZ2VyKHR5cGUsIGRhdGEpO1xuICAgIH07XG5cbiAgICAvLyBXaGVuIGl0IGdldHMgZGVzdHJveWVkLlxuICAgIG5pcHBsZS5vbignZGVzdHJveWVkJywgc2VsZi5vbkRlc3Ryb3llZC5iaW5kKHNlbGYpKTtcblxuICAgIC8vIE90aGVyIGV2ZW50cyB0aGF0IHdpbGwgZ2V0IGJ1YmJsZWQgdXAuXG4gICAgbmlwcGxlLm9uKCdzaG93biBoaWRkZW4gcmVzdGVkIGRpciBwbGFpbicsIGhhbmRsZXIpO1xuICAgIG5pcHBsZS5vbignZGlyOnVwIGRpcjpyaWdodCBkaXI6ZG93biBkaXI6bGVmdCcsIGhhbmRsZXIpO1xuICAgIG5pcHBsZS5vbigncGxhaW46dXAgcGxhaW46cmlnaHQgcGxhaW46ZG93biBwbGFpbjpsZWZ0JywgaGFuZGxlcik7XG59O1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5wcmVzc3VyZUZuID0gZnVuY3Rpb24gKHRvdWNoLCBuaXBwbGUsIGlkZW50aWZpZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByZXZpb3VzUHJlc3N1cmUgPSAwO1xuICAgIGNsZWFySW50ZXJ2YWwoc2VsZi5wcmVzc3VyZUludGVydmFsc1tpZGVudGlmaWVyXSk7XG4gICAgLy8gQ3JlYXRlIGFuIGludGVydmFsIHRoYXQgd2lsbCByZWFkIHRoZSBwcmVzc3VyZSBldmVyeSAxMDBtc1xuICAgIHNlbGYucHJlc3N1cmVJbnRlcnZhbHNbaWRlbnRpZmllcl0gPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmVzc3VyZSA9IHRvdWNoLmZvcmNlIHx8IHRvdWNoLnByZXNzdXJlIHx8XG4gICAgICAgICAgICB0b3VjaC53ZWJraXRGb3JjZSB8fCAwO1xuICAgICAgICBpZiAocHJlc3N1cmUgIT09IHByZXZpb3VzUHJlc3N1cmUpIHtcbiAgICAgICAgICAgIG5pcHBsZS50cmlnZ2VyKCdwcmVzc3VyZScsIHByZXNzdXJlKTtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcigncHJlc3N1cmUgJyArXG4gICAgICAgICAgICAgICAgbmlwcGxlLmlkZW50aWZpZXIgKyAnOnByZXNzdXJlJywgcHJlc3N1cmUpO1xuICAgICAgICAgICAgcHJldmlvdXNQcmVzc3VyZSA9IHByZXNzdXJlO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHNlbGYpLCAxMDApO1xufTtcblxuQ29sbGVjdGlvbi5wcm90b3R5cGUub25zdGFydCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG9wdHMgPSBzZWxmLm9wdGlvbnM7XG4gICAgZXZ0ID0gdS5wcmVwYXJlRXZlbnQoZXZ0KTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYm94IHBvc2l0aW9uXG4gICAgc2VsZi51cGRhdGVCb3goKTtcblxuICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICAgIC8vIElmIHdlIGNhbiBjcmVhdGUgbmV3IG5pcHBsZXNcbiAgICAgICAgLy8gbWVhbmluZyB3ZSBkb24ndCBoYXZlIG1vcmUgYWN0aXZlIG5pcHBsZXMgdGhhbiB3ZSBzaG91bGQuXG4gICAgICAgIGlmIChzZWxmLmFjdGl2ZXMubGVuZ3RoIDwgb3B0cy5tYXhOdW1iZXJPZk5pcHBsZXMpIHtcbiAgICAgICAgICAgIHNlbGYucHJvY2Vzc09uU3RhcnQodG91Y2gpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHUubWFwKGV2dCwgcHJvY2Vzcyk7XG5cbiAgICAvLyBXZSBhc2sgdXBzdHJlYW0gdG8gYmluZCB0aGUgZG9jdW1lbnRcbiAgICAvLyBvbiAnbW92ZScgYW5kICdlbmQnXG4gICAgc2VsZi5tYW5hZ2VyLmJpbmREb2N1bWVudCgpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnByb2Nlc3NPblN0YXJ0ID0gZnVuY3Rpb24gKGV2dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb3B0cyA9IHNlbGYub3B0aW9ucztcbiAgICB2YXIgaW5kZXhJbklkbGVzO1xuICAgIHZhciBpZGVudGlmaWVyID0gc2VsZi5tYW5hZ2VyLmdldElkZW50aWZpZXIoZXZ0KTtcbiAgICB2YXIgcHJlc3N1cmUgPSBldnQuZm9yY2UgfHwgZXZ0LnByZXNzdXJlIHx8IGV2dC53ZWJraXRGb3JjZSB8fCAwO1xuICAgIHZhciBwb3NpdGlvbiA9IHtcbiAgICAgICAgeDogZXZ0LnBhZ2VYLFxuICAgICAgICB5OiBldnQucGFnZVlcbiAgICB9O1xuXG4gICAgdmFyIG5pcHBsZSA9IHNlbGYuZ2V0T3JDcmVhdGUoaWRlbnRpZmllciwgcG9zaXRpb24pO1xuXG4gICAgLy8gVXBkYXRlIGl0cyB0b3VjaCBpZGVudGlmaWVyXG4gICAgaWYgKG5pcHBsZS5pZGVudGlmaWVyICE9PSBpZGVudGlmaWVyKSB7XG4gICAgICAgIHNlbGYubWFuYWdlci5yZW1vdmVJZGVudGlmaWVyKG5pcHBsZS5pZGVudGlmaWVyKTtcbiAgICB9XG4gICAgbmlwcGxlLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuXG4gICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAobmlwKSB7XG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIHN0YXJ0LlxuICAgICAgICBuaXAudHJpZ2dlcignc3RhcnQnLCBuaXApO1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ3N0YXJ0ICcgKyBuaXAuaWQgKyAnOnN0YXJ0JywgbmlwKTtcblxuICAgICAgICBuaXAuc2hvdygpO1xuICAgICAgICBpZiAocHJlc3N1cmUgPiAwKSB7XG4gICAgICAgICAgICBzZWxmLnByZXNzdXJlRm4oZXZ0LCBuaXAsIG5pcC5pZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBmaXJzdCBtb3ZlIGV2ZW50LlxuICAgICAgICBzZWxmLnByb2Nlc3NPbk1vdmUoZXZ0KTtcbiAgICB9O1xuXG4gICAgLy8gVHJhbnNmZXIgaXQgZnJvbSBpZGxlcyB0byBhY3RpdmVzLlxuICAgIGlmICgoaW5kZXhJbklkbGVzID0gc2VsZi5pZGxlcy5pbmRleE9mKG5pcHBsZSkpID49IDApIHtcbiAgICAgICAgc2VsZi5pZGxlcy5zcGxpY2UoaW5kZXhJbklkbGVzLCAxKTtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgbmlwcGxlIGluIHRoZSBhY3RpdmVzIGFycmF5XG4gICAgc2VsZi5hY3RpdmVzLnB1c2gobmlwcGxlKTtcbiAgICBzZWxmLmlkcy5wdXNoKG5pcHBsZS5pZGVudGlmaWVyKTtcblxuICAgIGlmIChvcHRzLm1vZGUgIT09ICdzZW1pJykge1xuICAgICAgICBwcm9jZXNzKG5pcHBsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gc2VtaSB3ZSBjaGVjayB0aGUgZGlzdGFuY2Ugb2YgdGhlIHRvdWNoXG4gICAgICAgIC8vIHRvIGRlY2lkZSBpZiB3ZSBoYXZlIHRvIHJlc2V0IHRoZSBuaXBwbGVcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gdS5kaXN0YW5jZShwb3NpdGlvbiwgbmlwcGxlLnBvc2l0aW9uKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDw9IG9wdHMuY2F0Y2hEaXN0YW5jZSkge1xuICAgICAgICAgICAgcHJvY2VzcyhuaXBwbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmlwcGxlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHNlbGYucHJvY2Vzc09uU3RhcnQoZXZ0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuaXBwbGU7XG59O1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5nZXRPckNyZWF0ZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBwb3NpdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb3B0cyA9IHNlbGYub3B0aW9ucztcbiAgICB2YXIgbmlwcGxlO1xuXG4gICAgLy8gSWYgd2UncmUgaW4gc3RhdGljIG9yIHNlbWksIHdlIG1pZ2h0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUuXG4gICAgaWYgKC8oc2VtaXxzdGF0aWMpLy50ZXN0KG9wdHMubW9kZSkpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBhY3RpdmUgb25lLlxuICAgICAgICAvLyBUT0RPOiBNdWx0aS10b3VjaGUgZm9yIHNlbWkgYW5kIHN0YXRpYyB3aWxsIHN0YXJ0IGhlcmUuXG4gICAgICAgIC8vIFJldHVybiB0aGUgbmVhcmVzdCBvbmUuXG4gICAgICAgIG5pcHBsZSA9IHNlbGYuaWRsZXNbMF07XG4gICAgICAgIGlmIChuaXBwbGUpIHtcbiAgICAgICAgICAgIHNlbGYuaWRsZXMuc3BsaWNlKDAsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG5pcHBsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLm1vZGUgPT09ICdzZW1pJykge1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgaW4gc2VtaSBtb2RlLCB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmUuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jcmVhdGVOaXBwbGUocG9zaXRpb24sIGlkZW50aWZpZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VkbG5cXCd0IGZpbmQgdGhlIG5lZWRlZCBuaXBwbGUuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSW4gZHluYW1pYywgd2UgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICBuaXBwbGUgPSBzZWxmLmNyZWF0ZU5pcHBsZShwb3NpdGlvbiwgaWRlbnRpZmllcik7XG4gICAgcmV0dXJuIG5pcHBsZTtcbn07XG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnByb2Nlc3NPbk1vdmUgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvcHRzID0gc2VsZi5vcHRpb25zO1xuICAgIHZhciBpZGVudGlmaWVyID0gc2VsZi5tYW5hZ2VyLmdldElkZW50aWZpZXIoZXZ0KTtcbiAgICB2YXIgbmlwcGxlID0gc2VsZi5uaXBwbGVzLmdldChpZGVudGlmaWVyKTtcblxuICAgIGlmICghbmlwcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaGVyZSBqdXN0IGZvciBzYWZldHkuXG4gICAgICAgIC8vIEl0IHNob3VsZG4ndCBoYXBwZW4uXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZvdW5kIHpvbWJpZSBqb3lzdGljayB3aXRoIElEICcgKyBpZGVudGlmaWVyKTtcbiAgICAgICAgc2VsZi5tYW5hZ2VyLnJlbW92ZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuaXBwbGUuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG5cbiAgICB2YXIgc2l6ZSA9IG5pcHBsZS5vcHRpb25zLnNpemUgLyAyO1xuICAgIHZhciBwb3MgPSB7XG4gICAgICAgIHg6IGV2dC5wYWdlWCxcbiAgICAgICAgeTogZXZ0LnBhZ2VZXG4gICAgfTtcblxuICAgIHZhciBkaXN0ID0gdS5kaXN0YW5jZShwb3MsIG5pcHBsZS5wb3NpdGlvbik7XG4gICAgdmFyIGFuZ2xlID0gdS5hbmdsZShwb3MsIG5pcHBsZS5wb3NpdGlvbik7XG4gICAgdmFyIHJBbmdsZSA9IHUucmFkaWFucyhhbmdsZSk7XG4gICAgdmFyIGZvcmNlID0gZGlzdCAvIHNpemU7XG5cbiAgICAvLyBJZiBkaXN0YW5jZSBpcyBiaWdnZXIgdGhhbiBuaXBwbGUncyBzaXplXG4gICAgLy8gd2UgY2xhbXAgdGhlIHBvc2l0aW9uLlxuICAgIGlmIChkaXN0ID4gc2l6ZSkge1xuICAgICAgICBkaXN0ID0gc2l6ZTtcbiAgICAgICAgcG9zID0gdS5maW5kQ29vcmQobmlwcGxlLnBvc2l0aW9uLCBkaXN0LCBhbmdsZSk7XG4gICAgfVxuXG4gICAgdmFyIHhQb3NpdGlvbiA9IHBvcy54IC0gbmlwcGxlLnBvc2l0aW9uLnhcbiAgICB2YXIgeVBvc2l0aW9uID0gcG9zLnkgLSBuaXBwbGUucG9zaXRpb24ueVxuXG4gICAgaWYgKG9wdHMubG9ja1gpe1xuICAgICAgICB5UG9zaXRpb24gPSAwXG4gICAgfVxuICAgIGlmIChvcHRzLmxvY2tZKSB7XG4gICAgICAgIHhQb3NpdGlvbiA9IDBcbiAgICB9XG5cbiAgICBuaXBwbGUuZnJvbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogeFBvc2l0aW9uLFxuICAgICAgICB5OiB5UG9zaXRpb25cbiAgICB9O1xuXG4gICAgaWYgKCFvcHRzLmRhdGFPbmx5KSB7XG4gICAgICAgIHUuYXBwbHlQb3NpdGlvbihuaXBwbGUudWkuZnJvbnQsIG5pcHBsZS5mcm9udFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIGV2ZW50J3MgZGF0YXMuXG4gICAgdmFyIHRvU2VuZCA9IHtcbiAgICAgICAgaWRlbnRpZmllcjogbmlwcGxlLmlkZW50aWZpZXIsXG4gICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgIGZvcmNlOiBmb3JjZSxcbiAgICAgICAgcHJlc3N1cmU6IGV2dC5mb3JjZSB8fCBldnQucHJlc3N1cmUgfHwgZXZ0LndlYmtpdEZvcmNlIHx8IDAsXG4gICAgICAgIGRpc3RhbmNlOiBkaXN0LFxuICAgICAgICBhbmdsZToge1xuICAgICAgICAgICAgcmFkaWFuOiByQW5nbGUsXG4gICAgICAgICAgICBkZWdyZWU6IGFuZ2xlXG4gICAgICAgIH0sXG4gICAgICAgIGluc3RhbmNlOiBuaXBwbGUsXG4gICAgICAgIGxvY2tYOiBvcHRzLmxvY2tYLFxuICAgICAgICBsb2NrWTogb3B0cy5sb2NrWVxuICAgIH07XG5cbiAgICAvLyBDb21wdXRlIHRoZSBkaXJlY3Rpb24ncyBkYXRhcy5cbiAgICB0b1NlbmQgPSBuaXBwbGUuY29tcHV0ZURpcmVjdGlvbih0b1NlbmQpO1xuXG4gICAgLy8gT2Zmc2V0IGFuZ2xlcyB0byBmb2xsb3cgdW5pdHMgY2lyY2xlLlxuICAgIHRvU2VuZC5hbmdsZSA9IHtcbiAgICAgICAgcmFkaWFuOiB1LnJhZGlhbnMoMTgwIC0gYW5nbGUpLFxuICAgICAgICBkZWdyZWU6IDE4MCAtIGFuZ2xlXG4gICAgfTtcblxuICAgIC8vIFNlbmQgZXZlcnl0aGluZyB0byBldmVyeW9uZS5cbiAgICBuaXBwbGUudHJpZ2dlcignbW92ZScsIHRvU2VuZCk7XG4gICAgc2VsZi50cmlnZ2VyKCdtb3ZlICcgKyBuaXBwbGUuaWQgKyAnOm1vdmUnLCB0b1NlbmQpO1xufTtcblxuQ29sbGVjdGlvbi5wcm90b3R5cGUucHJvY2Vzc09uRW5kID0gZnVuY3Rpb24gKGV2dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb3B0cyA9IHNlbGYub3B0aW9ucztcbiAgICB2YXIgaWRlbnRpZmllciA9IHNlbGYubWFuYWdlci5nZXRJZGVudGlmaWVyKGV2dCk7XG4gICAgdmFyIG5pcHBsZSA9IHNlbGYubmlwcGxlcy5nZXQoaWRlbnRpZmllcik7XG4gICAgdmFyIHJlbW92ZWRJZGVudGlmaWVyID0gc2VsZi5tYW5hZ2VyLnJlbW92ZUlkZW50aWZpZXIobmlwcGxlLmlkZW50aWZpZXIpO1xuXG4gICAgaWYgKCFuaXBwbGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0cy5kYXRhT25seSkge1xuICAgICAgICBuaXBwbGUuaGlkZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5tb2RlID09PSAnZHluYW1pYycpIHtcbiAgICAgICAgICAgICAgICBuaXBwbGUudHJpZ2dlcigncmVtb3ZlZCcsIG5pcHBsZSk7XG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdyZW1vdmVkICcgKyBuaXBwbGUuaWQgKyAnOnJlbW92ZWQnLCBuaXBwbGUpO1xuICAgICAgICAgICAgICAgIHNlbGYubWFuYWdlclxuICAgICAgICAgICAgICAgICAgICAudHJpZ2dlcigncmVtb3ZlZCAnICsgbmlwcGxlLmlkICsgJzpyZW1vdmVkJywgbmlwcGxlKTtcbiAgICAgICAgICAgICAgICBuaXBwbGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciB0aGUgcHJlc3N1cmUgaW50ZXJ2YWwgcmVhZGVyXG4gICAgY2xlYXJJbnRlcnZhbChzZWxmLnByZXNzdXJlSW50ZXJ2YWxzW25pcHBsZS5pZGVudGlmaWVyXSk7XG5cbiAgICAvLyBSZXNldCB0aGUgZGlyZWNpdG9uIG9mIHRoZSBuaXBwbGUsIHRvIGJlIGFibGUgdG8gdHJpZ2dlciBhIG5ldyBkaXJlY3Rpb25cbiAgICAvLyBvbiBzdGFydC5cbiAgICBuaXBwbGUucmVzZXREaXJlY3Rpb24oKTtcblxuICAgIG5pcHBsZS50cmlnZ2VyKCdlbmQnLCBuaXBwbGUpO1xuICAgIHNlbGYudHJpZ2dlcignZW5kICcgKyBuaXBwbGUuaWQgKyAnOmVuZCcsIG5pcHBsZSk7XG5cbiAgICAvLyBSZW1vdmUgaWRlbnRpZmllciBmcm9tIG91ciBiYW5rLlxuICAgIGlmIChzZWxmLmlkcy5pbmRleE9mKG5pcHBsZS5pZGVudGlmaWVyKSA+PSAwKSB7XG4gICAgICAgIHNlbGYuaWRzLnNwbGljZShzZWxmLmlkcy5pbmRleE9mKG5pcHBsZS5pZGVudGlmaWVyKSwgMSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gb3VyIGFjdGl2ZXMgYXJyYXkuXG4gICAgaWYgKHNlbGYuYWN0aXZlcy5pbmRleE9mKG5pcHBsZSkgPj0gMCkge1xuICAgICAgICBzZWxmLmFjdGl2ZXMuc3BsaWNlKHNlbGYuYWN0aXZlcy5pbmRleE9mKG5pcHBsZSksIDEpO1xuICAgIH1cblxuICAgIGlmICgvKHNlbWl8c3RhdGljKS8udGVzdChvcHRzLm1vZGUpKSB7XG4gICAgICAgIC8vIFRyYW5zZmVyIG5pcHBsZSBmcm9tIGFjdGl2ZXMgdG8gaWRsZXNcbiAgICAgICAgLy8gaWYgd2UncmUgaW4gc2VtaSBvciBzdGF0aWMgbW9kZS5cbiAgICAgICAgc2VsZi5pZGxlcy5wdXNoKG5pcHBsZSk7XG4gICAgfSBlbHNlIGlmIChzZWxmLm5pcHBsZXMuaW5kZXhPZihuaXBwbGUpID49IDApIHtcbiAgICAgICAgLy8gT25seSBpZiB3ZSdyZSBub3QgaW4gc2VtaSBvciBzdGF0aWMgbW9kZVxuICAgICAgICAvLyB3ZSBjYW4gcmVtb3ZlIHRoZSBpbnN0YW5jZS5cbiAgICAgICAgc2VsZi5uaXBwbGVzLnNwbGljZShzZWxmLm5pcHBsZXMuaW5kZXhPZihuaXBwbGUpLCAxKTtcbiAgICB9XG5cbiAgICAvLyBXZSB1bmJpbmQgbW92ZSBhbmQgZW5kLlxuICAgIHNlbGYubWFuYWdlci51bmJpbmREb2N1bWVudCgpO1xuXG4gICAgLy8gV2UgYWRkIGJhY2sgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGlkbGUgbmlwcGxlO1xuICAgIGlmICgvKHNlbWl8c3RhdGljKS8udGVzdChvcHRzLm1vZGUpKSB7XG4gICAgICAgIHNlbGYubWFuYWdlci5pZHNbcmVtb3ZlZElkZW50aWZpZXIuaWRdID0gcmVtb3ZlZElkZW50aWZpZXIuaWRlbnRpZmllcjtcbiAgICB9XG59O1xuXG4vLyBSZW1vdmUgZGVzdHJveWVkIG5pcHBsZSBmcm9tIHRoZSBsaXN0c1xuQ29sbGVjdGlvbi5wcm90b3R5cGUub25EZXN0cm95ZWQgPSBmdW5jdGlvbihldnQsIG5pcHBsZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5uaXBwbGVzLmluZGV4T2YobmlwcGxlKSA+PSAwKSB7XG4gICAgICAgIHNlbGYubmlwcGxlcy5zcGxpY2Uoc2VsZi5uaXBwbGVzLmluZGV4T2YobmlwcGxlKSwgMSk7XG4gICAgfVxuICAgIGlmIChzZWxmLmFjdGl2ZXMuaW5kZXhPZihuaXBwbGUpID49IDApIHtcbiAgICAgICAgc2VsZi5hY3RpdmVzLnNwbGljZShzZWxmLmFjdGl2ZXMuaW5kZXhPZihuaXBwbGUpLCAxKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuaWRsZXMuaW5kZXhPZihuaXBwbGUpID49IDApIHtcbiAgICAgICAgc2VsZi5pZGxlcy5zcGxpY2Uoc2VsZi5pZGxlcy5pbmRleE9mKG5pcHBsZSksIDEpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5pZHMuaW5kZXhPZihuaXBwbGUuaWRlbnRpZmllcikgPj0gMCkge1xuICAgICAgICBzZWxmLmlkcy5zcGxpY2Uoc2VsZi5pZHMuaW5kZXhPZihuaXBwbGUuaWRlbnRpZmllciksIDEpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aGUgaWRlbnRpZmllciBmcm9tIG91ciBiYW5rXG4gICAgc2VsZi5tYW5hZ2VyLnJlbW92ZUlkZW50aWZpZXIobmlwcGxlLmlkZW50aWZpZXIpO1xuXG4gICAgLy8gV2UgdW5iaW5kIG1vdmUgYW5kIGVuZC5cbiAgICBzZWxmLm1hbmFnZXIudW5iaW5kRG9jdW1lbnQoKTtcbn07XG5cbi8vIENsZWFubHkgZGVzdHJveSB0aGUgbWFuYWdlclxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi51bmJpbmRFdnQoc2VsZi5vcHRpb25zLnpvbmUsICdzdGFydCcpO1xuXG4gICAgLy8gRGVzdHJveSBuaXBwbGVzLlxuICAgIHNlbGYubmlwcGxlcy5mb3JFYWNoKGZ1bmN0aW9uKG5pcHBsZSkge1xuICAgICAgICBuaXBwbGUuZGVzdHJveSgpO1xuICAgIH0pO1xuXG4gICAgLy8gQ2xlYW4gM0RUb3VjaCBpbnRlcnZhbHMuXG4gICAgZm9yICh2YXIgaSBpbiBzZWxmLnByZXNzdXJlSW50ZXJ2YWxzKSB7XG4gICAgICAgIGlmIChzZWxmLnByZXNzdXJlSW50ZXJ2YWxzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHNlbGYucHJlc3N1cmVJbnRlcnZhbHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm90aWZ5IHRoZSBtYW5hZ2VyIHBhc3NpbmcgdGhlIGluc3RhbmNlXG4gICAgc2VsZi50cmlnZ2VyKCdkZXN0cm95ZWQnLCBzZWxmLm5pcHBsZXMpO1xuICAgIC8vIFdlIHVuYmluZCBtb3ZlIGFuZCBlbmQuXG4gICAgc2VsZi5tYW5hZ2VyLnVuYmluZERvY3VtZW50KCk7XG4gICAgLy8gVW5iaW5kIGV2ZXJ5dGhpbmcuXG4gICAgc2VsZi5vZmYoKTtcbn07XG5cbi8qIGdsb2JhbCB1LCBTdXBlciwgQ29sbGVjdGlvbiAqL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vICAgICBNQU5BR0VSICAgICAvLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIE1hbmFnZXIgKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5pZHMgPSB7fTtcbiAgICBzZWxmLmluZGV4ID0gMDtcbiAgICBzZWxmLmNvbGxlY3Rpb25zID0gW107XG5cbiAgICBzZWxmLmNvbmZpZyhvcHRpb25zKTtcbiAgICBzZWxmLnByZXBhcmVDb2xsZWN0aW9ucygpO1xuXG4gICAgLy8gTGlzdGVuIGZvciByZXNpemUsIHRvIHJlcG9zaXRpb24gZXZlcnkgam95c3RpY2tzXG4gICAgdmFyIHJlc2l6ZVRpbWVyO1xuICAgIHUuYmluZEV2dCh3aW5kb3csICdyZXNpemUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChyZXNpemVUaW1lcik7XG4gICAgICAgIHJlc2l6ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9zO1xuICAgICAgICAgICAgdmFyIHNjcm9sbCA9IHUuZ2V0U2Nyb2xsKCk7XG4gICAgICAgICAgICBzZWxmLmNvbGxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKG5pcHBsZSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuaXBwbGUuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIG5pcHBsZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNjcm9sbC54ICsgcG9zLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBzY3JvbGwueSArIHBvcy50b3BcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAxMDApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlbGYuY29sbGVjdGlvbnM7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZSA9IG5ldyBTdXBlcigpO1xuTWFuYWdlci5jb25zdHJ1Y3RvciA9IE1hbmFnZXI7XG5cbk1hbmFnZXIucHJvdG90eXBlLnByZXBhcmVDb2xsZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gUHVibGljIEFQSSBQcmVwYXJhdGlvbi5cbiAgICBzZWxmLmNvbGxlY3Rpb25zLmNyZWF0ZSA9IHNlbGYuY3JlYXRlLmJpbmQoc2VsZik7XG4gICAgLy8gTGlzdGVuIHRvIGFueXRoaW5nXG4gICAgc2VsZi5jb2xsZWN0aW9ucy5vbiA9IHNlbGYub24uYmluZChzZWxmKTtcbiAgICAvLyBVbmJpbmQgZ2VuZXJhbCBldmVudHNcbiAgICBzZWxmLmNvbGxlY3Rpb25zLm9mZiA9IHNlbGYub2ZmLmJpbmQoc2VsZik7XG4gICAgLy8gRGVzdHJveSBldmVyeXRoaW5nXG4gICAgc2VsZi5jb2xsZWN0aW9ucy5kZXN0cm95ID0gc2VsZi5kZXN0cm95LmJpbmQoc2VsZik7XG4gICAgLy8gR2V0IGFueSBuaXBwbGVcbiAgICBzZWxmLmNvbGxlY3Rpb25zLmdldCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgbmlwcGxlO1xuICAgICAgICBzZWxmLmNvbGxlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAobmlwcGxlID0gY29sbGVjdGlvbi5nZXQoaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmlwcGxlO1xuICAgIH07XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUNvbGxlY3Rpb24ob3B0aW9ucyk7XG59O1xuXG4vLyBDb2xsZWN0aW9uIEZhY3Rvcnlcbk1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUNvbGxlY3Rpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKHNlbGYsIG9wdGlvbnMpO1xuXG4gICAgc2VsZi5iaW5kQ29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICBzZWxmLmNvbGxlY3Rpb25zLnB1c2goY29sbGVjdGlvbik7XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLmJpbmRDb2xsZWN0aW9uID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR5cGU7XG4gICAgLy8gQnViYmxlIHVwIGlkZW50aWZpZWQgZXZlbnRzLlxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGV2dCwgZGF0YSkge1xuICAgICAgICAvLyBJZGVudGlmeSB0aGUgZXZlbnQgdHlwZSB3aXRoIHRoZSBuaXBwbGUncyBpZGVudGlmaWVyLlxuICAgICAgICB0eXBlID0gZXZ0LnR5cGUgKyAnICcgKyBkYXRhLmlkICsgJzonICsgZXZ0LnR5cGU7XG4gICAgICAgIHNlbGYudHJpZ2dlcih0eXBlLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgLy8gV2hlbiBpdCBnZXRzIGRlc3Ryb3llZCB3ZSBjbGVhbi5cbiAgICBjb2xsZWN0aW9uLm9uKCdkZXN0cm95ZWQnLCBzZWxmLm9uRGVzdHJveWVkLmJpbmQoc2VsZikpO1xuXG4gICAgLy8gT3RoZXIgZXZlbnRzIHRoYXQgd2lsbCBnZXQgYnViYmxlZCB1cC5cbiAgICBjb2xsZWN0aW9uLm9uKCdzaG93biBoaWRkZW4gcmVzdGVkIGRpciBwbGFpbicsIGhhbmRsZXIpO1xuICAgIGNvbGxlY3Rpb24ub24oJ2Rpcjp1cCBkaXI6cmlnaHQgZGlyOmRvd24gZGlyOmxlZnQnLCBoYW5kbGVyKTtcbiAgICBjb2xsZWN0aW9uLm9uKCdwbGFpbjp1cCBwbGFpbjpyaWdodCBwbGFpbjpkb3duIHBsYWluOmxlZnQnLCBoYW5kbGVyKTtcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLmJpbmREb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gQmluZCBvbmx5IGlmIG5vdCBhbHJlYWR5IGJpbmRlZFxuICAgIGlmICghc2VsZi5iaW5kZWQpIHtcbiAgICAgICAgc2VsZi5iaW5kRXZ0KGRvY3VtZW50LCAnbW92ZScpXG4gICAgICAgICAgICAuYmluZEV2dChkb2N1bWVudCwgJ2VuZCcpO1xuICAgICAgICBzZWxmLmJpbmRlZCA9IHRydWU7XG4gICAgfVxufTtcblxuTWFuYWdlci5wcm90b3R5cGUudW5iaW5kRG9jdW1lbnQgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHRvdWNoIGxlZnRcbiAgICAvLyB1bmJpbmQgdGhlIGRvY3VtZW50LlxuICAgIGlmICghT2JqZWN0LmtleXMoc2VsZi5pZHMpLmxlbmd0aCB8fCBmb3JjZSA9PT0gdHJ1ZSkge1xuICAgICAgICBzZWxmLnVuYmluZEV2dChkb2N1bWVudCwgJ21vdmUnKVxuICAgICAgICAgICAgLnVuYmluZEV2dChkb2N1bWVudCwgJ2VuZCcpO1xuICAgICAgICBzZWxmLmJpbmRlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLmdldElkZW50aWZpZXIgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdmFyIGlkO1xuICAgIC8vIElmIG5vIGV2ZW50LCBzaW1wbGUgaW5jcmVtZW50XG4gICAgaWYgKCFldnQpIHtcbiAgICAgICAgaWQgPSB0aGlzLmluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV4dHJhY3QgaWRlbnRpZmllciBmcm9tIGV2ZW50IG9iamVjdC5cbiAgICAgICAgLy8gVW5hdmFpbGFibGUgaW4gbW91c2UgZXZlbnRzIHNvIHJlcGxhY2VkIGJ5IGxhdGVzdCBpbmNyZW1lbnQuXG4gICAgICAgIGlkID0gZXZ0LmlkZW50aWZpZXIgPT09IHVuZGVmaW5lZCA/IGV2dC5wb2ludGVySWQgOiBldnQuaWRlbnRpZmllcjtcbiAgICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5sYXRlc3QgfHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlkc1tpZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmlkc1tpZF0gPSB0aGlzLmluZGV4O1xuICAgICAgICB0aGlzLmluZGV4ICs9IDE7XG4gICAgfVxuXG4gICAgLy8gS2VlcCB0aGUgbGF0ZXN0IGlkIHVzZWQgaW4gY2FzZSB3ZSdyZSB1c2luZyBhbiB1bmlkZW50aWZpZWQgbW91c2VFdmVudFxuICAgIHRoaXMubGF0ZXN0ID0gaWQ7XG4gICAgcmV0dXJuIHRoaXMuaWRzW2lkXTtcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoaWRlbnRpZmllcikge1xuICAgIHZhciByZW1vdmVkID0ge307XG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy5pZHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaWRzW2lkXSA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmVtb3ZlZC5pZCA9IGlkO1xuICAgICAgICAgICAgcmVtb3ZlZC5pZGVudGlmaWVyID0gdGhpcy5pZHNbaWRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaWRzW2lkXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVkO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUub25tb3ZlID0gZnVuY3Rpb24gKGV2dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLm9uQW55KCdtb3ZlJywgZXZ0KTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmVuZCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5vbkFueSgnZW5kJywgZXZ0KTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNhbmNlbCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5vbkFueSgnZW5kJywgZXZ0KTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbkFueSA9IGZ1bmN0aW9uICh3aGljaCwgZXZ0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpZDtcbiAgICB2YXIgcHJvY2Vzc0ZuID0gJ3Byb2Nlc3NPbicgKyB3aGljaC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArXG4gICAgICAgIHdoaWNoLnNsaWNlKDEpO1xuICAgIGV2dCA9IHUucHJlcGFyZUV2ZW50KGV2dCk7XG4gICAgdmFyIHByb2Nlc3NDb2xsID0gZnVuY3Rpb24gKGUsIGlkLCBjb2xsKSB7XG4gICAgICAgIGlmIChjb2xsLmlkcy5pbmRleE9mKGlkKSA+PSAwKSB7XG4gICAgICAgICAgICBjb2xsW3Byb2Nlc3NGbl0oZSk7XG4gICAgICAgICAgICAvLyBNYXJrIHRoZSBldmVudCB0byBhdm9pZCBjbGVhbmluZyBpdCBsYXRlci5cbiAgICAgICAgICAgIGUuX2ZvdW5kXyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwcm9jZXNzRXZ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWQgPSBzZWxmLmdldElkZW50aWZpZXIoZSk7XG4gICAgICAgIHUubWFwKHNlbGYuY29sbGVjdGlvbnMsIHByb2Nlc3NDb2xsLmJpbmQobnVsbCwgZSwgaWQpKTtcbiAgICAgICAgLy8gSWYgdGhlIGV2ZW50IGlzbid0IGhhbmRsZWQgYnkgYW55IGNvbGxlY3Rpb24sXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY2xlYW4gaXRzIGlkZW50aWZpZXIuXG4gICAgICAgIGlmICghZS5fZm91bmRfKSB7XG4gICAgICAgICAgICBzZWxmLnJlbW92ZUlkZW50aWZpZXIoaWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHUubWFwKGV2dCwgcHJvY2Vzc0V2dCk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBDbGVhbmx5IGRlc3Ryb3kgdGhlIG1hbmFnZXJcbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYudW5iaW5kRG9jdW1lbnQodHJ1ZSk7XG4gICAgc2VsZi5pZHMgPSB7fTtcbiAgICBzZWxmLmluZGV4ID0gMDtcbiAgICBzZWxmLmNvbGxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgICAgICBjb2xsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICBzZWxmLm9mZigpO1xufTtcblxuLy8gV2hlbiBhIGNvbGxlY3Rpb24gZ2V0cyBkZXN0cm95ZWRcbi8vIHdlIGNsZWFuIGJlaGluZC5cbk1hbmFnZXIucHJvdG90eXBlLm9uRGVzdHJveWVkID0gZnVuY3Rpb24gKGV2dCwgY29sbCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5jb2xsZWN0aW9ucy5pbmRleE9mKGNvbGwpIDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGYuY29sbGVjdGlvbnMuc3BsaWNlKHNlbGYuY29sbGVjdGlvbnMuaW5kZXhPZihjb2xsKSwgMSk7XG59O1xuXG52YXIgZmFjdG9yeSA9IG5ldyBNYW5hZ2VyKCk7XG5yZXR1cm4ge1xuICAgIGNyZWF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZmFjdG9yeTogZmFjdG9yeVxufTtcblxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nipplejs/dist/nipplejs.js\n");

/***/ })

};
;