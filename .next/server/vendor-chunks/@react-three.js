"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/Clone.js":
/*!******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Clone.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Clone: () => (/* binding */ Clone)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js\");\n\n\n\n\n\nfunction createSpread(child, {\n  keys = ['near', 'far', 'color', 'distance', 'decay', 'penumbra', 'angle', 'intensity', 'skeleton', 'visible', 'castShadow', 'receiveShadow', 'morphTargetDictionary', 'morphTargetInfluences', 'name', 'geometry', 'material', 'position', 'rotation', 'scale', 'up', 'userData', 'bindMode', 'bindMatrix', 'bindMatrixInverse', 'skeleton'],\n  deep,\n  inject,\n  castShadow,\n  receiveShadow\n}) {\n  let spread = {};\n  for (const key of keys) {\n    spread[key] = child[key];\n  }\n  if (deep) {\n    if (spread.geometry && deep !== 'materialsOnly') spread.geometry = spread.geometry.clone();\n    if (spread.material && deep !== 'geometriesOnly') spread.material = spread.material.clone();\n  }\n  if (inject) {\n    if (typeof inject === 'function') spread = {\n      ...spread,\n      children: inject(child)\n    };else if ( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(inject)) spread = {\n      ...spread,\n      children: inject\n    };else spread = {\n      ...spread,\n      ...inject\n    };\n  }\n  if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n    if (castShadow) spread.castShadow = true;\n    if (receiveShadow) spread.receiveShadow = true;\n  }\n  return spread;\n}\nconst Clone = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  isChild = false,\n  object,\n  children,\n  deep,\n  castShadow,\n  receiveShadow,\n  inject,\n  keys,\n  ...props\n}, forwardRef) => {\n  const config = {\n    keys,\n    deep,\n    inject,\n    castShadow,\n    receiveShadow\n  };\n  object = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    if (isChild === false && !Array.isArray(object)) {\n      let isSkinned = false;\n      object.traverse(object => {\n        if (object.isSkinnedMesh) isSkinned = true;\n      });\n      if (isSkinned) return three_stdlib__WEBPACK_IMPORTED_MODULE_3__.SkeletonUtils.clone(object);\n    }\n    return object;\n  }, [object, isChild]);\n\n  // Deal with arrayed clones\n  if (Array.isArray(object)) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n      ref: forwardRef\n    }), object.map(o => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Clone, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      key: o.uuid,\n      object: o\n    }, config))), children);\n  }\n\n  // Singleton clones\n  const {\n    children: injectChildren,\n    ...spread\n  } = createSpread(object, config);\n  const Element = object.type[0].toLowerCase() + object.type.slice(1);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Element, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, spread, props, {\n    ref: forwardRef\n  }), object.children.map(child => {\n    if (child.type === 'Bone') return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      key: child.uuid,\n      object: child\n    }, config));\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Clone, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      key: child.uuid,\n      object: child\n    }, config, {\n      isChild: true\n    }));\n  }), children, injectChildren);\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9DbG9uZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDQTtBQUNjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1QkFBdUIsaURBQW9CO0FBQ2pEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw0QkFBNEIsdURBQWE7QUFDekM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHdCQUF3QixnREFBbUIsVUFBVSw4RUFBUSxHQUFHO0FBQ2hFO0FBQ0EsS0FBSyxnQ0FBZ0MsZ0RBQW1CLFFBQVEsOEVBQVE7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNCQUFzQixnREFBbUIsVUFBVSw4RUFBUSxHQUFHO0FBQzlEO0FBQ0EsR0FBRztBQUNILG1EQUFtRCxnREFBbUIsY0FBYyw4RUFBUTtBQUM1RjtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixnREFBbUIsUUFBUSw4RUFBUTtBQUMzRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2phd2FyYS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL0Nsb25lLmpzPzI4MmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgU2tlbGV0b25VdGlscyB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNwcmVhZChjaGlsZCwge1xuICBrZXlzID0gWyduZWFyJywgJ2ZhcicsICdjb2xvcicsICdkaXN0YW5jZScsICdkZWNheScsICdwZW51bWJyYScsICdhbmdsZScsICdpbnRlbnNpdHknLCAnc2tlbGV0b24nLCAndmlzaWJsZScsICdjYXN0U2hhZG93JywgJ3JlY2VpdmVTaGFkb3cnLCAnbW9ycGhUYXJnZXREaWN0aW9uYXJ5JywgJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcycsICduYW1lJywgJ2dlb21ldHJ5JywgJ21hdGVyaWFsJywgJ3Bvc2l0aW9uJywgJ3JvdGF0aW9uJywgJ3NjYWxlJywgJ3VwJywgJ3VzZXJEYXRhJywgJ2JpbmRNb2RlJywgJ2JpbmRNYXRyaXgnLCAnYmluZE1hdHJpeEludmVyc2UnLCAnc2tlbGV0b24nXSxcbiAgZGVlcCxcbiAgaW5qZWN0LFxuICBjYXN0U2hhZG93LFxuICByZWNlaXZlU2hhZG93XG59KSB7XG4gIGxldCBzcHJlYWQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIHNwcmVhZFtrZXldID0gY2hpbGRba2V5XTtcbiAgfVxuICBpZiAoZGVlcCkge1xuICAgIGlmIChzcHJlYWQuZ2VvbWV0cnkgJiYgZGVlcCAhPT0gJ21hdGVyaWFsc09ubHknKSBzcHJlYWQuZ2VvbWV0cnkgPSBzcHJlYWQuZ2VvbWV0cnkuY2xvbmUoKTtcbiAgICBpZiAoc3ByZWFkLm1hdGVyaWFsICYmIGRlZXAgIT09ICdnZW9tZXRyaWVzT25seScpIHNwcmVhZC5tYXRlcmlhbCA9IHNwcmVhZC5tYXRlcmlhbC5jbG9uZSgpO1xuICB9XG4gIGlmIChpbmplY3QpIHtcbiAgICBpZiAodHlwZW9mIGluamVjdCA9PT0gJ2Z1bmN0aW9uJykgc3ByZWFkID0ge1xuICAgICAgLi4uc3ByZWFkLFxuICAgICAgY2hpbGRyZW46IGluamVjdChjaGlsZClcbiAgICB9O2Vsc2UgaWYgKCAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoaW5qZWN0KSkgc3ByZWFkID0ge1xuICAgICAgLi4uc3ByZWFkLFxuICAgICAgY2hpbGRyZW46IGluamVjdFxuICAgIH07ZWxzZSBzcHJlYWQgPSB7XG4gICAgICAuLi5zcHJlYWQsXG4gICAgICAuLi5pbmplY3RcbiAgICB9O1xuICB9XG4gIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcbiAgICBpZiAoY2FzdFNoYWRvdykgc3ByZWFkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgIGlmIChyZWNlaXZlU2hhZG93KSBzcHJlYWQucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHNwcmVhZDtcbn1cbmNvbnN0IENsb25lID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBpc0NoaWxkID0gZmFsc2UsXG4gIG9iamVjdCxcbiAgY2hpbGRyZW4sXG4gIGRlZXAsXG4gIGNhc3RTaGFkb3csXG4gIHJlY2VpdmVTaGFkb3csXG4gIGluamVjdCxcbiAga2V5cyxcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRSZWYpID0+IHtcbiAgY29uc3QgY29uZmlnID0ge1xuICAgIGtleXMsXG4gICAgZGVlcCxcbiAgICBpbmplY3QsXG4gICAgY2FzdFNoYWRvdyxcbiAgICByZWNlaXZlU2hhZG93XG4gIH07XG4gIG9iamVjdCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChpc0NoaWxkID09PSBmYWxzZSAmJiAhQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICBsZXQgaXNTa2lubmVkID0gZmFsc2U7XG4gICAgICBvYmplY3QudHJhdmVyc2Uob2JqZWN0ID0+IHtcbiAgICAgICAgaWYgKG9iamVjdC5pc1NraW5uZWRNZXNoKSBpc1NraW5uZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBpZiAoaXNTa2lubmVkKSByZXR1cm4gU2tlbGV0b25VdGlscy5jbG9uZShvYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LCBbb2JqZWN0LCBpc0NoaWxkXSk7XG5cbiAgLy8gRGVhbCB3aXRoIGFycmF5ZWQgY2xvbmVzXG4gIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHJlZjogZm9yd2FyZFJlZlxuICAgIH0pLCBvYmplY3QubWFwKG8gPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xvbmUsIF9leHRlbmRzKHtcbiAgICAgIGtleTogby51dWlkLFxuICAgICAgb2JqZWN0OiBvXG4gICAgfSwgY29uZmlnKSkpLCBjaGlsZHJlbik7XG4gIH1cblxuICAvLyBTaW5nbGV0b24gY2xvbmVzXG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbjogaW5qZWN0Q2hpbGRyZW4sXG4gICAgLi4uc3ByZWFkXG4gIH0gPSBjcmVhdGVTcHJlYWQob2JqZWN0LCBjb25maWcpO1xuICBjb25zdCBFbGVtZW50ID0gb2JqZWN0LnR5cGVbMF0udG9Mb3dlckNhc2UoKSArIG9iamVjdC50eXBlLnNsaWNlKDEpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRWxlbWVudCwgX2V4dGVuZHMoe30sIHNwcmVhZCwgcHJvcHMsIHtcbiAgICByZWY6IGZvcndhcmRSZWZcbiAgfSksIG9iamVjdC5jaGlsZHJlbi5tYXAoY2hpbGQgPT4ge1xuICAgIGlmIChjaGlsZC50eXBlID09PSAnQm9uZScpIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGNoaWxkLnV1aWQsXG4gICAgICBvYmplY3Q6IGNoaWxkXG4gICAgfSwgY29uZmlnKSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENsb25lLCBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGNoaWxkLnV1aWQsXG4gICAgICBvYmplY3Q6IGNoaWxkXG4gICAgfSwgY29uZmlnLCB7XG4gICAgICBpc0NoaWxkOiB0cnVlXG4gICAgfSkpO1xuICB9KSwgY2hpbGRyZW4sIGluamVjdENoaWxkcmVuKTtcbn0pO1xuXG5leHBvcnQgeyBDbG9uZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Clone.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Edges.js":
/*!******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Edges.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Edges: () => (/* binding */ Edges)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Line.js */ \"(ssr)/./node_modules/@react-three/drei/core/Line.js\");\n\n\n\n\n\nconst Edges = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  threshold = 15,\n  ...props\n}, fref) => {\n  const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(fref, () => ref.current, []);\n  const tmpPoints = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => [0, 0, 0, 1, 0, 0], []);\n  const memoizedGeometry = react__WEBPACK_IMPORTED_MODULE_1__.useRef();\n  const memoizedThreshold = react__WEBPACK_IMPORTED_MODULE_1__.useRef();\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    const parent = ref.current.parent;\n    if (parent) {\n      const geometry = parent.geometry;\n      if (geometry !== memoizedGeometry.current || threshold !== memoizedThreshold.current) {\n        memoizedGeometry.current = geometry;\n        memoizedThreshold.current = threshold;\n        const points = new three__WEBPACK_IMPORTED_MODULE_2__.EdgesGeometry(geometry, threshold).attributes.position.array;\n        ref.current.geometry.setPositions(points);\n        ref.current.geometry.attributes.instanceStart.needsUpdate = true;\n        ref.current.geometry.attributes.instanceEnd.needsUpdate = true;\n        ref.current.computeLineDistances();\n      }\n    }\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_Line_js__WEBPACK_IMPORTED_MODULE_3__.Line, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    segments: true,\n    points: tmpPoints,\n    ref: ref,\n    raycast: () => null\n  }, props));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9FZGdlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDQTtBQUNFOztBQUVqQyw2QkFBNkIsNkNBQWdCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsY0FBYyx5Q0FBWTtBQUMxQixFQUFFLHNEQUF5QjtBQUMzQixvQkFBb0IsMENBQWE7QUFDakMsMkJBQTJCLHlDQUFZO0FBQ3ZDLDRCQUE0Qix5Q0FBWTtBQUN4QyxFQUFFLGtEQUFxQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsZ0RBQW1CLENBQUMsMENBQUksRUFBRSw4RUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2phd2FyYS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL0VkZ2VzLmpzPzI4OWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4vTGluZS5qcyc7XG5cbmNvbnN0IEVkZ2VzID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICB0aHJlc2hvbGQgPSAxNSxcbiAgLi4ucHJvcHNcbn0sIGZyZWYpID0+IHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGZyZWYsICgpID0+IHJlZi5jdXJyZW50LCBbXSk7XG4gIGNvbnN0IHRtcFBvaW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gWzAsIDAsIDAsIDEsIDAsIDBdLCBbXSk7XG4gIGNvbnN0IG1lbW9pemVkR2VvbWV0cnkgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgbWVtb2l6ZWRUaHJlc2hvbGQgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSByZWYuY3VycmVudC5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgY29uc3QgZ2VvbWV0cnkgPSBwYXJlbnQuZ2VvbWV0cnk7XG4gICAgICBpZiAoZ2VvbWV0cnkgIT09IG1lbW9pemVkR2VvbWV0cnkuY3VycmVudCB8fCB0aHJlc2hvbGQgIT09IG1lbW9pemVkVGhyZXNob2xkLmN1cnJlbnQpIHtcbiAgICAgICAgbWVtb2l6ZWRHZW9tZXRyeS5jdXJyZW50ID0gZ2VvbWV0cnk7XG4gICAgICAgIG1lbW9pemVkVGhyZXNob2xkLmN1cnJlbnQgPSB0aHJlc2hvbGQ7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IG5ldyBUSFJFRS5FZGdlc0dlb21ldHJ5KGdlb21ldHJ5LCB0aHJlc2hvbGQpLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgICAgIHJlZi5jdXJyZW50Lmdlb21ldHJ5LnNldFBvc2l0aW9ucyhwb2ludHMpO1xuICAgICAgICByZWYuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLmluc3RhbmNlU3RhcnQubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZWYuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLmluc3RhbmNlRW5kLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmVmLmN1cnJlbnQuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGluZSwgX2V4dGVuZHMoe1xuICAgIHNlZ21lbnRzOiB0cnVlLFxuICAgIHBvaW50czogdG1wUG9pbnRzLFxuICAgIHJlZjogcmVmLFxuICAgIHJheWNhc3Q6ICgpID0+IG51bGxcbiAgfSwgcHJvcHMpKTtcbn0pO1xuXG5leHBvcnQgeyBFZGdlcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Edges.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Gltf.js":
/*!*****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Gltf.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gltf: () => (/* binding */ Gltf),\n/* harmony export */   useGLTF: () => (/* binding */ useGLTF)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Clone_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Clone.js */ \"(ssr)/./node_modules/@react-three/drei/core/Clone.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-99983b2d.esm.js\");\n\n\n\n\n\n\nlet dracoLoader = null;\nlet decoderPath = 'https://www.gstatic.com/draco/versioned/decoders/1.5.5/';\nfunction extensions(useDraco, useMeshopt, extendLoader) {\n  return loader => {\n    if (extendLoader) {\n      extendLoader(loader);\n    }\n    if (useDraco) {\n      if (!dracoLoader) {\n        dracoLoader = new three_stdlib__WEBPACK_IMPORTED_MODULE_2__.DRACOLoader();\n      }\n      dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : decoderPath);\n      loader.setDRACOLoader(dracoLoader);\n    }\n    if (useMeshopt) {\n      loader.setMeshoptDecoder(typeof three_stdlib__WEBPACK_IMPORTED_MODULE_3__.MeshoptDecoder === 'function' ? (0,three_stdlib__WEBPACK_IMPORTED_MODULE_3__.MeshoptDecoder)() : three_stdlib__WEBPACK_IMPORTED_MODULE_3__.MeshoptDecoder);\n    }\n  };\n}\nfunction useGLTF(path, useDraco = true, useMeshOpt = true, extendLoader) {\n  return (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F)(three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\n}\nuseGLTF.preload = (path, useDraco = true, useMeshOpt = true, extendLoader) => _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F.preload(three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\nuseGLTF.clear = input => _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F.clear(three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GLTFLoader, input);\nuseGLTF.setDecoderPath = path => {\n  decoderPath = path;\n};\n\n//\n\nconst Gltf = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  src,\n  useDraco,\n  useMeshOpt,\n  extendLoader,\n  ...props\n}, ref) => {\n  const {\n    scene\n  } = useGLTF(src, useDraco, useMeshOpt, extendLoader);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_Clone_js__WEBPACK_IMPORTED_MODULE_6__.Clone, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ref: ref\n  }, props, {\n    object: scene\n  }));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9HbHRmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDSTtBQUNvQztBQUN4Qjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0RBQWMsa0JBQWtCLDREQUFjLEtBQUssd0RBQWM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFEQUFTLENBQUMsb0RBQVU7QUFDN0I7QUFDQSw4RUFBOEUsaURBQVMsU0FBUyxvREFBVTtBQUMxRyx5QkFBeUIsaURBQVMsT0FBTyxvREFBVTtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLDZDQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0JBQXNCLGdEQUFtQixDQUFDLDRDQUFLLEVBQUUsOEVBQVE7QUFDekQ7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qYXdhcmEvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9HbHRmLmpzPzA1MGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuL0Nsb25lLmpzJztcbmltcG9ydCB7IEdMVEZMb2FkZXIsIERSQUNPTG9hZGVyLCBNZXNob3B0RGVjb2RlciB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5pbXBvcnQgeyB1c2VMb2FkZXIgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuXG5sZXQgZHJhY29Mb2FkZXIgPSBudWxsO1xubGV0IGRlY29kZXJQYXRoID0gJ2h0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2RyYWNvL3ZlcnNpb25lZC9kZWNvZGVycy8xLjUuNS8nO1xuZnVuY3Rpb24gZXh0ZW5zaW9ucyh1c2VEcmFjbywgdXNlTWVzaG9wdCwgZXh0ZW5kTG9hZGVyKSB7XG4gIHJldHVybiBsb2FkZXIgPT4ge1xuICAgIGlmIChleHRlbmRMb2FkZXIpIHtcbiAgICAgIGV4dGVuZExvYWRlcihsb2FkZXIpO1xuICAgIH1cbiAgICBpZiAodXNlRHJhY28pIHtcbiAgICAgIGlmICghZHJhY29Mb2FkZXIpIHtcbiAgICAgICAgZHJhY29Mb2FkZXIgPSBuZXcgRFJBQ09Mb2FkZXIoKTtcbiAgICAgIH1cbiAgICAgIGRyYWNvTG9hZGVyLnNldERlY29kZXJQYXRoKHR5cGVvZiB1c2VEcmFjbyA9PT0gJ3N0cmluZycgPyB1c2VEcmFjbyA6IGRlY29kZXJQYXRoKTtcbiAgICAgIGxvYWRlci5zZXREUkFDT0xvYWRlcihkcmFjb0xvYWRlcik7XG4gICAgfVxuICAgIGlmICh1c2VNZXNob3B0KSB7XG4gICAgICBsb2FkZXIuc2V0TWVzaG9wdERlY29kZXIodHlwZW9mIE1lc2hvcHREZWNvZGVyID09PSAnZnVuY3Rpb24nID8gTWVzaG9wdERlY29kZXIoKSA6IE1lc2hvcHREZWNvZGVyKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB1c2VHTFRGKHBhdGgsIHVzZURyYWNvID0gdHJ1ZSwgdXNlTWVzaE9wdCA9IHRydWUsIGV4dGVuZExvYWRlcikge1xuICByZXR1cm4gdXNlTG9hZGVyKEdMVEZMb2FkZXIsIHBhdGgsIGV4dGVuc2lvbnModXNlRHJhY28sIHVzZU1lc2hPcHQsIGV4dGVuZExvYWRlcikpO1xufVxudXNlR0xURi5wcmVsb2FkID0gKHBhdGgsIHVzZURyYWNvID0gdHJ1ZSwgdXNlTWVzaE9wdCA9IHRydWUsIGV4dGVuZExvYWRlcikgPT4gdXNlTG9hZGVyLnByZWxvYWQoR0xURkxvYWRlciwgcGF0aCwgZXh0ZW5zaW9ucyh1c2VEcmFjbywgdXNlTWVzaE9wdCwgZXh0ZW5kTG9hZGVyKSk7XG51c2VHTFRGLmNsZWFyID0gaW5wdXQgPT4gdXNlTG9hZGVyLmNsZWFyKEdMVEZMb2FkZXIsIGlucHV0KTtcbnVzZUdMVEYuc2V0RGVjb2RlclBhdGggPSBwYXRoID0+IHtcbiAgZGVjb2RlclBhdGggPSBwYXRoO1xufTtcblxuLy9cblxuY29uc3QgR2x0ZiA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgc3JjLFxuICB1c2VEcmFjbyxcbiAgdXNlTWVzaE9wdCxcbiAgZXh0ZW5kTG9hZGVyLFxuICAuLi5wcm9wc1xufSwgcmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzY2VuZVxuICB9ID0gdXNlR0xURihzcmMsIHVzZURyYWNvLCB1c2VNZXNoT3B0LCBleHRlbmRMb2FkZXIpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xvbmUsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZlxuICB9LCBwcm9wcywge1xuICAgIG9iamVjdDogc2NlbmVcbiAgfSkpO1xufSk7XG5cbmV4cG9ydCB7IEdsdGYsIHVzZUdMVEYgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Gltf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Line.js":
/*!*****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Line.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line: () => (/* binding */ Line)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-99983b2d.esm.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/lines/LineSegments2.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/lines/Line2.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/lines/LineMaterial.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/lines/LineSegmentsGeometry.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/lines/LineGeometry.js\");\n\n\n\n\n\n\nconst Line = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function Line({\n  points,\n  color = 0xffffff,\n  vertexColors,\n  linewidth,\n  lineWidth,\n  segments,\n  dashed,\n  ...rest\n}, ref) {\n  var _vertexColors$, _ref;\n  const size = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(state => state.size);\n  const line2 = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => segments ? new three_stdlib__WEBPACK_IMPORTED_MODULE_3__.LineSegments2() : new three_stdlib__WEBPACK_IMPORTED_MODULE_4__.Line2(), [segments]);\n  const [lineMaterial] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => new three_stdlib__WEBPACK_IMPORTED_MODULE_5__.LineMaterial());\n  const itemSize = (vertexColors == null || (_vertexColors$ = vertexColors[0]) == null ? void 0 : _vertexColors$.length) === 4 ? 4 : 3;\n  const lineGeom = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    const geom = segments ? new three_stdlib__WEBPACK_IMPORTED_MODULE_6__.LineSegmentsGeometry() : new three_stdlib__WEBPACK_IMPORTED_MODULE_7__.LineGeometry();\n    const pValues = points.map(p => {\n      const isArray = Array.isArray(p);\n      return p instanceof three__WEBPACK_IMPORTED_MODULE_8__.Vector3 || p instanceof three__WEBPACK_IMPORTED_MODULE_8__.Vector4 ? [p.x, p.y, p.z] : p instanceof three__WEBPACK_IMPORTED_MODULE_8__.Vector2 ? [p.x, p.y, 0] : isArray && p.length === 3 ? [p[0], p[1], p[2]] : isArray && p.length === 2 ? [p[0], p[1], 0] : p;\n    });\n    geom.setPositions(pValues.flat());\n    if (vertexColors) {\n      // using vertexColors requires the color value to be white see #1813\n      color = 0xffffff;\n      const cValues = vertexColors.map(c => c instanceof three__WEBPACK_IMPORTED_MODULE_8__.Color ? c.toArray() : c);\n      geom.setColors(cValues.flat(), itemSize);\n    }\n    return geom;\n  }, [points, segments, vertexColors, itemSize]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    line2.computeLineDistances();\n  }, [points, line2]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (dashed) {\n      lineMaterial.defines.USE_DASH = '';\n    } else {\n      // Setting lineMaterial.defines.USE_DASH to undefined is apparently not sufficient.\n      delete lineMaterial.defines.USE_DASH;\n    }\n    lineMaterial.needsUpdate = true;\n  }, [dashed, lineMaterial]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    return () => lineGeom.dispose();\n  }, [lineGeom]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    object: line2,\n    ref: ref\n  }, rest), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", {\n    object: lineGeom,\n    attach: \"geometry\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    object: lineMaterial,\n    attach: \"material\",\n    color: color,\n    vertexColors: Boolean(vertexColors),\n    resolution: [size.width, size.height],\n    linewidth: (_ref = linewidth !== null && linewidth !== void 0 ? linewidth : lineWidth) !== null && _ref !== void 0 ? _ref : 1,\n    dashed: dashed,\n    transparent: itemSize === 4\n  }, rest)));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9MaW5lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzNCO0FBQzBCO0FBQ1g7QUFDd0Q7O0FBRXRHLDRCQUE0Qiw2Q0FBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGVBQWUscURBQVE7QUFDdkIsZ0JBQWdCLDBDQUFhLHNCQUFzQix1REFBYSxTQUFTLCtDQUFLO0FBQzlFLHlCQUF5QiwyQ0FBYyxXQUFXLHNEQUFZO0FBQzlEO0FBQ0EsbUJBQW1CLDBDQUFhO0FBQ2hDLGdDQUFnQyw4REFBb0IsU0FBUyxzREFBWTtBQUN6RTtBQUNBO0FBQ0EsMEJBQTBCLDBDQUFPLGlCQUFpQiwwQ0FBTyxrQ0FBa0MsMENBQU87QUFDbEcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdDQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGtEQUFxQjtBQUN2QjtBQUNBLEdBQUc7QUFDSCxFQUFFLGtEQUFxQjtBQUN2QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLGdEQUFtQixjQUFjLDhFQUFRO0FBQy9EO0FBQ0E7QUFDQSxHQUFHLHNCQUFzQixnREFBbUI7QUFDNUM7QUFDQTtBQUNBLEdBQUcsZ0JBQWdCLGdEQUFtQixjQUFjLDhFQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFZSIsInNvdXJjZXMiOlsid2VicGFjazovL2phd2FyYS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL0xpbmUuanM/NWQ4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBWZWN0b3IzLCBWZWN0b3I0LCBWZWN0b3IyLCBDb2xvciB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHVzZVRocmVlIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCB7IExpbmVTZWdtZW50czIsIExpbmUyLCBMaW5lTWF0ZXJpYWwsIExpbmVTZWdtZW50c0dlb21ldHJ5LCBMaW5lR2VvbWV0cnkgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuXG5jb25zdCBMaW5lID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBMaW5lKHtcbiAgcG9pbnRzLFxuICBjb2xvciA9IDB4ZmZmZmZmLFxuICB2ZXJ0ZXhDb2xvcnMsXG4gIGxpbmV3aWR0aCxcbiAgbGluZVdpZHRoLFxuICBzZWdtZW50cyxcbiAgZGFzaGVkLFxuICAuLi5yZXN0XG59LCByZWYpIHtcbiAgdmFyIF92ZXJ0ZXhDb2xvcnMkLCBfcmVmO1xuICBjb25zdCBzaXplID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2l6ZSk7XG4gIGNvbnN0IGxpbmUyID0gUmVhY3QudXNlTWVtbygoKSA9PiBzZWdtZW50cyA/IG5ldyBMaW5lU2VnbWVudHMyKCkgOiBuZXcgTGluZTIoKSwgW3NlZ21lbnRzXSk7XG4gIGNvbnN0IFtsaW5lTWF0ZXJpYWxdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IExpbmVNYXRlcmlhbCgpKTtcbiAgY29uc3QgaXRlbVNpemUgPSAodmVydGV4Q29sb3JzID09IG51bGwgfHwgKF92ZXJ0ZXhDb2xvcnMkID0gdmVydGV4Q29sb3JzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3ZlcnRleENvbG9ycyQubGVuZ3RoKSA9PT0gNCA/IDQgOiAzO1xuICBjb25zdCBsaW5lR2VvbSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGdlb20gPSBzZWdtZW50cyA/IG5ldyBMaW5lU2VnbWVudHNHZW9tZXRyeSgpIDogbmV3IExpbmVHZW9tZXRyeSgpO1xuICAgIGNvbnN0IHBWYWx1ZXMgPSBwb2ludHMubWFwKHAgPT4ge1xuICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocCk7XG4gICAgICByZXR1cm4gcCBpbnN0YW5jZW9mIFZlY3RvcjMgfHwgcCBpbnN0YW5jZW9mIFZlY3RvcjQgPyBbcC54LCBwLnksIHAuel0gOiBwIGluc3RhbmNlb2YgVmVjdG9yMiA/IFtwLngsIHAueSwgMF0gOiBpc0FycmF5ICYmIHAubGVuZ3RoID09PSAzID8gW3BbMF0sIHBbMV0sIHBbMl1dIDogaXNBcnJheSAmJiBwLmxlbmd0aCA9PT0gMiA/IFtwWzBdLCBwWzFdLCAwXSA6IHA7XG4gICAgfSk7XG4gICAgZ2VvbS5zZXRQb3NpdGlvbnMocFZhbHVlcy5mbGF0KCkpO1xuICAgIGlmICh2ZXJ0ZXhDb2xvcnMpIHtcbiAgICAgIC8vIHVzaW5nIHZlcnRleENvbG9ycyByZXF1aXJlcyB0aGUgY29sb3IgdmFsdWUgdG8gYmUgd2hpdGUgc2VlICMxODEzXG4gICAgICBjb2xvciA9IDB4ZmZmZmZmO1xuICAgICAgY29uc3QgY1ZhbHVlcyA9IHZlcnRleENvbG9ycy5tYXAoYyA9PiBjIGluc3RhbmNlb2YgQ29sb3IgPyBjLnRvQXJyYXkoKSA6IGMpO1xuICAgICAgZ2VvbS5zZXRDb2xvcnMoY1ZhbHVlcy5mbGF0KCksIGl0ZW1TaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlb207XG4gIH0sIFtwb2ludHMsIHNlZ21lbnRzLCB2ZXJ0ZXhDb2xvcnMsIGl0ZW1TaXplXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgbGluZTIuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTtcbiAgfSwgW3BvaW50cywgbGluZTJdKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGFzaGVkKSB7XG4gICAgICBsaW5lTWF0ZXJpYWwuZGVmaW5lcy5VU0VfREFTSCA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXR0aW5nIGxpbmVNYXRlcmlhbC5kZWZpbmVzLlVTRV9EQVNIIHRvIHVuZGVmaW5lZCBpcyBhcHBhcmVudGx5IG5vdCBzdWZmaWNpZW50LlxuICAgICAgZGVsZXRlIGxpbmVNYXRlcmlhbC5kZWZpbmVzLlVTRV9EQVNIO1xuICAgIH1cbiAgICBsaW5lTWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9LCBbZGFzaGVkLCBsaW5lTWF0ZXJpYWxdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4gbGluZUdlb20uZGlzcG9zZSgpO1xuICB9LCBbbGluZUdlb21dKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsIF9leHRlbmRzKHtcbiAgICBvYmplY3Q6IGxpbmUyLFxuICAgIHJlZjogcmVmXG4gIH0sIHJlc3QpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCB7XG4gICAgb2JqZWN0OiBsaW5lR2VvbSxcbiAgICBhdHRhY2g6IFwiZ2VvbWV0cnlcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgX2V4dGVuZHMoe1xuICAgIG9iamVjdDogbGluZU1hdGVyaWFsLFxuICAgIGF0dGFjaDogXCJtYXRlcmlhbFwiLFxuICAgIGNvbG9yOiBjb2xvcixcbiAgICB2ZXJ0ZXhDb2xvcnM6IEJvb2xlYW4odmVydGV4Q29sb3JzKSxcbiAgICByZXNvbHV0aW9uOiBbc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHRdLFxuICAgIGxpbmV3aWR0aDogKF9yZWYgPSBsaW5ld2lkdGggIT09IG51bGwgJiYgbGluZXdpZHRoICE9PSB2b2lkIDAgPyBsaW5ld2lkdGggOiBsaW5lV2lkdGgpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiAxLFxuICAgIGRhc2hlZDogZGFzaGVkLFxuICAgIHRyYW5zcGFyZW50OiBpdGVtU2l6ZSA9PT0gNFxuICB9LCByZXN0KSkpO1xufSk7XG5cbmV4cG9ydCB7IExpbmUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Line.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/OrbitControls.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/OrbitControls.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrbitControls: () => (/* binding */ OrbitControls)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-99983b2d.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/controls/OrbitControls.js\");\n\n\n\n\n\nconst OrbitControls = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  makeDefault,\n  camera,\n  regress,\n  domElement,\n  enableDamping = true,\n  keyEvents = false,\n  onChange,\n  onStart,\n  onEnd,\n  ...restProps\n}, ref) => {\n  const invalidate = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(state => state.invalidate);\n  const defaultCamera = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(state => state.camera);\n  const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(state => state.gl);\n  const events = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(state => state.events);\n  const setEvents = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(state => state.setEvents);\n  const set = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(state => state.set);\n  const get = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(state => state.get);\n  const performance = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(state => state.performance);\n  const explCamera = camera || defaultCamera;\n  const explDomElement = domElement || events.connected || gl.domElement;\n  const controls = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => new three_stdlib__WEBPACK_IMPORTED_MODULE_3__.OrbitControls(explCamera), [explCamera]);\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(() => {\n    if (controls.enabled) controls.update();\n  }, -1);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    if (keyEvents) {\n      controls.connect(keyEvents === true ? explDomElement : keyEvents);\n    }\n    controls.connect(explDomElement);\n    return () => void controls.dispose();\n  }, [keyEvents, explDomElement, regress, controls, invalidate]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    const callback = e => {\n      invalidate();\n      if (regress) performance.regress();\n      if (onChange) onChange(e);\n    };\n    const onStartCb = e => {\n      if (onStart) onStart(e);\n    };\n    const onEndCb = e => {\n      if (onEnd) onEnd(e);\n    };\n    controls.addEventListener('change', callback);\n    controls.addEventListener('start', onStartCb);\n    controls.addEventListener('end', onEndCb);\n    return () => {\n      controls.removeEventListener('start', onStartCb);\n      controls.removeEventListener('end', onEndCb);\n      controls.removeEventListener('change', callback);\n    };\n  }, [onChange, onStart, onEnd, controls, invalidate, setEvents]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      set({\n        controls\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, controls]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ref: ref,\n    object: controls,\n    enableDamping: enableDamping\n  }, restProps));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9PcmJpdENvbnRyb2xzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwRDtBQUNGO0FBQ3pCO0FBQ2lDOztBQUVoRSxxQ0FBcUMsNkNBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFCQUFxQixxREFBUTtBQUM3Qix3QkFBd0IscURBQVE7QUFDaEMsYUFBYSxxREFBUTtBQUNyQixpQkFBaUIscURBQVE7QUFDekIsb0JBQW9CLHFEQUFRO0FBQzVCLGNBQWMscURBQVE7QUFDdEIsY0FBYyxxREFBUTtBQUN0QixzQkFBc0IscURBQVE7QUFDOUI7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBYSxXQUFXLHVEQUFlO0FBQzFELEVBQUUscURBQVE7QUFDVjtBQUNBLEdBQUc7QUFDSCxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLGdEQUFtQixjQUFjLDhFQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUV3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2phd2FyYS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL09yYml0Q29udHJvbHMuanM/MzdlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgeyB1c2VUaHJlZSwgdXNlRnJhbWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgT3JiaXRDb250cm9scyBhcyBPcmJpdENvbnRyb2xzJDEgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuXG5jb25zdCBPcmJpdENvbnRyb2xzID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBtYWtlRGVmYXVsdCxcbiAgY2FtZXJhLFxuICByZWdyZXNzLFxuICBkb21FbGVtZW50LFxuICBlbmFibGVEYW1waW5nID0gdHJ1ZSxcbiAga2V5RXZlbnRzID0gZmFsc2UsXG4gIG9uQ2hhbmdlLFxuICBvblN0YXJ0LFxuICBvbkVuZCxcbiAgLi4ucmVzdFByb3BzXG59LCByZWYpID0+IHtcbiAgY29uc3QgaW52YWxpZGF0ZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmludmFsaWRhdGUpO1xuICBjb25zdCBkZWZhdWx0Q2FtZXJhID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuY2FtZXJhKTtcbiAgY29uc3QgZ2wgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5nbCk7XG4gIGNvbnN0IGV2ZW50cyA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmV2ZW50cyk7XG4gIGNvbnN0IHNldEV2ZW50cyA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNldEV2ZW50cyk7XG4gIGNvbnN0IHNldCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNldCk7XG4gIGNvbnN0IGdldCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmdldCk7XG4gIGNvbnN0IHBlcmZvcm1hbmNlID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUucGVyZm9ybWFuY2UpO1xuICBjb25zdCBleHBsQ2FtZXJhID0gY2FtZXJhIHx8IGRlZmF1bHRDYW1lcmE7XG4gIGNvbnN0IGV4cGxEb21FbGVtZW50ID0gZG9tRWxlbWVudCB8fCBldmVudHMuY29ubmVjdGVkIHx8IGdsLmRvbUVsZW1lbnQ7XG4gIGNvbnN0IGNvbnRyb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiBuZXcgT3JiaXRDb250cm9scyQxKGV4cGxDYW1lcmEpLCBbZXhwbENhbWVyYV0pO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgaWYgKGNvbnRyb2xzLmVuYWJsZWQpIGNvbnRyb2xzLnVwZGF0ZSgpO1xuICB9LCAtMSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGtleUV2ZW50cykge1xuICAgICAgY29udHJvbHMuY29ubmVjdChrZXlFdmVudHMgPT09IHRydWUgPyBleHBsRG9tRWxlbWVudCA6IGtleUV2ZW50cyk7XG4gICAgfVxuICAgIGNvbnRyb2xzLmNvbm5lY3QoZXhwbERvbUVsZW1lbnQpO1xuICAgIHJldHVybiAoKSA9PiB2b2lkIGNvbnRyb2xzLmRpc3Bvc2UoKTtcbiAgfSwgW2tleUV2ZW50cywgZXhwbERvbUVsZW1lbnQsIHJlZ3Jlc3MsIGNvbnRyb2xzLCBpbnZhbGlkYXRlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBlID0+IHtcbiAgICAgIGludmFsaWRhdGUoKTtcbiAgICAgIGlmIChyZWdyZXNzKSBwZXJmb3JtYW5jZS5yZWdyZXNzKCk7XG4gICAgICBpZiAob25DaGFuZ2UpIG9uQ2hhbmdlKGUpO1xuICAgIH07XG4gICAgY29uc3Qgb25TdGFydENiID0gZSA9PiB7XG4gICAgICBpZiAob25TdGFydCkgb25TdGFydChlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRW5kQ2IgPSBlID0+IHtcbiAgICAgIGlmIChvbkVuZCkgb25FbmQoZSk7XG4gICAgfTtcbiAgICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignc3RhcnQnLCBvblN0YXJ0Q2IpO1xuICAgIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIG9uRW5kQ2IpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGFydCcsIG9uU3RhcnRDYik7XG4gICAgICBjb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmQnLCBvbkVuZENiKTtcbiAgICAgIGNvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9LCBbb25DaGFuZ2UsIG9uU3RhcnQsIG9uRW5kLCBjb250cm9scywgaW52YWxpZGF0ZSwgc2V0RXZlbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1ha2VEZWZhdWx0KSB7XG4gICAgICBjb25zdCBvbGQgPSBnZXQoKS5jb250cm9scztcbiAgICAgIHNldCh7XG4gICAgICAgIGNvbnRyb2xzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiBzZXQoe1xuICAgICAgICBjb250cm9sczogb2xkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFttYWtlRGVmYXVsdCwgY29udHJvbHNdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICBvYmplY3Q6IGNvbnRyb2xzLFxuICAgIGVuYWJsZURhbXBpbmc6IGVuYWJsZURhbXBpbmdcbiAgfSwgcmVzdFByb3BzKSk7XG59KTtcblxuZXhwb3J0IHsgT3JiaXRDb250cm9scyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/OrbitControls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Outlines.js":
/*!*********************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Outlines.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Outlines: () => (/* binding */ Outlines)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _shaderMaterial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shaderMaterial.js */ \"(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-99983b2d.esm.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _helpers_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/constants.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/constants.js\");\n\n\n\n\n\n\n\n\nconst OutlinesMaterial = /* @__PURE__ */(0,_shaderMaterial_js__WEBPACK_IMPORTED_MODULE_2__.shaderMaterial)({\n  screenspace: false,\n  color: /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Color('black'),\n  opacity: 1,\n  thickness: 0.05,\n  size: /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()\n}, `#include <common>\n   #include <morphtarget_pars_vertex>\n   #include <skinning_pars_vertex>\n   uniform float thickness;\n   uniform float screenspace;\n   uniform vec2 size;\n   void main() {\n     #if defined (USE_SKINNING)\n\t     #include <beginnormal_vertex>\n       #include <morphnormal_vertex>\n       #include <skinbase_vertex>\n       #include <skinnormal_vertex>\n       #include <defaultnormal_vertex>\n     #endif\n     #include <begin_vertex>\n\t   #include <morphtarget_vertex>\n\t   #include <skinning_vertex>\n     #include <project_vertex>\n     vec4 tNormal = vec4(normal, 0.0);\n     vec4 tPosition = vec4(transformed, 1.0);\n     #ifdef USE_INSTANCING\n       tNormal = instanceMatrix * tNormal;\n       tPosition = instanceMatrix * tPosition;\n     #endif\n     if (screenspace == 0.0) {\n       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;\n       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); \n     } else {\n       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;\n       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;\n       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;\n       clipPosition.xy += offset;\n       gl_Position = clipPosition;\n     }\n   }`, `uniform vec3 color;\n   uniform float opacity;\n   void main(){\n     gl_FragColor = vec4(color, opacity);\n     #include <tonemapping_fragment>\n     #include <${_helpers_constants_js__WEBPACK_IMPORTED_MODULE_4__.version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n   }`);\nfunction Outlines({\n  color = 'black',\n  opacity = 1,\n  transparent = false,\n  screenspace = false,\n  toneMapped = true,\n  polygonOffset = false,\n  polygonOffsetFactor = 0,\n  renderOrder = 0,\n  thickness = 0.05,\n  angle = Math.PI,\n  ...props\n}) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef();\n  const [material] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => new OutlinesMaterial({\n    side: three__WEBPACK_IMPORTED_MODULE_3__.BackSide\n  }));\n  const {\n    gl\n  } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.A)();\n  const contextSize = gl.getDrawingBufferSize(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2());\n  react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.e)({\n    OutlinesMaterial\n  }), []);\n  const oldAngle = react__WEBPACK_IMPORTED_MODULE_1__.useRef(0);\n  const oldGeometry = react__WEBPACK_IMPORTED_MODULE_1__.useRef();\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    const group = ref.current;\n    if (!group) return;\n    const parent = group.parent;\n    if (parent && parent.geometry) {\n      if (oldAngle.current !== angle || oldGeometry.current !== parent.geometry) {\n        var _group$children;\n        oldAngle.current = angle;\n        oldGeometry.current = parent.geometry;\n\n        // Remove old mesh\n        let mesh = (_group$children = group.children) == null ? void 0 : _group$children[0];\n        if (mesh) {\n          if (angle) mesh.geometry.dispose();\n          group.remove(mesh);\n        }\n        if (parent.skeleton) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_3__.SkinnedMesh();\n          mesh.material = material;\n          mesh.bind(parent.skeleton, parent.bindMatrix);\n          group.add(mesh);\n        } else if (parent.isInstancedMesh) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_3__.InstancedMesh(parent.geometry, material, parent.count);\n          mesh.instanceMatrix = parent.instanceMatrix;\n          group.add(mesh);\n        } else {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh();\n          mesh.material = material;\n          group.add(mesh);\n        }\n        mesh.geometry = angle ? (0,three_stdlib__WEBPACK_IMPORTED_MODULE_6__.toCreasedNormals)(parent.geometry, angle) : parent.geometry;\n      }\n    }\n  });\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    const group = ref.current;\n    if (!group) return;\n    const mesh = group.children[0];\n    if (mesh) {\n      mesh.renderOrder = renderOrder;\n      (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.j)(mesh.material, {\n        transparent,\n        thickness,\n        color,\n        opacity,\n        size: contextSize,\n        screenspace,\n        toneMapped,\n        polygonOffset,\n        polygonOffsetFactor\n      });\n    }\n  });\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    return () => {\n      // Dispose everything on unmount\n      const group = ref.current;\n      if (!group) return;\n      const mesh = group.children[0];\n      if (mesh) {\n        if (angle) mesh.geometry.dispose();\n        group.remove(mesh);\n      }\n    };\n  }, []);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ref: ref\n  }, props));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9PdXRsaW5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDQTtBQUNzQjtBQUNhO0FBQ2xCO0FBQ0U7O0FBRWxELHdDQUF3QyxrRUFBYztBQUN0RDtBQUNBLDRCQUE0Qix3Q0FBVztBQUN2QztBQUNBO0FBQ0EsMkJBQTJCLDBDQUFhO0FBQ3hDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwREFBTyx1REFBdUQ7QUFDL0UsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjLHlDQUFZO0FBQzFCLHFCQUFxQiwyQ0FBYztBQUNuQyxVQUFVLDJDQUFjO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSxFQUFFLHFEQUFRO0FBQ2Qsa0RBQWtELDBDQUFhO0FBQy9ELEVBQUUsMENBQWEsT0FBTyxxREFBTTtBQUM1QjtBQUNBLEdBQUc7QUFDSCxtQkFBbUIseUNBQVk7QUFDL0Isc0JBQXNCLHlDQUFZO0FBQ2xDLEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOENBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixxQkFBcUIsZ0RBQW1CO0FBQ3hDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YscUJBQXFCLHVDQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4REFBZ0I7QUFDaEQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGtEQUFxQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsZ0RBQW1CLFVBQVUsOEVBQVE7QUFDM0Q7QUFDQSxHQUFHO0FBQ0g7O0FBRW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamF3YXJhLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvT3V0bGluZXMuanM/ZjhkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzaGFkZXJNYXRlcmlhbCB9IGZyb20gJy4vc2hhZGVyTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgdXNlVGhyZWUsIGV4dGVuZCwgYXBwbHlQcm9wcyB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyB0b0NyZWFzZWROb3JtYWxzIH0gZnJvbSAndGhyZWUtc3RkbGliJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi9oZWxwZXJzL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IE91dGxpbmVzTWF0ZXJpYWwgPSAvKiBAX19QVVJFX18gKi9zaGFkZXJNYXRlcmlhbCh7XG4gIHNjcmVlbnNwYWNlOiBmYWxzZSxcbiAgY29sb3I6IC8qIEBfX1BVUkVfXyAqL25ldyBUSFJFRS5Db2xvcignYmxhY2snKSxcbiAgb3BhY2l0eTogMSxcbiAgdGhpY2tuZXNzOiAwLjA1LFxuICBzaXplOiAvKiBAX19QVVJFX18gKi9uZXcgVEhSRUUuVmVjdG9yMigpXG59LCBgI2luY2x1ZGUgPGNvbW1vbj5cbiAgICNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cbiAgICNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cbiAgIHVuaWZvcm0gZmxvYXQgdGhpY2tuZXNzO1xuICAgdW5pZm9ybSBmbG9hdCBzY3JlZW5zcGFjZTtcbiAgIHVuaWZvcm0gdmVjMiBzaXplO1xuICAgdm9pZCBtYWluKCkge1xuICAgICAjaWYgZGVmaW5lZCAoVVNFX1NLSU5OSU5HKVxuXHQgICAgICNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XG4gICAgICAgI2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cbiAgICAgICAjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxuICAgICAgICNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cbiAgICAgICAjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XG4gICAgICNlbmRpZlxuICAgICAjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuXHQgICAjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxuXHQgICAjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxuICAgICAjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XG4gICAgIHZlYzQgdE5vcm1hbCA9IHZlYzQobm9ybWFsLCAwLjApO1xuICAgICB2ZWM0IHRQb3NpdGlvbiA9IHZlYzQodHJhbnNmb3JtZWQsIDEuMCk7XG4gICAgICNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xuICAgICAgIHROb3JtYWwgPSBpbnN0YW5jZU1hdHJpeCAqIHROb3JtYWw7XG4gICAgICAgdFBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiB0UG9zaXRpb247XG4gICAgICNlbmRpZlxuICAgICBpZiAoc2NyZWVuc3BhY2UgPT0gMC4wKSB7XG4gICAgICAgdmVjMyBuZXdQb3NpdGlvbiA9IHRQb3NpdGlvbi54eXogKyB0Tm9ybWFsLnh5eiAqIHRoaWNrbmVzcztcbiAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KG5ld1Bvc2l0aW9uLCAxLjApOyBcbiAgICAgfSBlbHNlIHtcbiAgICAgICB2ZWM0IGNsaXBQb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB0UG9zaXRpb247XG4gICAgICAgdmVjNCBjbGlwTm9ybWFsID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHROb3JtYWw7XG4gICAgICAgdmVjMiBvZmZzZXQgPSBub3JtYWxpemUoY2xpcE5vcm1hbC54eSkgKiB0aGlja25lc3MgLyBzaXplICogY2xpcFBvc2l0aW9uLncgKiAyLjA7XG4gICAgICAgY2xpcFBvc2l0aW9uLnh5ICs9IG9mZnNldDtcbiAgICAgICBnbF9Qb3NpdGlvbiA9IGNsaXBQb3NpdGlvbjtcbiAgICAgfVxuICAgfWAsIGB1bmlmb3JtIHZlYzMgY29sb3I7XG4gICB1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG4gICB2b2lkIG1haW4oKXtcbiAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgb3BhY2l0eSk7XG4gICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cbiAgICAgI2luY2x1ZGUgPCR7dmVyc2lvbiA+PSAxNTQgPyAnY29sb3JzcGFjZV9mcmFnbWVudCcgOiAnZW5jb2RpbmdzX2ZyYWdtZW50J30+XG4gICB9YCk7XG5mdW5jdGlvbiBPdXRsaW5lcyh7XG4gIGNvbG9yID0gJ2JsYWNrJyxcbiAgb3BhY2l0eSA9IDEsXG4gIHRyYW5zcGFyZW50ID0gZmFsc2UsXG4gIHNjcmVlbnNwYWNlID0gZmFsc2UsXG4gIHRvbmVNYXBwZWQgPSB0cnVlLFxuICBwb2x5Z29uT2Zmc2V0ID0gZmFsc2UsXG4gIHBvbHlnb25PZmZzZXRGYWN0b3IgPSAwLFxuICByZW5kZXJPcmRlciA9IDAsXG4gIHRoaWNrbmVzcyA9IDAuMDUsXG4gIGFuZ2xlID0gTWF0aC5QSSxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IFttYXRlcmlhbF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgT3V0bGluZXNNYXRlcmlhbCh7XG4gICAgc2lkZTogVEhSRUUuQmFja1NpZGVcbiAgfSkpO1xuICBjb25zdCB7XG4gICAgZ2xcbiAgfSA9IHVzZVRocmVlKCk7XG4gIGNvbnN0IGNvbnRleHRTaXplID0gZ2wuZ2V0RHJhd2luZ0J1ZmZlclNpemUobmV3IFRIUkVFLlZlY3RvcjIoKSk7XG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4gZXh0ZW5kKHtcbiAgICBPdXRsaW5lc01hdGVyaWFsXG4gIH0pLCBbXSk7XG4gIGNvbnN0IG9sZEFuZ2xlID0gUmVhY3QudXNlUmVmKDApO1xuICBjb25zdCBvbGRHZW9tZXRyeSA9IFJlYWN0LnVzZVJlZigpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGdyb3VwID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFncm91cCkgcmV0dXJuO1xuICAgIGNvbnN0IHBhcmVudCA9IGdyb3VwLnBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5nZW9tZXRyeSkge1xuICAgICAgaWYgKG9sZEFuZ2xlLmN1cnJlbnQgIT09IGFuZ2xlIHx8IG9sZEdlb21ldHJ5LmN1cnJlbnQgIT09IHBhcmVudC5nZW9tZXRyeSkge1xuICAgICAgICB2YXIgX2dyb3VwJGNoaWxkcmVuO1xuICAgICAgICBvbGRBbmdsZS5jdXJyZW50ID0gYW5nbGU7XG4gICAgICAgIG9sZEdlb21ldHJ5LmN1cnJlbnQgPSBwYXJlbnQuZ2VvbWV0cnk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIG9sZCBtZXNoXG4gICAgICAgIGxldCBtZXNoID0gKF9ncm91cCRjaGlsZHJlbiA9IGdyb3VwLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2dyb3VwJGNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAobWVzaCkge1xuICAgICAgICAgIGlmIChhbmdsZSkgbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgICAgZ3JvdXAucmVtb3ZlKG1lc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQuc2tlbGV0b24pIHtcbiAgICAgICAgICBtZXNoID0gbmV3IFRIUkVFLlNraW5uZWRNZXNoKCk7XG4gICAgICAgICAgbWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgICAgICAgIG1lc2guYmluZChwYXJlbnQuc2tlbGV0b24sIHBhcmVudC5iaW5kTWF0cml4KTtcbiAgICAgICAgICBncm91cC5hZGQobWVzaCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50LmlzSW5zdGFuY2VkTWVzaCkge1xuICAgICAgICAgIG1lc2ggPSBuZXcgVEhSRUUuSW5zdGFuY2VkTWVzaChwYXJlbnQuZ2VvbWV0cnksIG1hdGVyaWFsLCBwYXJlbnQuY291bnQpO1xuICAgICAgICAgIG1lc2guaW5zdGFuY2VNYXRyaXggPSBwYXJlbnQuaW5zdGFuY2VNYXRyaXg7XG4gICAgICAgICAgZ3JvdXAuYWRkKG1lc2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc2ggPSBuZXcgVEhSRUUuTWVzaCgpO1xuICAgICAgICAgIG1lc2gubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgICBncm91cC5hZGQobWVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzaC5nZW9tZXRyeSA9IGFuZ2xlID8gdG9DcmVhc2VkTm9ybWFscyhwYXJlbnQuZ2VvbWV0cnksIGFuZ2xlKSA6IHBhcmVudC5nZW9tZXRyeTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGdyb3VwID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFncm91cCkgcmV0dXJuO1xuICAgIGNvbnN0IG1lc2ggPSBncm91cC5jaGlsZHJlblswXTtcbiAgICBpZiAobWVzaCkge1xuICAgICAgbWVzaC5yZW5kZXJPcmRlciA9IHJlbmRlck9yZGVyO1xuICAgICAgYXBwbHlQcm9wcyhtZXNoLm1hdGVyaWFsLCB7XG4gICAgICAgIHRyYW5zcGFyZW50LFxuICAgICAgICB0aGlja25lc3MsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBzaXplOiBjb250ZXh0U2l6ZSxcbiAgICAgICAgc2NyZWVuc3BhY2UsXG4gICAgICAgIHRvbmVNYXBwZWQsXG4gICAgICAgIHBvbHlnb25PZmZzZXQsXG4gICAgICAgIHBvbHlnb25PZmZzZXRGYWN0b3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIERpc3Bvc2UgZXZlcnl0aGluZyBvbiB1bm1vdW50XG4gICAgICBjb25zdCBncm91cCA9IHJlZi5jdXJyZW50O1xuICAgICAgaWYgKCFncm91cCkgcmV0dXJuO1xuICAgICAgY29uc3QgbWVzaCA9IGdyb3VwLmNoaWxkcmVuWzBdO1xuICAgICAgaWYgKG1lc2gpIHtcbiAgICAgICAgaWYgKGFuZ2xlKSBtZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgZ3JvdXAucmVtb3ZlKG1lc2gpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmXG4gIH0sIHByb3BzKSk7XG59XG5cbmV4cG9ydCB7IE91dGxpbmVzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Outlines.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Text.js":
/*!*****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Text.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var troika_three_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! troika-three-text */ \"(ssr)/./node_modules/troika-three-text/dist/troika-three-text.esm.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-99983b2d.esm.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n\n\n\n\n\n\n// eslint-disable-next-line prettier/prettier\nconst Text = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  sdfGlyphSize = 64,\n  anchorX = 'center',\n  anchorY = 'middle',\n  font,\n  fontSize = 1,\n  children,\n  characters,\n  onSync,\n  ...props\n}, ref) => {\n  const invalidate = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(({\n    invalidate\n  }) => invalidate);\n  const [troikaMesh] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => new troika_three_text__WEBPACK_IMPORTED_MODULE_3__.Text());\n  const [nodes, text] = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    const n = [];\n    let t = '';\n    react__WEBPACK_IMPORTED_MODULE_1__.Children.forEach(children, child => {\n      if (typeof child === 'string' || typeof child === 'number') {\n        t += child;\n      } else {\n        n.push(child);\n      }\n    });\n    return [n, t];\n  }, [children]);\n  (0,suspend_react__WEBPACK_IMPORTED_MODULE_4__.suspend)(() => new Promise(res => (0,troika_three_text__WEBPACK_IMPORTED_MODULE_3__.preloadFont)({\n    font,\n    characters\n  }, res)), ['troika-text', font, characters]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => void troikaMesh.sync(() => {\n    invalidate();\n    if (onSync) onSync(troikaMesh);\n  }));\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    return () => troikaMesh.dispose();\n  }, [troikaMesh]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    object: troikaMesh,\n    ref: ref,\n    font: font,\n    text: text,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    fontSize: fontSize,\n    sdfGlyphSize: sdfGlyphSize\n  }, props), nodes);\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9UZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDaUM7QUFDbEI7QUFDTjs7QUFFeEM7QUFDQSw0QkFBNEIsNkNBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUIscURBQVE7QUFDN0I7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLDJDQUFjLFdBQVcsbURBQU07QUFDdEQsd0JBQXdCLDBDQUFhO0FBQ3JDO0FBQ0E7QUFDQSxJQUFJLDJDQUFjO0FBQ2xCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFLHNEQUFPLDBCQUEwQiw4REFBVztBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsZ0RBQW1CLGNBQWMsOEVBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamF3YXJhLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvVGV4dC5qcz8wZTQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFRleHQgYXMgVGV4dCQxLCBwcmVsb2FkRm9udCB9IGZyb20gJ3Ryb2lrYS10aHJlZS10ZXh0JztcbmltcG9ydCB7IHVzZVRocmVlIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCB7IHN1c3BlbmQgfSBmcm9tICdzdXNwZW5kLXJlYWN0JztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZXR0aWVyL3ByZXR0aWVyXG5jb25zdCBUZXh0ID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBzZGZHbHlwaFNpemUgPSA2NCxcbiAgYW5jaG9yWCA9ICdjZW50ZXInLFxuICBhbmNob3JZID0gJ21pZGRsZScsXG4gIGZvbnQsXG4gIGZvbnRTaXplID0gMSxcbiAgY2hpbGRyZW4sXG4gIGNoYXJhY3RlcnMsXG4gIG9uU3luYyxcbiAgLi4ucHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCBpbnZhbGlkYXRlID0gdXNlVGhyZWUoKHtcbiAgICBpbnZhbGlkYXRlXG4gIH0pID0+IGludmFsaWRhdGUpO1xuICBjb25zdCBbdHJvaWthTWVzaF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVGV4dCQxKCkpO1xuICBjb25zdCBbbm9kZXMsIHRleHRdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgbiA9IFtdO1xuICAgIGxldCB0ID0gJyc7XG4gICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgICB0ICs9IGNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW24sIHRdO1xuICB9LCBbY2hpbGRyZW5dKTtcbiAgc3VzcGVuZCgoKSA9PiBuZXcgUHJvbWlzZShyZXMgPT4gcHJlbG9hZEZvbnQoe1xuICAgIGZvbnQsXG4gICAgY2hhcmFjdGVyc1xuICB9LCByZXMpKSwgWyd0cm9pa2EtdGV4dCcsIGZvbnQsIGNoYXJhY3RlcnNdKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgdHJvaWthTWVzaC5zeW5jKCgpID0+IHtcbiAgICBpbnZhbGlkYXRlKCk7XG4gICAgaWYgKG9uU3luYykgb25TeW5jKHRyb2lrYU1lc2gpO1xuICB9KSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHRyb2lrYU1lc2guZGlzcG9zZSgpO1xuICB9LCBbdHJvaWthTWVzaF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgX2V4dGVuZHMoe1xuICAgIG9iamVjdDogdHJvaWthTWVzaCxcbiAgICByZWY6IHJlZixcbiAgICBmb250OiBmb250LFxuICAgIHRleHQ6IHRleHQsXG4gICAgYW5jaG9yWDogYW5jaG9yWCxcbiAgICBhbmNob3JZOiBhbmNob3JZLFxuICAgIGZvbnRTaXplOiBmb250U2l6ZSxcbiAgICBzZGZHbHlwaFNpemU6IHNkZkdseXBoU2l6ZVxuICB9LCBwcm9wcyksIG5vZGVzKTtcbn0pO1xuXG5leHBvcnQgeyBUZXh0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Text.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/shaderMaterial.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shaderMaterial: () => (/* binding */ shaderMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\n\nfunction shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {\n  const material = class material extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    constructor(parameters = {}) {\n      const entries = Object.entries(uniforms);\n      // Create unforms and shaders\n      super({\n        uniforms: entries.reduce((acc, [name, value]) => {\n          const uniform = three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone({\n            [name]: {\n              value\n            }\n          });\n          return {\n            ...acc,\n            ...uniform\n          };\n        }, {}),\n        vertexShader,\n        fragmentShader\n      });\n      // Create getter/setters\n      this.key = '';\n      entries.forEach(([name]) => Object.defineProperty(this, name, {\n        get: () => this.uniforms[name].value,\n        set: v => this.uniforms[name].value = v\n      }));\n\n      // Assign parameters, this might include uniforms\n      Object.assign(this, parameters);\n      // Call onInit\n      if (onInit) onInit(this);\n    }\n  };\n  material.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n  return material;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9zaGFkZXJNYXRlcmlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjs7QUFFL0I7QUFDQSwwQ0FBMEMsaURBQW9CO0FBQzlELCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnREFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNENBQWU7QUFDaEM7QUFDQTs7QUFFMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qYXdhcmEvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9zaGFkZXJNYXRlcmlhbC5qcz9jZmJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxuZnVuY3Rpb24gc2hhZGVyTWF0ZXJpYWwodW5pZm9ybXMsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIG9uSW5pdCkge1xuICBjb25zdCBtYXRlcmlhbCA9IGNsYXNzIG1hdGVyaWFsIGV4dGVuZHMgVEhSRUUuU2hhZGVyTWF0ZXJpYWwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHVuaWZvcm1zKTtcbiAgICAgIC8vIENyZWF0ZSB1bmZvcm1zIGFuZCBzaGFkZXJzXG4gICAgICBzdXBlcih7XG4gICAgICAgIHVuaWZvcm1zOiBlbnRyaWVzLnJlZHVjZSgoYWNjLCBbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgY29uc3QgdW5pZm9ybSA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoe1xuICAgICAgICAgICAgW25hbWVdOiB7XG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIC4uLnVuaWZvcm1cbiAgICAgICAgICB9O1xuICAgICAgICB9LCB7fSksXG4gICAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXJcbiAgICAgIH0pO1xuICAgICAgLy8gQ3JlYXRlIGdldHRlci9zZXR0ZXJzXG4gICAgICB0aGlzLmtleSA9ICcnO1xuICAgICAgZW50cmllcy5mb3JFYWNoKChbbmFtZV0pID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgIGdldDogKCkgPT4gdGhpcy51bmlmb3Jtc1tuYW1lXS52YWx1ZSxcbiAgICAgICAgc2V0OiB2ID0+IHRoaXMudW5pZm9ybXNbbmFtZV0udmFsdWUgPSB2XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIEFzc2lnbiBwYXJhbWV0ZXJzLCB0aGlzIG1pZ2h0IGluY2x1ZGUgdW5pZm9ybXNcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1ldGVycyk7XG4gICAgICAvLyBDYWxsIG9uSW5pdFxuICAgICAgaWYgKG9uSW5pdCkgb25Jbml0KHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgbWF0ZXJpYWwua2V5ID0gVEhSRUUuTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuICByZXR1cm4gbWF0ZXJpYWw7XG59XG5cbmV4cG9ydCB7IHNoYWRlck1hdGVyaWFsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useAnimations.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useAnimations.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAnimations: () => (/* binding */ useAnimations)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-99983b2d.esm.js\");\n\n\n\n\nfunction useAnimations(clips, root) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const [actualRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => root ? root instanceof three__WEBPACK_IMPORTED_MODULE_1__.Object3D ? {\n    current: root\n  } : root : ref);\n  // eslint-disable-next-line prettier/prettier\n  const [mixer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new three__WEBPACK_IMPORTED_MODULE_1__.AnimationMixer(undefined));\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n    if (root) actualRef.current = root instanceof three__WEBPACK_IMPORTED_MODULE_1__.Object3D ? root : root.current;\n    mixer._root = actualRef.current;\n  });\n  const lazyActions = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n  const api = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const actions = {};\n    clips.forEach(clip => Object.defineProperty(actions, clip.name, {\n      enumerable: true,\n      get() {\n        if (actualRef.current) {\n          return lazyActions.current[clip.name] || (lazyActions.current[clip.name] = mixer.clipAction(clip, actualRef.current));\n        }\n      },\n      configurable: true\n    }));\n    return {\n      ref: actualRef,\n      clips,\n      actions,\n      names: clips.map(c => c.name),\n      mixer\n    };\n  }, [clips]);\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)((state, delta) => mixer.update(delta));\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const currentRoot = actualRef.current;\n    return () => {\n      // Clean up only when clips change, wipe out lazy actions and uncache clips\n      lazyActions.current = {};\n      mixer.stopAllAction();\n      Object.values(api.actions).forEach(action => {\n        if (currentRoot) {\n          mixer.uncacheAction(action, currentRoot);\n        }\n      });\n    };\n  }, [clips]);\n  return api;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VBbmltYXRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStCO0FBQ2tCO0FBQ0g7O0FBRTlDO0FBQ0EsY0FBYyx5Q0FBWTtBQUMxQixzQkFBc0IsMkNBQWMsOEJBQThCLDJDQUFRO0FBQzFFO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0JBQWtCLDJDQUFjLFdBQVcsaURBQWM7QUFDekQsRUFBRSxrREFBcUI7QUFDdkIsa0RBQWtELDJDQUFRO0FBQzFEO0FBQ0EsR0FBRztBQUNILHNCQUFzQix5Q0FBWSxHQUFHO0FBQ3JDLGNBQWMsMENBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxxREFBUTtBQUNWLEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamF3YXJhLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvdXNlQW5pbWF0aW9ucy5qcz9hMGI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE9iamVjdDNELCBBbmltYXRpb25NaXhlciB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHVzZUZyYW1lIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcblxuZnVuY3Rpb24gdXNlQW5pbWF0aW9ucyhjbGlwcywgcm9vdCkge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgW2FjdHVhbFJlZl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiByb290ID8gcm9vdCBpbnN0YW5jZW9mIE9iamVjdDNEID8ge1xuICAgIGN1cnJlbnQ6IHJvb3RcbiAgfSA6IHJvb3QgOiByZWYpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJldHRpZXIvcHJldHRpZXJcbiAgY29uc3QgW21peGVyXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBBbmltYXRpb25NaXhlcih1bmRlZmluZWQpKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAocm9vdCkgYWN0dWFsUmVmLmN1cnJlbnQgPSByb290IGluc3RhbmNlb2YgT2JqZWN0M0QgPyByb290IDogcm9vdC5jdXJyZW50O1xuICAgIG1peGVyLl9yb290ID0gYWN0dWFsUmVmLmN1cnJlbnQ7XG4gIH0pO1xuICBjb25zdCBsYXp5QWN0aW9ucyA9IFJlYWN0LnVzZVJlZih7fSk7XG4gIGNvbnN0IGFwaSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGFjdGlvbnMgPSB7fTtcbiAgICBjbGlwcy5mb3JFYWNoKGNsaXAgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGlvbnMsIGNsaXAubmFtZSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKGFjdHVhbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGxhenlBY3Rpb25zLmN1cnJlbnRbY2xpcC5uYW1lXSB8fCAobGF6eUFjdGlvbnMuY3VycmVudFtjbGlwLm5hbWVdID0gbWl4ZXIuY2xpcEFjdGlvbihjbGlwLCBhY3R1YWxSZWYuY3VycmVudCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSkpO1xuICAgIHJldHVybiB7XG4gICAgICByZWY6IGFjdHVhbFJlZixcbiAgICAgIGNsaXBzLFxuICAgICAgYWN0aW9ucyxcbiAgICAgIG5hbWVzOiBjbGlwcy5tYXAoYyA9PiBjLm5hbWUpLFxuICAgICAgbWl4ZXJcbiAgICB9O1xuICB9LCBbY2xpcHNdKTtcbiAgdXNlRnJhbWUoKHN0YXRlLCBkZWx0YSkgPT4gbWl4ZXIudXBkYXRlKGRlbHRhKSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudFJvb3QgPSBhY3R1YWxSZWYuY3VycmVudDtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gQ2xlYW4gdXAgb25seSB3aGVuIGNsaXBzIGNoYW5nZSwgd2lwZSBvdXQgbGF6eSBhY3Rpb25zIGFuZCB1bmNhY2hlIGNsaXBzXG4gICAgICBsYXp5QWN0aW9ucy5jdXJyZW50ID0ge307XG4gICAgICBtaXhlci5zdG9wQWxsQWN0aW9uKCk7XG4gICAgICBPYmplY3QudmFsdWVzKGFwaS5hY3Rpb25zKS5mb3JFYWNoKGFjdGlvbiA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50Um9vdCkge1xuICAgICAgICAgIG1peGVyLnVuY2FjaGVBY3Rpb24oYWN0aW9uLCBjdXJyZW50Um9vdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtjbGlwc10pO1xuICByZXR1cm4gYXBpO1xufVxuXG5leHBvcnQgeyB1c2VBbmltYXRpb25zIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useAnimations.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\n\nconst getVersion = () => parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, ''));\nconst version = /* @__PURE__ */getVersion();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7O0FBRWpDLGtDQUFrQywyQ0FBUTtBQUMxQzs7QUFFbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qYXdhcmEvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9jb25zdGFudHMuanM/ZjFjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRVZJU0lPTiB9IGZyb20gJ3RocmVlJztcblxuY29uc3QgZ2V0VmVyc2lvbiA9ICgpID0+IHBhcnNlSW50KFJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZywgJycpKTtcbmNvbnN0IHZlcnNpb24gPSAvKiBAX19QVVJFX18gKi9nZXRWZXJzaW9uKCk7XG5cbmV4cG9ydCB7IHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/zustand/esm/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/zustand/esm/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction createStore(createState) {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (nextState !== state) {\n      const previousState = state;\n      state = replace ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is) => {\n    console.warn(\"[DEPRECATED] Please use `subscribeWithSelector` middleware\");\n    let currentSlice = selector(state);\n    function listenerToAdd() {\n      const nextSlice = selector(state);\n      if (!equalityFn(currentSlice, nextSlice)) {\n        const previousSlice = currentSlice;\n        listener(currentSlice = nextSlice, previousSlice);\n      }\n    }\n    listeners.add(listenerToAdd);\n    return () => listeners.delete(listenerToAdd);\n  };\n  const subscribe = (listener, selector, equalityFn) => {\n    if (selector || equalityFn) {\n      return subscribeWithSelector(listener, selector, equalityFn);\n    }\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => listeners.clear();\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n}\n\nconst isSSR = typeof window === \"undefined\" || !window.navigator || /ServerSideRendering|^Deno\\//.test(window.navigator.userAgent);\nconst useIsomorphicLayoutEffect = isSSR ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\nfunction create(createState) {\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useStore = (selector = api.getState, equalityFn = Object.is) => {\n    const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((c) => c + 1, 0);\n    const state = api.getState();\n    const stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    const selectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selector);\n    const equalityFnRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(equalityFn);\n    const erroredRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const currentSliceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (currentSliceRef.current === void 0) {\n      currentSliceRef.current = selector(state);\n    }\n    let newStateSlice;\n    let hasNewStateSlice = false;\n    if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {\n      newStateSlice = selector(state);\n      hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);\n    }\n    useIsomorphicLayoutEffect(() => {\n      if (hasNewStateSlice) {\n        currentSliceRef.current = newStateSlice;\n      }\n      stateRef.current = state;\n      selectorRef.current = selector;\n      equalityFnRef.current = equalityFn;\n      erroredRef.current = false;\n    });\n    const stateBeforeSubscriptionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    useIsomorphicLayoutEffect(() => {\n      const listener = () => {\n        try {\n          const nextState = api.getState();\n          const nextStateSlice = selectorRef.current(nextState);\n          if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {\n            stateRef.current = nextState;\n            currentSliceRef.current = nextStateSlice;\n            forceUpdate();\n          }\n        } catch (error) {\n          erroredRef.current = true;\n          forceUpdate();\n        }\n      };\n      const unsubscribe = api.subscribe(listener);\n      if (api.getState() !== stateBeforeSubscriptionRef.current) {\n        listener();\n      }\n      return unsubscribe;\n    }, []);\n    const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(sliceToReturn);\n    return sliceToReturn;\n  };\n  Object.assign(useStore, api);\n  useStore[Symbol.iterator] = function() {\n    console.warn(\"[useStore, api] = create() is deprecated and will be removed in v4\");\n    const items = [useStore, api];\n    return {\n      next() {\n        const done = items.length <= 0;\n        return { value: items.shift(), done };\n      }\n    };\n  };\n  return useStore;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRjs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLDRDQUFTLEdBQUcsa0RBQWU7QUFDckU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlEQUFVO0FBQ3RDO0FBQ0EscUJBQXFCLDZDQUFNO0FBQzNCLHdCQUF3Qiw2Q0FBTTtBQUM5QiwwQkFBMEIsNkNBQU07QUFDaEMsdUJBQXVCLDZDQUFNO0FBQzdCLDRCQUE0Qiw2Q0FBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVDQUF1Qyw2Q0FBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLG9EQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2phd2FyYS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vaW5kZXguanM/NTZmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWR1Y2VyLCB1c2VSZWYsIHVzZURlYnVnVmFsdWUsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShjcmVhdGVTdGF0ZSkge1xuICBsZXQgc3RhdGU7XG4gIGNvbnN0IGxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHNldFN0YXRlID0gKHBhcnRpYWwsIHJlcGxhY2UpID0+IHtcbiAgICBjb25zdCBuZXh0U3RhdGUgPSB0eXBlb2YgcGFydGlhbCA9PT0gXCJmdW5jdGlvblwiID8gcGFydGlhbChzdGF0ZSkgOiBwYXJ0aWFsO1xuICAgIGlmIChuZXh0U3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gc3RhdGU7XG4gICAgICBzdGF0ZSA9IHJlcGxhY2UgPyBuZXh0U3RhdGUgOiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoc3RhdGUsIHByZXZpb3VzU3RhdGUpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdldFN0YXRlID0gKCkgPT4gc3RhdGU7XG4gIGNvbnN0IHN1YnNjcmliZVdpdGhTZWxlY3RvciA9IChsaXN0ZW5lciwgc2VsZWN0b3IgPSBnZXRTdGF0ZSwgZXF1YWxpdHlGbiA9IE9iamVjdC5pcykgPT4ge1xuICAgIGNvbnNvbGUud2FybihcIltERVBSRUNBVEVEXSBQbGVhc2UgdXNlIGBzdWJzY3JpYmVXaXRoU2VsZWN0b3JgIG1pZGRsZXdhcmVcIik7XG4gICAgbGV0IGN1cnJlbnRTbGljZSA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICBmdW5jdGlvbiBsaXN0ZW5lclRvQWRkKCkge1xuICAgICAgY29uc3QgbmV4dFNsaWNlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgaWYgKCFlcXVhbGl0eUZuKGN1cnJlbnRTbGljZSwgbmV4dFNsaWNlKSkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1NsaWNlID0gY3VycmVudFNsaWNlO1xuICAgICAgICBsaXN0ZW5lcihjdXJyZW50U2xpY2UgPSBuZXh0U2xpY2UsIHByZXZpb3VzU2xpY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyVG9BZGQpO1xuICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyVG9BZGQpO1xuICB9O1xuICBjb25zdCBzdWJzY3JpYmUgPSAobGlzdGVuZXIsIHNlbGVjdG9yLCBlcXVhbGl0eUZuKSA9PiB7XG4gICAgaWYgKHNlbGVjdG9yIHx8IGVxdWFsaXR5Rm4pIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmVXaXRoU2VsZWN0b3IobGlzdGVuZXIsIHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9O1xuICBjb25zdCBkZXN0cm95ID0gKCkgPT4gbGlzdGVuZXJzLmNsZWFyKCk7XG4gIGNvbnN0IGFwaSA9IHsgc2V0U3RhdGUsIGdldFN0YXRlLCBzdWJzY3JpYmUsIGRlc3Ryb3kgfTtcbiAgc3RhdGUgPSBjcmVhdGVTdGF0ZShzZXRTdGF0ZSwgZ2V0U3RhdGUsIGFwaSk7XG4gIHJldHVybiBhcGk7XG59XG5cbmNvbnN0IGlzU1NSID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhd2luZG93Lm5hdmlnYXRvciB8fCAvU2VydmVyU2lkZVJlbmRlcmluZ3xeRGVub1xcLy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gaXNTU1IgPyB1c2VFZmZlY3QgOiB1c2VMYXlvdXRFZmZlY3Q7XG5mdW5jdGlvbiBjcmVhdGUoY3JlYXRlU3RhdGUpIHtcbiAgY29uc3QgYXBpID0gdHlwZW9mIGNyZWF0ZVN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyBjcmVhdGVTdG9yZShjcmVhdGVTdGF0ZSkgOiBjcmVhdGVTdGF0ZTtcbiAgY29uc3QgdXNlU3RvcmUgPSAoc2VsZWN0b3IgPSBhcGkuZ2V0U3RhdGUsIGVxdWFsaXR5Rm4gPSBPYmplY3QuaXMpID0+IHtcbiAgICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSB1c2VSZWR1Y2VyKChjKSA9PiBjICsgMSwgMCk7XG4gICAgY29uc3Qgc3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBzdGF0ZVJlZiA9IHVzZVJlZihzdGF0ZSk7XG4gICAgY29uc3Qgc2VsZWN0b3JSZWYgPSB1c2VSZWYoc2VsZWN0b3IpO1xuICAgIGNvbnN0IGVxdWFsaXR5Rm5SZWYgPSB1c2VSZWYoZXF1YWxpdHlGbik7XG4gICAgY29uc3QgZXJyb3JlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgY3VycmVudFNsaWNlUmVmID0gdXNlUmVmKCk7XG4gICAgaWYgKGN1cnJlbnRTbGljZVJlZi5jdXJyZW50ID09PSB2b2lkIDApIHtcbiAgICAgIGN1cnJlbnRTbGljZVJlZi5jdXJyZW50ID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgIH1cbiAgICBsZXQgbmV3U3RhdGVTbGljZTtcbiAgICBsZXQgaGFzTmV3U3RhdGVTbGljZSA9IGZhbHNlO1xuICAgIGlmIChzdGF0ZVJlZi5jdXJyZW50ICE9PSBzdGF0ZSB8fCBzZWxlY3RvclJlZi5jdXJyZW50ICE9PSBzZWxlY3RvciB8fCBlcXVhbGl0eUZuUmVmLmN1cnJlbnQgIT09IGVxdWFsaXR5Rm4gfHwgZXJyb3JlZFJlZi5jdXJyZW50KSB7XG4gICAgICBuZXdTdGF0ZVNsaWNlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgaGFzTmV3U3RhdGVTbGljZSA9ICFlcXVhbGl0eUZuKGN1cnJlbnRTbGljZVJlZi5jdXJyZW50LCBuZXdTdGF0ZVNsaWNlKTtcbiAgICB9XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoaGFzTmV3U3RhdGVTbGljZSkge1xuICAgICAgICBjdXJyZW50U2xpY2VSZWYuY3VycmVudCA9IG5ld1N0YXRlU2xpY2U7XG4gICAgICB9XG4gICAgICBzdGF0ZVJlZi5jdXJyZW50ID0gc3RhdGU7XG4gICAgICBzZWxlY3RvclJlZi5jdXJyZW50ID0gc2VsZWN0b3I7XG4gICAgICBlcXVhbGl0eUZuUmVmLmN1cnJlbnQgPSBlcXVhbGl0eUZuO1xuICAgICAgZXJyb3JlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSk7XG4gICAgY29uc3Qgc3RhdGVCZWZvcmVTdWJzY3JpcHRpb25SZWYgPSB1c2VSZWYoc3RhdGUpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbmV4dFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgbmV4dFN0YXRlU2xpY2UgPSBzZWxlY3RvclJlZi5jdXJyZW50KG5leHRTdGF0ZSk7XG4gICAgICAgICAgaWYgKCFlcXVhbGl0eUZuUmVmLmN1cnJlbnQoY3VycmVudFNsaWNlUmVmLmN1cnJlbnQsIG5leHRTdGF0ZVNsaWNlKSkge1xuICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudCA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgIGN1cnJlbnRTbGljZVJlZi5jdXJyZW50ID0gbmV4dFN0YXRlU2xpY2U7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBlcnJvcmVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IGFwaS5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgICAgaWYgKGFwaS5nZXRTdGF0ZSgpICE9PSBzdGF0ZUJlZm9yZVN1YnNjcmlwdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHNsaWNlVG9SZXR1cm4gPSBoYXNOZXdTdGF0ZVNsaWNlID8gbmV3U3RhdGVTbGljZSA6IGN1cnJlbnRTbGljZVJlZi5jdXJyZW50O1xuICAgIHVzZURlYnVnVmFsdWUoc2xpY2VUb1JldHVybik7XG4gICAgcmV0dXJuIHNsaWNlVG9SZXR1cm47XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlU3RvcmUsIGFwaSk7XG4gIHVzZVN0b3JlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbdXNlU3RvcmUsIGFwaV0gPSBjcmVhdGUoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjRcIik7XG4gICAgY29uc3QgaXRlbXMgPSBbdXNlU3RvcmUsIGFwaV07XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGRvbmUgPSBpdGVtcy5sZW5ndGggPD0gMDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW1zLnNoaWZ0KCksIGRvbmUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gdXNlU3RvcmU7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/zustand/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/zustand/esm/middleware.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/zustand/esm/middleware.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   combine: () => (/* binding */ combine),\n/* harmony export */   devtools: () => (/* binding */ devtools),\n/* harmony export */   persist: () => (/* binding */ persist),\n/* harmony export */   redux: () => (/* binding */ redux),\n/* harmony export */   subscribeWithSelector: () => (/* binding */ subscribeWithSelector)\n/* harmony export */ });\nvar __defProp$1 = Object.defineProperty;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nconst redux = (reducer, initial) => (set, get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return __spreadValues$1({ dispatch: (...a) => api.dispatch(...a) }, initial);\n};\n\nfunction devtools(fn, options) {\n  return (set, get, api) => {\n    var _a;\n    let didWarnAboutNameDeprecation = false;\n    if (typeof options === \"string\" && !didWarnAboutNameDeprecation) {\n      console.warn(\"[zustand devtools middleware]: passing `name` as directly will be not allowed in next majorpass the `name` in an object `{ name: ... }` instead\");\n      didWarnAboutNameDeprecation = true;\n    }\n    const devtoolsOptions = options === void 0 ? { name: void 0, anonymousActionType: void 0 } : typeof options === \"string\" ? { name: options } : options;\n    if (typeof ((_a = devtoolsOptions == null ? void 0 : devtoolsOptions.serialize) == null ? void 0 : _a.options) !== \"undefined\") {\n      console.warn(\"[zustand devtools middleware]: `serialize.options` is deprecated, just use `serialize`\");\n    }\n    let extensionConnector;\n    try {\n      extensionConnector = window.__REDUX_DEVTOOLS_EXTENSION__ || window.top.__REDUX_DEVTOOLS_EXTENSION__;\n    } catch {\n    }\n    if (!extensionConnector) {\n      if ( true && typeof window !== \"undefined\") {\n        console.warn(\"[zustand devtools middleware] Please install/enable Redux devtools extension\");\n      }\n      return fn(set, get, api);\n    }\n    let extension = Object.create(extensionConnector.connect(devtoolsOptions));\n    let didWarnAboutDevtools = false;\n    Object.defineProperty(api, \"devtools\", {\n      get: () => {\n        if (!didWarnAboutDevtools) {\n          console.warn(\"[zustand devtools middleware] `devtools` property on the store is deprecated it will be removed in the next major.\\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly\");\n          didWarnAboutDevtools = true;\n        }\n        return extension;\n      },\n      set: (value) => {\n        if (!didWarnAboutDevtools) {\n          console.warn(\"[zustand devtools middleware] `api.devtools` is deprecated, it will be removed in the next major.\\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly\");\n          didWarnAboutDevtools = true;\n        }\n        extension = value;\n      }\n    });\n    let didWarnAboutPrefix = false;\n    Object.defineProperty(extension, \"prefix\", {\n      get: () => {\n        if (!didWarnAboutPrefix) {\n          console.warn(\"[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\\nWe no longer prefix the actions/names\" + devtoolsOptions.name === void 0 ? \", pass the `name` option to create a separate instance of devtools for each store.\" : \", because the `name` option already creates a separate instance of devtools for each store.\");\n          didWarnAboutPrefix = true;\n        }\n        return \"\";\n      },\n      set: () => {\n        if (!didWarnAboutPrefix) {\n          console.warn(\"[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\\nWe no longer prefix the actions/names\" + devtoolsOptions.name === void 0 ? \", pass the `name` option to create a separate instance of devtools for each store.\" : \", because the `name` option already creates a separate instance of devtools for each store.\");\n          didWarnAboutPrefix = true;\n        }\n      }\n    });\n    let isRecording = true;\n    api.setState = (state, replace, nameOrAction) => {\n      set(state, replace);\n      if (!isRecording)\n        return;\n      extension.send(nameOrAction === void 0 ? { type: devtoolsOptions.anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction, get());\n    };\n    const setStateFromDevtools = (...a) => {\n      const originalIsRecording = isRecording;\n      isRecording = false;\n      set(...a);\n      isRecording = originalIsRecording;\n    };\n    const initialState = fn(api.setState, get, api);\n    extension.init(initialState);\n    if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n      let didWarnAboutReservedActionType = false;\n      const originalDispatch = api.dispatch;\n      api.dispatch = (...a) => {\n        if (a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n          console.warn('[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.');\n          didWarnAboutReservedActionType = true;\n        }\n        originalDispatch(...a);\n      };\n    }\n    extension.subscribe((message) => {\n      var _a2;\n      switch (message.type) {\n        case \"ACTION\":\n          if (typeof message.payload !== \"string\") {\n            console.error(\"[zustand devtools middleware] Unsupported action format\");\n            return;\n          }\n          return parseJsonThen(message.payload, (action) => {\n            if (action.type === \"__setState\") {\n              setStateFromDevtools(action.state);\n              return;\n            }\n            if (!api.dispatchFromDevtools)\n              return;\n            if (typeof api.dispatch !== \"function\")\n              return;\n            api.dispatch(action);\n          });\n        case \"DISPATCH\":\n          switch (message.payload.type) {\n            case \"RESET\":\n              setStateFromDevtools(initialState);\n              return extension.init(api.getState());\n            case \"COMMIT\":\n              return extension.init(api.getState());\n            case \"ROLLBACK\":\n              return parseJsonThen(message.state, (state) => {\n                setStateFromDevtools(state);\n                extension.init(api.getState());\n              });\n            case \"JUMP_TO_STATE\":\n            case \"JUMP_TO_ACTION\":\n              return parseJsonThen(message.state, (state) => {\n                setStateFromDevtools(state);\n              });\n            case \"IMPORT_STATE\": {\n              const { nextLiftedState } = message.payload;\n              const lastComputedState = (_a2 = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a2.state;\n              if (!lastComputedState)\n                return;\n              setStateFromDevtools(lastComputedState);\n              extension.send(null, nextLiftedState);\n              return;\n            }\n            case \"PAUSE_RECORDING\":\n              return isRecording = !isRecording;\n          }\n          return;\n      }\n    });\n    return initialState;\n  };\n}\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\"[zustand devtools middleware] Could not parse the received json\", e);\n  }\n  if (parsed !== void 0)\n    f(parsed);\n};\n\nconst subscribeWithSelector = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\n\nconst combine = (initialState, create) => (set, get, api) => Object.assign({}, initialState, create(set, get, api));\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst persist = (config, baseOptions) => (set, get, api) => {\n  let options = __spreadValues({\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => __spreadValues(__spreadValues({}, currentState), persistedState)\n  }, baseOptions);\n  if (options.blacklist || options.whitelist) {\n    console.warn(`The ${options.blacklist ? \"blacklist\" : \"whitelist\"} option is deprecated and will be removed in the next version. Please use the 'partialize' option instead.`);\n  }\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (e) {\n  }\n  if (!storage) {\n    return config((...args) => {\n      console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);\n      set(...args);\n    }, get, api);\n  } else if (!storage.removeItem) {\n    console.warn(`[zustand persist middleware] The given storage for item '${options.name}' does not contain a 'removeItem' method, which will be required in v4.`);\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize(__spreadValues({}, get()));\n    if (options.whitelist) {\n      Object.keys(state).forEach((key) => {\n        var _a;\n        !((_a = options.whitelist) == null ? void 0 : _a.includes(key)) && delete state[key];\n      });\n    }\n    if (options.blacklist) {\n      options.blacklist.forEach((key) => delete state[key]);\n    }\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then((serializedValue) => storage.setItem(options.name, serializedValue)).catch((e) => {\n      errorInSync = e;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config((...args) => {\n    set(...args);\n    void setItem();\n  }, get, api);\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(deserializedStorageValue.state, deserializedStorageValue.version);\n          }\n          console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(migratedState, (_a2 = get()) != null ? _a2 : configResult);\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = __spreadValues(__spreadValues({}, options), newOptions);\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      var _a;\n      (_a = storage == null ? void 0 : storage.removeItem) == null ? void 0 : _a.call(storage, options.name);\n    },\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL21pZGRsZXdhcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRiw2REFBNkQ7QUFDL0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdDQUF3QztBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0lBQStJLFdBQVc7QUFDMUo7QUFDQTtBQUNBLG1EQUFtRCw0Q0FBNEMsa0NBQWtDLGdCQUFnQjtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVUsS0FBMEQ7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyREFBMkQsdUNBQXVDLHFCQUFxQjtBQUN4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkVBQTZFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsK0NBQStDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSiw2RUFBNkUsYUFBYTtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQ0FBaUM7QUFDMUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvRSIsInNvdXJjZXMiOlsid2VicGFjazovL2phd2FyYS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vbWlkZGxld2FyZS5qcz82YzRiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0kMSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzJDEgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcCQxLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AkMShhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkMSlcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkMShiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bSQxLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcCQxKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgcmVkdXggPSAocmVkdWNlciwgaW5pdGlhbCkgPT4gKHNldCwgZ2V0LCBhcGkpID0+IHtcbiAgYXBpLmRpc3BhdGNoID0gKGFjdGlvbikgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+IHJlZHVjZXIoc3RhdGUsIGFjdGlvbiksIGZhbHNlLCBhY3Rpb24pO1xuICAgIHJldHVybiBhY3Rpb247XG4gIH07XG4gIGFwaS5kaXNwYXRjaEZyb21EZXZ0b29scyA9IHRydWU7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyQxKHsgZGlzcGF0Y2g6ICguLi5hKSA9PiBhcGkuZGlzcGF0Y2goLi4uYSkgfSwgaW5pdGlhbCk7XG59O1xuXG5mdW5jdGlvbiBkZXZ0b29scyhmbiwgb3B0aW9ucykge1xuICByZXR1cm4gKHNldCwgZ2V0LCBhcGkpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGRpZFdhcm5BYm91dE5hbWVEZXByZWNhdGlvbiA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiAmJiAhZGlkV2FybkFib3V0TmFtZURlcHJlY2F0aW9uKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbenVzdGFuZCBkZXZ0b29scyBtaWRkbGV3YXJlXTogcGFzc2luZyBgbmFtZWAgYXMgZGlyZWN0bHkgd2lsbCBiZSBub3QgYWxsb3dlZCBpbiBuZXh0IG1ham9ycGFzcyB0aGUgYG5hbWVgIGluIGFuIG9iamVjdCBgeyBuYW1lOiAuLi4gfWAgaW5zdGVhZFwiKTtcbiAgICAgIGRpZFdhcm5BYm91dE5hbWVEZXByZWNhdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGRldnRvb2xzT3B0aW9ucyA9IG9wdGlvbnMgPT09IHZvaWQgMCA/IHsgbmFtZTogdm9pZCAwLCBhbm9ueW1vdXNBY3Rpb25UeXBlOiB2b2lkIDAgfSA6IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID8geyBuYW1lOiBvcHRpb25zIH0gOiBvcHRpb25zO1xuICAgIGlmICh0eXBlb2YgKChfYSA9IGRldnRvb2xzT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogZGV2dG9vbHNPcHRpb25zLnNlcmlhbGl6ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm9wdGlvbnMpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbenVzdGFuZCBkZXZ0b29scyBtaWRkbGV3YXJlXTogYHNlcmlhbGl6ZS5vcHRpb25zYCBpcyBkZXByZWNhdGVkLCBqdXN0IHVzZSBgc2VyaWFsaXplYFwiKTtcbiAgICB9XG4gICAgbGV0IGV4dGVuc2lvbkNvbm5lY3RvcjtcbiAgICB0cnkge1xuICAgICAgZXh0ZW5zaW9uQ29ubmVjdG9yID0gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gfHwgd2luZG93LnRvcC5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICBpZiAoIWV4dGVuc2lvbkNvbm5lY3Rvcikge1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgJiYgaW1wb3J0Lm1ldGEuZW52Lk1PREUpICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlt6dXN0YW5kIGRldnRvb2xzIG1pZGRsZXdhcmVdIFBsZWFzZSBpbnN0YWxsL2VuYWJsZSBSZWR1eCBkZXZ0b29scyBleHRlbnNpb25cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm4oc2V0LCBnZXQsIGFwaSk7XG4gICAgfVxuICAgIGxldCBleHRlbnNpb24gPSBPYmplY3QuY3JlYXRlKGV4dGVuc2lvbkNvbm5lY3Rvci5jb25uZWN0KGRldnRvb2xzT3B0aW9ucykpO1xuICAgIGxldCBkaWRXYXJuQWJvdXREZXZ0b29scyA9IGZhbHNlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcGksIFwiZGV2dG9vbHNcIiwge1xuICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0RGV2dG9vbHMpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJbenVzdGFuZCBkZXZ0b29scyBtaWRkbGV3YXJlXSBgZGV2dG9vbHNgIHByb3BlcnR5IG9uIHRoZSBzdG9yZSBpcyBkZXByZWNhdGVkIGl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvci5cXG5Zb3Ugc2hvdWxkbid0IGludGVyYWN0IHdpdGggdGhlIGV4dGVuc2lvbiBkaXJlY3RseS4gQnV0IGluIGNhc2UgeW91IHN0aWxsIHdhbnQgdG8geW91IGNhbiBwYXRjaCBgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX19gIGRpcmVjdGx5XCIpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dERldnRvb2xzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0RGV2dG9vbHMpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJbenVzdGFuZCBkZXZ0b29scyBtaWRkbGV3YXJlXSBgYXBpLmRldnRvb2xzYCBpcyBkZXByZWNhdGVkLCBpdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IuXFxuWW91IHNob3VsZG4ndCBpbnRlcmFjdCB3aXRoIHRoZSBleHRlbnNpb24gZGlyZWN0bHkuIEJ1dCBpbiBjYXNlIHlvdSBzdGlsbCB3YW50IHRvIHlvdSBjYW4gcGF0Y2ggYHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fYCBkaXJlY3RseVwiKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXREZXZ0b29scyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5zaW9uID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGRpZFdhcm5BYm91dFByZWZpeCA9IGZhbHNlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHRlbnNpb24sIFwicHJlZml4XCIsIHtcbiAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFByZWZpeCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlt6dXN0YW5kIGRldnRvb2xzIG1pZGRsZXdhcmVdIGFsb25nIHdpdGggYGFwaS5kZXZ0b29sc2AsIGBhcGkuZGV2dG9vbHMucHJlZml4YCBpcyBkZXByZWNhdGVkLlxcbldlIG5vIGxvbmdlciBwcmVmaXggdGhlIGFjdGlvbnMvbmFtZXNcIiArIGRldnRvb2xzT3B0aW9ucy5uYW1lID09PSB2b2lkIDAgPyBcIiwgcGFzcyB0aGUgYG5hbWVgIG9wdGlvbiB0byBjcmVhdGUgYSBzZXBhcmF0ZSBpbnN0YW5jZSBvZiBkZXZ0b29scyBmb3IgZWFjaCBzdG9yZS5cIiA6IFwiLCBiZWNhdXNlIHRoZSBgbmFtZWAgb3B0aW9uIGFscmVhZHkgY3JlYXRlcyBhIHNlcGFyYXRlIGluc3RhbmNlIG9mIGRldnRvb2xzIGZvciBlYWNoIHN0b3JlLlwiKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRQcmVmaXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfSxcbiAgICAgIHNldDogKCkgPT4ge1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFByZWZpeCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlt6dXN0YW5kIGRldnRvb2xzIG1pZGRsZXdhcmVdIGFsb25nIHdpdGggYGFwaS5kZXZ0b29sc2AsIGBhcGkuZGV2dG9vbHMucHJlZml4YCBpcyBkZXByZWNhdGVkLlxcbldlIG5vIGxvbmdlciBwcmVmaXggdGhlIGFjdGlvbnMvbmFtZXNcIiArIGRldnRvb2xzT3B0aW9ucy5uYW1lID09PSB2b2lkIDAgPyBcIiwgcGFzcyB0aGUgYG5hbWVgIG9wdGlvbiB0byBjcmVhdGUgYSBzZXBhcmF0ZSBpbnN0YW5jZSBvZiBkZXZ0b29scyBmb3IgZWFjaCBzdG9yZS5cIiA6IFwiLCBiZWNhdXNlIHRoZSBgbmFtZWAgb3B0aW9uIGFscmVhZHkgY3JlYXRlcyBhIHNlcGFyYXRlIGluc3RhbmNlIG9mIGRldnRvb2xzIGZvciBlYWNoIHN0b3JlLlwiKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRQcmVmaXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGlzUmVjb3JkaW5nID0gdHJ1ZTtcbiAgICBhcGkuc2V0U3RhdGUgPSAoc3RhdGUsIHJlcGxhY2UsIG5hbWVPckFjdGlvbikgPT4ge1xuICAgICAgc2V0KHN0YXRlLCByZXBsYWNlKTtcbiAgICAgIGlmICghaXNSZWNvcmRpbmcpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGV4dGVuc2lvbi5zZW5kKG5hbWVPckFjdGlvbiA9PT0gdm9pZCAwID8geyB0eXBlOiBkZXZ0b29sc09wdGlvbnMuYW5vbnltb3VzQWN0aW9uVHlwZSB8fCBcImFub255bW91c1wiIH0gOiB0eXBlb2YgbmFtZU9yQWN0aW9uID09PSBcInN0cmluZ1wiID8geyB0eXBlOiBuYW1lT3JBY3Rpb24gfSA6IG5hbWVPckFjdGlvbiwgZ2V0KCkpO1xuICAgIH07XG4gICAgY29uc3Qgc2V0U3RhdGVGcm9tRGV2dG9vbHMgPSAoLi4uYSkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxJc1JlY29yZGluZyA9IGlzUmVjb3JkaW5nO1xuICAgICAgaXNSZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgIHNldCguLi5hKTtcbiAgICAgIGlzUmVjb3JkaW5nID0gb3JpZ2luYWxJc1JlY29yZGluZztcbiAgICB9O1xuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IGZuKGFwaS5zZXRTdGF0ZSwgZ2V0LCBhcGkpO1xuICAgIGV4dGVuc2lvbi5pbml0KGluaXRpYWxTdGF0ZSk7XG4gICAgaWYgKGFwaS5kaXNwYXRjaEZyb21EZXZ0b29scyAmJiB0eXBlb2YgYXBpLmRpc3BhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGxldCBkaWRXYXJuQWJvdXRSZXNlcnZlZEFjdGlvblR5cGUgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsRGlzcGF0Y2ggPSBhcGkuZGlzcGF0Y2g7XG4gICAgICBhcGkuZGlzcGF0Y2ggPSAoLi4uYSkgPT4ge1xuICAgICAgICBpZiAoYVswXS50eXBlID09PSBcIl9fc2V0U3RhdGVcIiAmJiAhZGlkV2FybkFib3V0UmVzZXJ2ZWRBY3Rpb25UeXBlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbenVzdGFuZCBkZXZ0b29scyBtaWRkbGV3YXJlXSBcIl9fc2V0U3RhdGVcIiBhY3Rpb24gdHlwZSBpcyByZXNlcnZlZCB0byBzZXQgc3RhdGUgZnJvbSB0aGUgZGV2dG9vbHMuIEF2b2lkIHVzaW5nIGl0LicpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFJlc2VydmVkQWN0aW9uVHlwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgb3JpZ2luYWxEaXNwYXRjaCguLi5hKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGV4dGVuc2lvbi5zdWJzY3JpYmUoKG1lc3NhZ2UpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICBjYXNlIFwiQUNUSU9OXCI6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnBheWxvYWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbenVzdGFuZCBkZXZ0b29scyBtaWRkbGV3YXJlXSBVbnN1cHBvcnRlZCBhY3Rpb24gZm9ybWF0XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGFyc2VKc29uVGhlbihtZXNzYWdlLnBheWxvYWQsIChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gXCJfX3NldFN0YXRlXCIpIHtcbiAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMoYWN0aW9uLnN0YXRlKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcGkuZGlzcGF0Y2hGcm9tRGV2dG9vbHMpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXBpLmRpc3BhdGNoICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGFwaS5kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIFwiRElTUEFUQ0hcIjpcbiAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UucGF5bG9hZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiUkVTRVRcIjpcbiAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbi5pbml0KGFwaS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgICAgIGNhc2UgXCJDT01NSVRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbi5pbml0KGFwaS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgICAgIGNhc2UgXCJST0xMQkFDS1wiOlxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VKc29uVGhlbihtZXNzYWdlLnN0YXRlLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhzdGF0ZSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uLmluaXQoYXBpLmdldFN0YXRlKCkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJKVU1QX1RPX1NUQVRFXCI6XG4gICAgICAgICAgICBjYXNlIFwiSlVNUF9UT19BQ1RJT05cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSnNvblRoZW4obWVzc2FnZS5zdGF0ZSwgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMoc3RhdGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJJTVBPUlRfU1RBVEVcIjoge1xuICAgICAgICAgICAgICBjb25zdCB7IG5leHRMaWZ0ZWRTdGF0ZSB9ID0gbWVzc2FnZS5wYXlsb2FkO1xuICAgICAgICAgICAgICBjb25zdCBsYXN0Q29tcHV0ZWRTdGF0ZSA9IChfYTIgPSBuZXh0TGlmdGVkU3RhdGUuY29tcHV0ZWRTdGF0ZXMuc2xpY2UoLTEpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnN0YXRlO1xuICAgICAgICAgICAgICBpZiAoIWxhc3RDb21wdXRlZFN0YXRlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMobGFzdENvbXB1dGVkU3RhdGUpO1xuICAgICAgICAgICAgICBleHRlbnNpb24uc2VuZChudWxsLCBuZXh0TGlmdGVkU3RhdGUpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiUEFVU0VfUkVDT1JESU5HXCI6XG4gICAgICAgICAgICAgIHJldHVybiBpc1JlY29yZGluZyA9ICFpc1JlY29yZGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpbml0aWFsU3RhdGU7XG4gIH07XG59XG5jb25zdCBwYXJzZUpzb25UaGVuID0gKHN0cmluZ2lmaWVkLCBmKSA9PiB7XG4gIGxldCBwYXJzZWQ7XG4gIHRyeSB7XG4gICAgcGFyc2VkID0gSlNPTi5wYXJzZShzdHJpbmdpZmllZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW3p1c3RhbmQgZGV2dG9vbHMgbWlkZGxld2FyZV0gQ291bGQgbm90IHBhcnNlIHRoZSByZWNlaXZlZCBqc29uXCIsIGUpO1xuICB9XG4gIGlmIChwYXJzZWQgIT09IHZvaWQgMClcbiAgICBmKHBhcnNlZCk7XG59O1xuXG5jb25zdCBzdWJzY3JpYmVXaXRoU2VsZWN0b3IgPSAoZm4pID0+IChzZXQsIGdldCwgYXBpKSA9PiB7XG4gIGNvbnN0IG9yaWdTdWJzY3JpYmUgPSBhcGkuc3Vic2NyaWJlO1xuICBhcGkuc3Vic2NyaWJlID0gKHNlbGVjdG9yLCBvcHRMaXN0ZW5lciwgb3B0aW9ucykgPT4ge1xuICAgIGxldCBsaXN0ZW5lciA9IHNlbGVjdG9yO1xuICAgIGlmIChvcHRMaXN0ZW5lcikge1xuICAgICAgY29uc3QgZXF1YWxpdHlGbiA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmVxdWFsaXR5Rm4pIHx8IE9iamVjdC5pcztcbiAgICAgIGxldCBjdXJyZW50U2xpY2UgPSBzZWxlY3RvcihhcGkuZ2V0U3RhdGUoKSk7XG4gICAgICBsaXN0ZW5lciA9IChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0U2xpY2UgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICAgIGlmICghZXF1YWxpdHlGbihjdXJyZW50U2xpY2UsIG5leHRTbGljZSkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c1NsaWNlID0gY3VycmVudFNsaWNlO1xuICAgICAgICAgIG9wdExpc3RlbmVyKGN1cnJlbnRTbGljZSA9IG5leHRTbGljZSwgcHJldmlvdXNTbGljZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5maXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgb3B0TGlzdGVuZXIoY3VycmVudFNsaWNlLCBjdXJyZW50U2xpY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3JpZ1N1YnNjcmliZShsaXN0ZW5lcik7XG4gIH07XG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IGZuKHNldCwgZ2V0LCBhcGkpO1xuICByZXR1cm4gaW5pdGlhbFN0YXRlO1xufTtcblxuY29uc3QgY29tYmluZSA9IChpbml0aWFsU3RhdGUsIGNyZWF0ZSkgPT4gKHNldCwgZ2V0LCBhcGkpID0+IE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSwgY3JlYXRlKHNldCwgZ2V0LCBhcGkpKTtcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgdG9UaGVuYWJsZSA9IChmbikgPT4gKGlucHV0KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZm4oaW5wdXQpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdGhlbihvbkZ1bGZpbGxlZCkge1xuICAgICAgICByZXR1cm4gdG9UaGVuYWJsZShvbkZ1bGZpbGxlZCkocmVzdWx0KTtcbiAgICAgIH0sXG4gICAgICBjYXRjaChfb25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRoZW4oX29uRnVsZmlsbGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRvVGhlbmFibGUob25SZWplY3RlZCkoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IHBlcnNpc3QgPSAoY29uZmlnLCBiYXNlT3B0aW9ucykgPT4gKHNldCwgZ2V0LCBhcGkpID0+IHtcbiAgbGV0IG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgZ2V0U3RvcmFnZTogKCkgPT4gbG9jYWxTdG9yYWdlLFxuICAgIHNlcmlhbGl6ZTogSlNPTi5zdHJpbmdpZnksXG4gICAgZGVzZXJpYWxpemU6IEpTT04ucGFyc2UsXG4gICAgcGFydGlhbGl6ZTogKHN0YXRlKSA9PiBzdGF0ZSxcbiAgICB2ZXJzaW9uOiAwLFxuICAgIG1lcmdlOiAocGVyc2lzdGVkU3RhdGUsIGN1cnJlbnRTdGF0ZSkgPT4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGN1cnJlbnRTdGF0ZSksIHBlcnNpc3RlZFN0YXRlKVxuICB9LCBiYXNlT3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmJsYWNrbGlzdCB8fCBvcHRpb25zLndoaXRlbGlzdCkge1xuICAgIGNvbnNvbGUud2FybihgVGhlICR7b3B0aW9ucy5ibGFja2xpc3QgPyBcImJsYWNrbGlzdFwiIDogXCJ3aGl0ZWxpc3RcIn0gb3B0aW9uIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCB2ZXJzaW9uLiBQbGVhc2UgdXNlIHRoZSAncGFydGlhbGl6ZScgb3B0aW9uIGluc3RlYWQuYCk7XG4gIH1cbiAgbGV0IGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gIGNvbnN0IGh5ZHJhdGlvbkxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBzdG9yYWdlO1xuICB0cnkge1xuICAgIHN0b3JhZ2UgPSBvcHRpb25zLmdldFN0b3JhZ2UoKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIGlmICghc3RvcmFnZSkge1xuICAgIHJldHVybiBjb25maWcoKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihgW3p1c3RhbmQgcGVyc2lzdCBtaWRkbGV3YXJlXSBVbmFibGUgdG8gdXBkYXRlIGl0ZW0gJyR7b3B0aW9ucy5uYW1lfScsIHRoZSBnaXZlbiBzdG9yYWdlIGlzIGN1cnJlbnRseSB1bmF2YWlsYWJsZS5gKTtcbiAgICAgIHNldCguLi5hcmdzKTtcbiAgICB9LCBnZXQsIGFwaSk7XG4gIH0gZWxzZSBpZiAoIXN0b3JhZ2UucmVtb3ZlSXRlbSkge1xuICAgIGNvbnNvbGUud2FybihgW3p1c3RhbmQgcGVyc2lzdCBtaWRkbGV3YXJlXSBUaGUgZ2l2ZW4gc3RvcmFnZSBmb3IgaXRlbSAnJHtvcHRpb25zLm5hbWV9JyBkb2VzIG5vdCBjb250YWluIGEgJ3JlbW92ZUl0ZW0nIG1ldGhvZCwgd2hpY2ggd2lsbCBiZSByZXF1aXJlZCBpbiB2NC5gKTtcbiAgfVxuICBjb25zdCB0aGVuYWJsZVNlcmlhbGl6ZSA9IHRvVGhlbmFibGUob3B0aW9ucy5zZXJpYWxpemUpO1xuICBjb25zdCBzZXRJdGVtID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gb3B0aW9ucy5wYXJ0aWFsaXplKF9fc3ByZWFkVmFsdWVzKHt9LCBnZXQoKSkpO1xuICAgIGlmIChvcHRpb25zLndoaXRlbGlzdCkge1xuICAgICAgT2JqZWN0LmtleXMoc3RhdGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgICEoKF9hID0gb3B0aW9ucy53aGl0ZWxpc3QpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhrZXkpKSAmJiBkZWxldGUgc3RhdGVba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ibGFja2xpc3QpIHtcbiAgICAgIG9wdGlvbnMuYmxhY2tsaXN0LmZvckVhY2goKGtleSkgPT4gZGVsZXRlIHN0YXRlW2tleV0pO1xuICAgIH1cbiAgICBsZXQgZXJyb3JJblN5bmM7XG4gICAgY29uc3QgdGhlbmFibGUgPSB0aGVuYWJsZVNlcmlhbGl6ZSh7IHN0YXRlLCB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24gfSkudGhlbigoc2VyaWFsaXplZFZhbHVlKSA9PiBzdG9yYWdlLnNldEl0ZW0ob3B0aW9ucy5uYW1lLCBzZXJpYWxpemVkVmFsdWUpKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgZXJyb3JJblN5bmMgPSBlO1xuICAgIH0pO1xuICAgIGlmIChlcnJvckluU3luYykge1xuICAgICAgdGhyb3cgZXJyb3JJblN5bmM7XG4gICAgfVxuICAgIHJldHVybiB0aGVuYWJsZTtcbiAgfTtcbiAgY29uc3Qgc2F2ZWRTZXRTdGF0ZSA9IGFwaS5zZXRTdGF0ZTtcbiAgYXBpLnNldFN0YXRlID0gKHN0YXRlLCByZXBsYWNlKSA9PiB7XG4gICAgc2F2ZWRTZXRTdGF0ZShzdGF0ZSwgcmVwbGFjZSk7XG4gICAgdm9pZCBzZXRJdGVtKCk7XG4gIH07XG4gIGNvbnN0IGNvbmZpZ1Jlc3VsdCA9IGNvbmZpZygoLi4uYXJncykgPT4ge1xuICAgIHNldCguLi5hcmdzKTtcbiAgICB2b2lkIHNldEl0ZW0oKTtcbiAgfSwgZ2V0LCBhcGkpO1xuICBsZXQgc3RhdGVGcm9tU3RvcmFnZTtcbiAgY29uc3QgaHlkcmF0ZSA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFzdG9yYWdlKVxuICAgICAgcmV0dXJuO1xuICAgIGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gICAgaHlkcmF0aW9uTGlzdGVuZXJzLmZvckVhY2goKGNiKSA9PiBjYihnZXQoKSkpO1xuICAgIGNvbnN0IHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrID0gKChfYSA9IG9wdGlvbnMub25SZWh5ZHJhdGVTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBnZXQoKSkpIHx8IHZvaWQgMDtcbiAgICByZXR1cm4gdG9UaGVuYWJsZShzdG9yYWdlLmdldEl0ZW0uYmluZChzdG9yYWdlKSkob3B0aW9ucy5uYW1lKS50aGVuKChzdG9yYWdlVmFsdWUpID0+IHtcbiAgICAgIGlmIChzdG9yYWdlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGVzZXJpYWxpemUoc3RvcmFnZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9KS50aGVuKChkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUpID0+IHtcbiAgICAgIGlmIChkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvbiA9PT0gXCJudW1iZXJcIiAmJiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvbiAhPT0gb3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubWlncmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubWlncmF0ZShkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUuc3RhdGUsIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS52ZXJzaW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgU3RhdGUgbG9hZGVkIGZyb20gc3RvcmFnZSBjb3VsZG4ndCBiZSBtaWdyYXRlZCBzaW5jZSBubyBtaWdyYXRlIGZ1bmN0aW9uIHdhcyBwcm92aWRlZGApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS50aGVuKChtaWdyYXRlZFN0YXRlKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgc3RhdGVGcm9tU3RvcmFnZSA9IG9wdGlvbnMubWVyZ2UobWlncmF0ZWRTdGF0ZSwgKF9hMiA9IGdldCgpKSAhPSBudWxsID8gX2EyIDogY29uZmlnUmVzdWx0KTtcbiAgICAgIHNldChzdGF0ZUZyb21TdG9yYWdlLCB0cnVlKTtcbiAgICAgIHJldHVybiBzZXRJdGVtKCk7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2soc3RhdGVGcm9tU3RvcmFnZSwgdm9pZCAwKTtcbiAgICAgIGhhc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgICAgIGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycy5mb3JFYWNoKChjYikgPT4gY2Ioc3RhdGVGcm9tU3RvcmFnZSkpO1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2sodm9pZCAwLCBlKTtcbiAgICB9KTtcbiAgfTtcbiAgYXBpLnBlcnNpc3QgPSB7XG4gICAgc2V0T3B0aW9uczogKG5ld09wdGlvbnMpID0+IHtcbiAgICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIG5ld09wdGlvbnMpO1xuICAgICAgaWYgKG5ld09wdGlvbnMuZ2V0U3RvcmFnZSkge1xuICAgICAgICBzdG9yYWdlID0gbmV3T3B0aW9ucy5nZXRTdG9yYWdlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhclN0b3JhZ2U6ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHN0b3JhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3JhZ2UucmVtb3ZlSXRlbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoc3RvcmFnZSwgb3B0aW9ucy5uYW1lKTtcbiAgICB9LFxuICAgIHJlaHlkcmF0ZTogKCkgPT4gaHlkcmF0ZSgpLFxuICAgIGhhc0h5ZHJhdGVkOiAoKSA9PiBoYXNIeWRyYXRlZCxcbiAgICBvbkh5ZHJhdGU6IChjYikgPT4ge1xuICAgICAgaHlkcmF0aW9uTGlzdGVuZXJzLmFkZChjYik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBoeWRyYXRpb25MaXN0ZW5lcnMuZGVsZXRlKGNiKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBvbkZpbmlzaEh5ZHJhdGlvbjogKGNiKSA9PiB7XG4gICAgICBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMuYWRkKGNiKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycy5kZWxldGUoY2IpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIGh5ZHJhdGUoKTtcbiAgcmV0dXJuIHN0YXRlRnJvbVN0b3JhZ2UgfHwgY29uZmlnUmVzdWx0O1xufTtcblxuZXhwb3J0IHsgY29tYmluZSwgZGV2dG9vbHMsIHBlcnNpc3QsIHJlZHV4LCBzdWJzY3JpYmVXaXRoU2VsZWN0b3IgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/zustand/esm/middleware.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/web/Html.js":
/*!****************************************************!*\
  !*** ./node_modules/@react-three/drei/web/Html.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html: () => (/* binding */ Html)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom/client */ \"(ssr)/./node_modules/next/dist/compiled/react-dom/client.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-99983b2d.esm.js\");\n\n\n\n\n\n\nconst v1 = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst v2 = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst v3 = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst v4 = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Vector2();\nfunction defaultCalculatePosition(el, camera, size) {\n  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n  objectPos.project(camera);\n  const widthHalf = size.width / 2;\n  const heightHalf = size.height / 2;\n  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];\n}\nfunction isObjectBehindCamera(el, camera) {\n  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n  const deltaCamObj = objectPos.sub(cameraPos);\n  const camDir = camera.getWorldDirection(v3);\n  return deltaCamObj.angleTo(camDir) > Math.PI / 2;\n}\nfunction isObjectVisible(el, camera, raycaster, occlude) {\n  const elPos = v1.setFromMatrixPosition(el.matrixWorld);\n  const screenPos = elPos.clone();\n  screenPos.project(camera);\n  v4.set(screenPos.x, screenPos.y);\n  raycaster.setFromCamera(v4, camera);\n  const intersects = raycaster.intersectObjects(occlude, true);\n  if (intersects.length) {\n    const intersectionDistance = intersects[0].distance;\n    const pointDistance = elPos.distanceTo(raycaster.ray.origin);\n    return pointDistance < intersectionDistance;\n  }\n  return true;\n}\nfunction objectScale(el, camera) {\n  if (camera instanceof three__WEBPACK_IMPORTED_MODULE_3__.OrthographicCamera) {\n    return camera.zoom;\n  } else if (camera instanceof three__WEBPACK_IMPORTED_MODULE_3__.PerspectiveCamera) {\n    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n    const vFOV = camera.fov * Math.PI / 180;\n    const dist = objectPos.distanceTo(cameraPos);\n    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;\n    return 1 / scaleFOV;\n  } else {\n    return 1;\n  }\n}\nfunction objectZIndex(el, camera, zIndexRange) {\n  if (camera instanceof three__WEBPACK_IMPORTED_MODULE_3__.PerspectiveCamera || camera instanceof three__WEBPACK_IMPORTED_MODULE_3__.OrthographicCamera) {\n    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n    const dist = objectPos.distanceTo(cameraPos);\n    const A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);\n    const B = zIndexRange[1] - A * camera.far;\n    return Math.round(A * dist + B);\n  }\n  return undefined;\n}\nconst epsilon = value => Math.abs(value) < 1e-10 ? 0 : value;\nfunction getCSSMatrix(matrix, multipliers, prepend = '') {\n  let matrix3d = 'matrix3d(';\n  for (let i = 0; i !== 16; i++) {\n    matrix3d += epsilon(multipliers[i] * matrix.elements[i]) + (i !== 15 ? ',' : ')');\n  }\n  return prepend + matrix3d;\n}\nconst getCameraCSSMatrix = (multipliers => {\n  return matrix => getCSSMatrix(matrix, multipliers);\n})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);\nconst getObjectCSSMatrix = (scaleMultipliers => {\n  return (matrix, factor) => getCSSMatrix(matrix, scaleMultipliers(factor), 'translate(-50%,-50%)');\n})(f => [1 / f, 1 / f, 1 / f, 1, -1 / f, -1 / f, -1 / f, -1, 1 / f, 1 / f, 1 / f, 1, 1, 1, 1, 1]);\nfunction isRefObject(ref) {\n  return ref && typeof ref === 'object' && 'current' in ref;\n}\nconst Html = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  children,\n  eps = 0.001,\n  style,\n  className,\n  prepend,\n  center,\n  fullscreen,\n  portal,\n  distanceFactor,\n  sprite = false,\n  transform = false,\n  occlude,\n  onOcclude,\n  castShadow,\n  receiveShadow,\n  material,\n  geometry,\n  zIndexRange = [16777271, 0],\n  calculatePosition = defaultCalculatePosition,\n  as = 'div',\n  wrapperClass,\n  pointerEvents = 'auto',\n  ...props\n}, ref) => {\n  const {\n    gl,\n    camera,\n    scene,\n    size,\n    raycaster,\n    events,\n    viewport\n  } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.A)();\n  const [el] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => document.createElement(as));\n  const root = react__WEBPACK_IMPORTED_MODULE_1__.useRef();\n  const group = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const oldZoom = react__WEBPACK_IMPORTED_MODULE_1__.useRef(0);\n  const oldPosition = react__WEBPACK_IMPORTED_MODULE_1__.useRef([0, 0]);\n  const transformOuterRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const transformInnerRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  // Append to the connected element, which makes HTML work with views\n  const target = (portal == null ? void 0 : portal.current) || events.connected || gl.domElement.parentNode;\n  const occlusionMeshRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const isMeshSizeSet = react__WEBPACK_IMPORTED_MODULE_1__.useRef(false);\n  const isRayCastOcclusion = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    return occlude && occlude !== 'blending' || Array.isArray(occlude) && occlude.length && isRefObject(occlude[0]);\n  }, [occlude]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    const el = gl.domElement;\n    if (occlude && occlude === 'blending') {\n      el.style.zIndex = `${Math.floor(zIndexRange[0] / 2)}`;\n      el.style.position = 'absolute';\n      el.style.pointerEvents = 'none';\n    } else {\n      el.style.zIndex = null;\n      el.style.position = null;\n      el.style.pointerEvents = null;\n    }\n  }, [occlude]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (group.current) {\n      const currentRoot = root.current = react_dom_client__WEBPACK_IMPORTED_MODULE_2__.createRoot(el);\n      scene.updateMatrixWorld();\n      if (transform) {\n        el.style.cssText = `position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;`;\n      } else {\n        const vec = calculatePosition(group.current, camera, size);\n        el.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${vec[0]}px,${vec[1]}px,0);transform-origin:0 0;`;\n      }\n      if (target) {\n        if (prepend) target.prepend(el);else target.appendChild(el);\n      }\n      return () => {\n        if (target) target.removeChild(el);\n        currentRoot.unmount();\n      };\n    }\n  }, [target, transform]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (wrapperClass) el.className = wrapperClass;\n  }, [wrapperClass]);\n  const styles = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    if (transform) {\n      return {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: size.width,\n        height: size.height,\n        transformStyle: 'preserve-3d',\n        pointerEvents: 'none'\n      };\n    } else {\n      return {\n        position: 'absolute',\n        transform: center ? 'translate3d(-50%,-50%,0)' : 'none',\n        ...(fullscreen && {\n          top: -size.height / 2,\n          left: -size.width / 2,\n          width: size.width,\n          height: size.height\n        }),\n        ...style\n      };\n    }\n  }, [style, center, fullscreen, size, transform]);\n  const transformInnerStyles = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ({\n    position: 'absolute',\n    pointerEvents\n  }), [pointerEvents]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    isMeshSizeSet.current = false;\n    if (transform) {\n      var _root$current;\n      (_root$current = root.current) == null || _root$current.render( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n        ref: transformOuterRef,\n        style: styles\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n        ref: transformInnerRef,\n        style: transformInnerStyles\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n        ref: ref,\n        className: className,\n        style: style,\n        children: children\n      }))));\n    } else {\n      var _root$current2;\n      (_root$current2 = root.current) == null || _root$current2.render( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n        ref: ref,\n        style: styles,\n        className: className,\n        children: children\n      }));\n    }\n  });\n  const visible = react__WEBPACK_IMPORTED_MODULE_1__.useRef(true);\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C)(gl => {\n    if (group.current) {\n      camera.updateMatrixWorld();\n      group.current.updateWorldMatrix(true, false);\n      const vec = transform ? oldPosition.current : calculatePosition(group.current, camera, size);\n      if (transform || Math.abs(oldZoom.current - camera.zoom) > eps || Math.abs(oldPosition.current[0] - vec[0]) > eps || Math.abs(oldPosition.current[1] - vec[1]) > eps) {\n        const isBehindCamera = isObjectBehindCamera(group.current, camera);\n        let raytraceTarget = false;\n        if (isRayCastOcclusion) {\n          if (Array.isArray(occlude)) {\n            raytraceTarget = occlude.map(item => item.current);\n          } else if (occlude !== 'blending') {\n            raytraceTarget = [scene];\n          }\n        }\n        const previouslyVisible = visible.current;\n        if (raytraceTarget) {\n          const isvisible = isObjectVisible(group.current, camera, raycaster, raytraceTarget);\n          visible.current = isvisible && !isBehindCamera;\n        } else {\n          visible.current = !isBehindCamera;\n        }\n        if (previouslyVisible !== visible.current) {\n          if (onOcclude) onOcclude(!visible.current);else el.style.display = visible.current ? 'block' : 'none';\n        }\n        const halfRange = Math.floor(zIndexRange[0] / 2);\n        const zRange = occlude ? isRayCastOcclusion //\n        ? [zIndexRange[0], halfRange] : [halfRange - 1, 0] : zIndexRange;\n        el.style.zIndex = `${objectZIndex(group.current, camera, zRange)}`;\n        if (transform) {\n          const [widthHalf, heightHalf] = [size.width / 2, size.height / 2];\n          const fov = camera.projectionMatrix.elements[5] * heightHalf;\n          const {\n            isOrthographicCamera,\n            top,\n            left,\n            bottom,\n            right\n          } = camera;\n          const cameraMatrix = getCameraCSSMatrix(camera.matrixWorldInverse);\n          const cameraTransform = isOrthographicCamera ? `scale(${fov})translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${fov}px)`;\n          let matrix = group.current.matrixWorld;\n          if (sprite) {\n            matrix = camera.matrixWorldInverse.clone().transpose().copyPosition(matrix).scale(group.current.scale);\n            matrix.elements[3] = matrix.elements[7] = matrix.elements[11] = 0;\n            matrix.elements[15] = 1;\n          }\n          el.style.width = size.width + 'px';\n          el.style.height = size.height + 'px';\n          el.style.perspective = isOrthographicCamera ? '' : `${fov}px`;\n          if (transformOuterRef.current && transformInnerRef.current) {\n            transformOuterRef.current.style.transform = `${cameraTransform}${cameraMatrix}translate(${widthHalf}px,${heightHalf}px)`;\n            transformInnerRef.current.style.transform = getObjectCSSMatrix(matrix, 1 / ((distanceFactor || 10) / 400));\n          }\n        } else {\n          const scale = distanceFactor === undefined ? 1 : objectScale(group.current, camera) * distanceFactor;\n          el.style.transform = `translate3d(${vec[0]}px,${vec[1]}px,0) scale(${scale})`;\n        }\n        oldPosition.current = vec;\n        oldZoom.current = camera.zoom;\n      }\n    }\n    if (!isRayCastOcclusion && occlusionMeshRef.current && !isMeshSizeSet.current) {\n      if (transform) {\n        if (transformOuterRef.current) {\n          const el = transformOuterRef.current.children[0];\n          if (el != null && el.clientWidth && el != null && el.clientHeight) {\n            const {\n              isOrthographicCamera\n            } = camera;\n            if (isOrthographicCamera || geometry) {\n              if (props.scale) {\n                if (!Array.isArray(props.scale)) {\n                  occlusionMeshRef.current.scale.setScalar(1 / props.scale);\n                } else if (props.scale instanceof three__WEBPACK_IMPORTED_MODULE_3__.Vector3) {\n                  occlusionMeshRef.current.scale.copy(props.scale.clone().divideScalar(1));\n                } else {\n                  occlusionMeshRef.current.scale.set(1 / props.scale[0], 1 / props.scale[1], 1 / props.scale[2]);\n                }\n              }\n            } else {\n              const ratio = (distanceFactor || 10) / 400;\n              const w = el.clientWidth * ratio;\n              const h = el.clientHeight * ratio;\n              occlusionMeshRef.current.scale.set(w, h, 1);\n            }\n            isMeshSizeSet.current = true;\n          }\n        }\n      } else {\n        const ele = el.children[0];\n        if (ele != null && ele.clientWidth && ele != null && ele.clientHeight) {\n          const ratio = 1 / viewport.factor;\n          const w = ele.clientWidth * ratio;\n          const h = ele.clientHeight * ratio;\n          occlusionMeshRef.current.scale.set(w, h, 1);\n          isMeshSizeSet.current = true;\n        }\n        occlusionMeshRef.current.lookAt(gl.camera.position);\n      }\n    }\n  });\n  const shaders = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ({\n    vertexShader: !transform ? /* glsl */`\n          /*\n            This shader is from the THREE's SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if \"transfrom\"\n            is false.\n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n\n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ` : undefined,\n    fragmentShader: /* glsl */`\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `\n  }), [transform]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n    ref: group\n  }), occlude && !isRayCastOcclusion && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", {\n    castShadow: castShadow,\n    receiveShadow: receiveShadow,\n    ref: occlusionMeshRef\n  }, geometry || /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"planeGeometry\", null), material || /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"shaderMaterial\", {\n    side: three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide,\n    vertexShader: shaders.vertexShader,\n    fragmentShader: shaders.fragmentShader\n  })));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvd2ViL0h0bWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUNjO0FBQytDO0FBQ3BDOztBQUV4RCw4QkFBOEIsMENBQU87QUFDckMsOEJBQThCLDBDQUFPO0FBQ3JDLDhCQUE4QiwwQ0FBTztBQUNyQyw4QkFBOEIsMENBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBa0I7QUFDMUM7QUFDQSxJQUFJLDJCQUEyQixvREFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9EQUFpQixzQkFBc0IscURBQWtCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2Q0FBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxFQUFFLHFEQUFRO0FBQ2QsZUFBZSwyQ0FBYztBQUM3QixlQUFlLHlDQUFZO0FBQzNCLGdCQUFnQix5Q0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsZ0RBQW1CLFVBQVUsOEVBQVEsR0FBRztBQUM5RDtBQUNBLEdBQUcsa0RBQWtELGdEQUFtQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDJCQUEyQixnREFBbUIsa0RBQWtELGdEQUFtQjtBQUN0SCxVQUFVLDZDQUFVO0FBQ3BCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFZSIsInNvdXJjZXMiOlsid2VicGFjazovL2phd2FyYS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS93ZWIvSHRtbC5qcz85YzllIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbS9jbGllbnQnO1xuaW1wb3J0IHsgVmVjdG9yMywgRG91YmxlU2lkZSwgT3J0aG9ncmFwaGljQ2FtZXJhLCBQZXJzcGVjdGl2ZUNhbWVyYSwgVmVjdG9yMiB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHVzZVRocmVlLCB1c2VGcmFtZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5cbmNvbnN0IHYxID0gLyogQF9fUFVSRV9fICovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHYyID0gLyogQF9fUFVSRV9fICovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHYzID0gLyogQF9fUFVSRV9fICovbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHY0ID0gLyogQF9fUFVSRV9fICovbmV3IFZlY3RvcjIoKTtcbmZ1bmN0aW9uIGRlZmF1bHRDYWxjdWxhdGVQb3NpdGlvbihlbCwgY2FtZXJhLCBzaXplKSB7XG4gIGNvbnN0IG9iamVjdFBvcyA9IHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbihlbC5tYXRyaXhXb3JsZCk7XG4gIG9iamVjdFBvcy5wcm9qZWN0KGNhbWVyYSk7XG4gIGNvbnN0IHdpZHRoSGFsZiA9IHNpemUud2lkdGggLyAyO1xuICBjb25zdCBoZWlnaHRIYWxmID0gc2l6ZS5oZWlnaHQgLyAyO1xuICByZXR1cm4gW29iamVjdFBvcy54ICogd2lkdGhIYWxmICsgd2lkdGhIYWxmLCAtKG9iamVjdFBvcy55ICogaGVpZ2h0SGFsZikgKyBoZWlnaHRIYWxmXTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0QmVoaW5kQ2FtZXJhKGVsLCBjYW1lcmEpIHtcbiAgY29uc3Qgb2JqZWN0UG9zID0gdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGVsLm1hdHJpeFdvcmxkKTtcbiAgY29uc3QgY2FtZXJhUG9zID0gdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGNhbWVyYS5tYXRyaXhXb3JsZCk7XG4gIGNvbnN0IGRlbHRhQ2FtT2JqID0gb2JqZWN0UG9zLnN1YihjYW1lcmFQb3MpO1xuICBjb25zdCBjYW1EaXIgPSBjYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24odjMpO1xuICByZXR1cm4gZGVsdGFDYW1PYmouYW5nbGVUbyhjYW1EaXIpID4gTWF0aC5QSSAvIDI7XG59XG5mdW5jdGlvbiBpc09iamVjdFZpc2libGUoZWwsIGNhbWVyYSwgcmF5Y2FzdGVyLCBvY2NsdWRlKSB7XG4gIGNvbnN0IGVsUG9zID0gdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGVsLm1hdHJpeFdvcmxkKTtcbiAgY29uc3Qgc2NyZWVuUG9zID0gZWxQb3MuY2xvbmUoKTtcbiAgc2NyZWVuUG9zLnByb2plY3QoY2FtZXJhKTtcbiAgdjQuc2V0KHNjcmVlblBvcy54LCBzY3JlZW5Qb3MueSk7XG4gIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHY0LCBjYW1lcmEpO1xuICBjb25zdCBpbnRlcnNlY3RzID0gcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHMob2NjbHVkZSwgdHJ1ZSk7XG4gIGlmIChpbnRlcnNlY3RzLmxlbmd0aCkge1xuICAgIGNvbnN0IGludGVyc2VjdGlvbkRpc3RhbmNlID0gaW50ZXJzZWN0c1swXS5kaXN0YW5jZTtcbiAgICBjb25zdCBwb2ludERpc3RhbmNlID0gZWxQb3MuZGlzdGFuY2VUbyhyYXljYXN0ZXIucmF5Lm9yaWdpbik7XG4gICAgcmV0dXJuIHBvaW50RGlzdGFuY2UgPCBpbnRlcnNlY3Rpb25EaXN0YW5jZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9iamVjdFNjYWxlKGVsLCBjYW1lcmEpIHtcbiAgaWYgKGNhbWVyYSBpbnN0YW5jZW9mIE9ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgIHJldHVybiBjYW1lcmEuem9vbTtcbiAgfSBlbHNlIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgIGNvbnN0IG9iamVjdFBvcyA9IHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbihlbC5tYXRyaXhXb3JsZCk7XG4gICAgY29uc3QgY2FtZXJhUG9zID0gdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGNhbWVyYS5tYXRyaXhXb3JsZCk7XG4gICAgY29uc3QgdkZPViA9IGNhbWVyYS5mb3YgKiBNYXRoLlBJIC8gMTgwO1xuICAgIGNvbnN0IGRpc3QgPSBvYmplY3RQb3MuZGlzdGFuY2VUbyhjYW1lcmFQb3MpO1xuICAgIGNvbnN0IHNjYWxlRk9WID0gMiAqIE1hdGgudGFuKHZGT1YgLyAyKSAqIGRpc3Q7XG4gICAgcmV0dXJuIDEgLyBzY2FsZUZPVjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuZnVuY3Rpb24gb2JqZWN0WkluZGV4KGVsLCBjYW1lcmEsIHpJbmRleFJhbmdlKSB7XG4gIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSB8fCBjYW1lcmEgaW5zdGFuY2VvZiBPcnRob2dyYXBoaWNDYW1lcmEpIHtcbiAgICBjb25zdCBvYmplY3RQb3MgPSB2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oZWwubWF0cml4V29ybGQpO1xuICAgIGNvbnN0IGNhbWVyYVBvcyA9IHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbihjYW1lcmEubWF0cml4V29ybGQpO1xuICAgIGNvbnN0IGRpc3QgPSBvYmplY3RQb3MuZGlzdGFuY2VUbyhjYW1lcmFQb3MpO1xuICAgIGNvbnN0IEEgPSAoekluZGV4UmFuZ2VbMV0gLSB6SW5kZXhSYW5nZVswXSkgLyAoY2FtZXJhLmZhciAtIGNhbWVyYS5uZWFyKTtcbiAgICBjb25zdCBCID0gekluZGV4UmFuZ2VbMV0gLSBBICogY2FtZXJhLmZhcjtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChBICogZGlzdCArIEIpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5jb25zdCBlcHNpbG9uID0gdmFsdWUgPT4gTWF0aC5hYnModmFsdWUpIDwgMWUtMTAgPyAwIDogdmFsdWU7XG5mdW5jdGlvbiBnZXRDU1NNYXRyaXgobWF0cml4LCBtdWx0aXBsaWVycywgcHJlcGVuZCA9ICcnKSB7XG4gIGxldCBtYXRyaXgzZCA9ICdtYXRyaXgzZCgnO1xuICBmb3IgKGxldCBpID0gMDsgaSAhPT0gMTY7IGkrKykge1xuICAgIG1hdHJpeDNkICs9IGVwc2lsb24obXVsdGlwbGllcnNbaV0gKiBtYXRyaXguZWxlbWVudHNbaV0pICsgKGkgIT09IDE1ID8gJywnIDogJyknKTtcbiAgfVxuICByZXR1cm4gcHJlcGVuZCArIG1hdHJpeDNkO1xufVxuY29uc3QgZ2V0Q2FtZXJhQ1NTTWF0cml4ID0gKG11bHRpcGxpZXJzID0+IHtcbiAgcmV0dXJuIG1hdHJpeCA9PiBnZXRDU1NNYXRyaXgobWF0cml4LCBtdWx0aXBsaWVycyk7XG59KShbMSwgLTEsIDEsIDEsIDEsIC0xLCAxLCAxLCAxLCAtMSwgMSwgMSwgMSwgLTEsIDEsIDFdKTtcbmNvbnN0IGdldE9iamVjdENTU01hdHJpeCA9IChzY2FsZU11bHRpcGxpZXJzID0+IHtcbiAgcmV0dXJuIChtYXRyaXgsIGZhY3RvcikgPT4gZ2V0Q1NTTWF0cml4KG1hdHJpeCwgc2NhbGVNdWx0aXBsaWVycyhmYWN0b3IpLCAndHJhbnNsYXRlKC01MCUsLTUwJSknKTtcbn0pKGYgPT4gWzEgLyBmLCAxIC8gZiwgMSAvIGYsIDEsIC0xIC8gZiwgLTEgLyBmLCAtMSAvIGYsIC0xLCAxIC8gZiwgMSAvIGYsIDEgLyBmLCAxLCAxLCAxLCAxLCAxXSk7XG5mdW5jdGlvbiBpc1JlZk9iamVjdChyZWYpIHtcbiAgcmV0dXJuIHJlZiAmJiB0eXBlb2YgcmVmID09PSAnb2JqZWN0JyAmJiAnY3VycmVudCcgaW4gcmVmO1xufVxuY29uc3QgSHRtbCA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgY2hpbGRyZW4sXG4gIGVwcyA9IDAuMDAxLFxuICBzdHlsZSxcbiAgY2xhc3NOYW1lLFxuICBwcmVwZW5kLFxuICBjZW50ZXIsXG4gIGZ1bGxzY3JlZW4sXG4gIHBvcnRhbCxcbiAgZGlzdGFuY2VGYWN0b3IsXG4gIHNwcml0ZSA9IGZhbHNlLFxuICB0cmFuc2Zvcm0gPSBmYWxzZSxcbiAgb2NjbHVkZSxcbiAgb25PY2NsdWRlLFxuICBjYXN0U2hhZG93LFxuICByZWNlaXZlU2hhZG93LFxuICBtYXRlcmlhbCxcbiAgZ2VvbWV0cnksXG4gIHpJbmRleFJhbmdlID0gWzE2Nzc3MjcxLCAwXSxcbiAgY2FsY3VsYXRlUG9zaXRpb24gPSBkZWZhdWx0Q2FsY3VsYXRlUG9zaXRpb24sXG4gIGFzID0gJ2RpdicsXG4gIHdyYXBwZXJDbGFzcyxcbiAgcG9pbnRlckV2ZW50cyA9ICdhdXRvJyxcbiAgLi4ucHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCB7XG4gICAgZ2wsXG4gICAgY2FtZXJhLFxuICAgIHNjZW5lLFxuICAgIHNpemUsXG4gICAgcmF5Y2FzdGVyLFxuICAgIGV2ZW50cyxcbiAgICB2aWV3cG9ydFxuICB9ID0gdXNlVGhyZWUoKTtcbiAgY29uc3QgW2VsXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYXMpKTtcbiAgY29uc3Qgcm9vdCA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBncm91cCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgb2xkWm9vbSA9IFJlYWN0LnVzZVJlZigwKTtcbiAgY29uc3Qgb2xkUG9zaXRpb24gPSBSZWFjdC51c2VSZWYoWzAsIDBdKTtcbiAgY29uc3QgdHJhbnNmb3JtT3V0ZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHRyYW5zZm9ybUlubmVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAvLyBBcHBlbmQgdG8gdGhlIGNvbm5lY3RlZCBlbGVtZW50LCB3aGljaCBtYWtlcyBIVE1MIHdvcmsgd2l0aCB2aWV3c1xuICBjb25zdCB0YXJnZXQgPSAocG9ydGFsID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWwuY3VycmVudCkgfHwgZXZlbnRzLmNvbm5lY3RlZCB8fCBnbC5kb21FbGVtZW50LnBhcmVudE5vZGU7XG4gIGNvbnN0IG9jY2x1c2lvbk1lc2hSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGlzTWVzaFNpemVTZXQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpc1JheUNhc3RPY2NsdXNpb24gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gb2NjbHVkZSAmJiBvY2NsdWRlICE9PSAnYmxlbmRpbmcnIHx8IEFycmF5LmlzQXJyYXkob2NjbHVkZSkgJiYgb2NjbHVkZS5sZW5ndGggJiYgaXNSZWZPYmplY3Qob2NjbHVkZVswXSk7XG4gIH0sIFtvY2NsdWRlXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZWwgPSBnbC5kb21FbGVtZW50O1xuICAgIGlmIChvY2NsdWRlICYmIG9jY2x1ZGUgPT09ICdibGVuZGluZycpIHtcbiAgICAgIGVsLnN0eWxlLnpJbmRleCA9IGAke01hdGguZmxvb3IoekluZGV4UmFuZ2VbMF0gLyAyKX1gO1xuICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuekluZGV4ID0gbnVsbDtcbiAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gbnVsbDtcbiAgICAgIGVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBudWxsO1xuICAgIH1cbiAgfSwgW29jY2x1ZGVdKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZ3JvdXAuY3VycmVudCkge1xuICAgICAgY29uc3QgY3VycmVudFJvb3QgPSByb290LmN1cnJlbnQgPSBSZWFjdERPTS5jcmVhdGVSb290KGVsKTtcbiAgICAgIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBgcG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3BvaW50ZXItZXZlbnRzOm5vbmU7b3ZlcmZsb3c6aGlkZGVuO2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2ZWMgPSBjYWxjdWxhdGVQb3NpdGlvbihncm91cC5jdXJyZW50LCBjYW1lcmEsIHNpemUpO1xuICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gYHBvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoJHt2ZWNbMF19cHgsJHt2ZWNbMV19cHgsMCk7dHJhbnNmb3JtLW9yaWdpbjowIDA7YDtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHByZXBlbmQpIHRhcmdldC5wcmVwZW5kKGVsKTtlbHNlIHRhcmdldC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAodGFyZ2V0KSB0YXJnZXQucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICBjdXJyZW50Um9vdC51bm1vdW50KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3RhcmdldCwgdHJhbnNmb3JtXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHdyYXBwZXJDbGFzcykgZWwuY2xhc3NOYW1lID0gd3JhcHBlckNsYXNzO1xuICB9LCBbd3JhcHBlckNsYXNzXSk7XG4gIGNvbnN0IHN0eWxlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICB0cmFuc2Zvcm1TdHlsZTogJ3ByZXNlcnZlLTNkJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdHJhbnNmb3JtOiBjZW50ZXIgPyAndHJhbnNsYXRlM2QoLTUwJSwtNTAlLDApJyA6ICdub25lJyxcbiAgICAgICAgLi4uKGZ1bGxzY3JlZW4gJiYge1xuICAgICAgICAgIHRvcDogLXNpemUuaGVpZ2h0IC8gMixcbiAgICAgICAgICBsZWZ0OiAtc2l6ZS53aWR0aCAvIDIsXG4gICAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uc3R5bGVcbiAgICAgIH07XG4gICAgfVxuICB9LCBbc3R5bGUsIGNlbnRlciwgZnVsbHNjcmVlbiwgc2l6ZSwgdHJhbnNmb3JtXSk7XG4gIGNvbnN0IHRyYW5zZm9ybUlubmVyU3R5bGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHBvaW50ZXJFdmVudHNcbiAgfSksIFtwb2ludGVyRXZlbnRzXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaXNNZXNoU2l6ZVNldC5jdXJyZW50ID0gZmFsc2U7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgdmFyIF9yb290JGN1cnJlbnQ7XG4gICAgICAoX3Jvb3QkY3VycmVudCA9IHJvb3QuY3VycmVudCkgPT0gbnVsbCB8fCBfcm9vdCRjdXJyZW50LnJlbmRlciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICByZWY6IHRyYW5zZm9ybU91dGVyUmVmLFxuICAgICAgICBzdHlsZTogc3R5bGVzXG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHJlZjogdHJhbnNmb3JtSW5uZXJSZWYsXG4gICAgICAgIHN0eWxlOiB0cmFuc2Zvcm1Jbm5lclN0eWxlc1xuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICByZWY6IHJlZixcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICB9KSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9yb290JGN1cnJlbnQyO1xuICAgICAgKF9yb290JGN1cnJlbnQyID0gcm9vdC5jdXJyZW50KSA9PSBudWxsIHx8IF9yb290JGN1cnJlbnQyLnJlbmRlciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICByZWY6IHJlZixcbiAgICAgICAgc3R5bGU6IHN0eWxlcyxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHZpc2libGUgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gIHVzZUZyYW1lKGdsID0+IHtcbiAgICBpZiAoZ3JvdXAuY3VycmVudCkge1xuICAgICAgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICBncm91cC5jdXJyZW50LnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgICAgIGNvbnN0IHZlYyA9IHRyYW5zZm9ybSA/IG9sZFBvc2l0aW9uLmN1cnJlbnQgOiBjYWxjdWxhdGVQb3NpdGlvbihncm91cC5jdXJyZW50LCBjYW1lcmEsIHNpemUpO1xuICAgICAgaWYgKHRyYW5zZm9ybSB8fCBNYXRoLmFicyhvbGRab29tLmN1cnJlbnQgLSBjYW1lcmEuem9vbSkgPiBlcHMgfHwgTWF0aC5hYnMob2xkUG9zaXRpb24uY3VycmVudFswXSAtIHZlY1swXSkgPiBlcHMgfHwgTWF0aC5hYnMob2xkUG9zaXRpb24uY3VycmVudFsxXSAtIHZlY1sxXSkgPiBlcHMpIHtcbiAgICAgICAgY29uc3QgaXNCZWhpbmRDYW1lcmEgPSBpc09iamVjdEJlaGluZENhbWVyYShncm91cC5jdXJyZW50LCBjYW1lcmEpO1xuICAgICAgICBsZXQgcmF5dHJhY2VUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzUmF5Q2FzdE9jY2x1c2lvbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9jY2x1ZGUpKSB7XG4gICAgICAgICAgICByYXl0cmFjZVRhcmdldCA9IG9jY2x1ZGUubWFwKGl0ZW0gPT4gaXRlbS5jdXJyZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9jY2x1ZGUgIT09ICdibGVuZGluZycpIHtcbiAgICAgICAgICAgIHJheXRyYWNlVGFyZ2V0ID0gW3NjZW5lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNseVZpc2libGUgPSB2aXNpYmxlLmN1cnJlbnQ7XG4gICAgICAgIGlmIChyYXl0cmFjZVRhcmdldCkge1xuICAgICAgICAgIGNvbnN0IGlzdmlzaWJsZSA9IGlzT2JqZWN0VmlzaWJsZShncm91cC5jdXJyZW50LCBjYW1lcmEsIHJheWNhc3RlciwgcmF5dHJhY2VUYXJnZXQpO1xuICAgICAgICAgIHZpc2libGUuY3VycmVudCA9IGlzdmlzaWJsZSAmJiAhaXNCZWhpbmRDYW1lcmE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlzaWJsZS5jdXJyZW50ID0gIWlzQmVoaW5kQ2FtZXJhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c2x5VmlzaWJsZSAhPT0gdmlzaWJsZS5jdXJyZW50KSB7XG4gICAgICAgICAgaWYgKG9uT2NjbHVkZSkgb25PY2NsdWRlKCF2aXNpYmxlLmN1cnJlbnQpO2Vsc2UgZWwuc3R5bGUuZGlzcGxheSA9IHZpc2libGUuY3VycmVudCA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFsZlJhbmdlID0gTWF0aC5mbG9vcih6SW5kZXhSYW5nZVswXSAvIDIpO1xuICAgICAgICBjb25zdCB6UmFuZ2UgPSBvY2NsdWRlID8gaXNSYXlDYXN0T2NjbHVzaW9uIC8vXG4gICAgICAgID8gW3pJbmRleFJhbmdlWzBdLCBoYWxmUmFuZ2VdIDogW2hhbGZSYW5nZSAtIDEsIDBdIDogekluZGV4UmFuZ2U7XG4gICAgICAgIGVsLnN0eWxlLnpJbmRleCA9IGAke29iamVjdFpJbmRleChncm91cC5jdXJyZW50LCBjYW1lcmEsIHpSYW5nZSl9YDtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgIGNvbnN0IFt3aWR0aEhhbGYsIGhlaWdodEhhbGZdID0gW3NpemUud2lkdGggLyAyLCBzaXplLmhlaWdodCAvIDJdO1xuICAgICAgICAgIGNvbnN0IGZvdiA9IGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzVdICogaGVpZ2h0SGFsZjtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpc09ydGhvZ3JhcGhpY0NhbWVyYSxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICByaWdodFxuICAgICAgICAgIH0gPSBjYW1lcmE7XG4gICAgICAgICAgY29uc3QgY2FtZXJhTWF0cml4ID0gZ2V0Q2FtZXJhQ1NTTWF0cml4KGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuICAgICAgICAgIGNvbnN0IGNhbWVyYVRyYW5zZm9ybSA9IGlzT3J0aG9ncmFwaGljQ2FtZXJhID8gYHNjYWxlKCR7Zm92fSl0cmFuc2xhdGUoJHtlcHNpbG9uKC0ocmlnaHQgKyBsZWZ0KSAvIDIpfXB4LCR7ZXBzaWxvbigodG9wICsgYm90dG9tKSAvIDIpfXB4KWAgOiBgdHJhbnNsYXRlWigke2Zvdn1weClgO1xuICAgICAgICAgIGxldCBtYXRyaXggPSBncm91cC5jdXJyZW50Lm1hdHJpeFdvcmxkO1xuICAgICAgICAgIGlmIChzcHJpdGUpIHtcbiAgICAgICAgICAgIG1hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuY2xvbmUoKS50cmFuc3Bvc2UoKS5jb3B5UG9zaXRpb24obWF0cml4KS5zY2FsZShncm91cC5jdXJyZW50LnNjYWxlKTtcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1szXSA9IG1hdHJpeC5lbGVtZW50c1s3XSA9IG1hdHJpeC5lbGVtZW50c1sxMV0gPSAwO1xuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWzE1XSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gc2l6ZS53aWR0aCArICdweCc7XG4gICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQgKyAncHgnO1xuICAgICAgICAgIGVsLnN0eWxlLnBlcnNwZWN0aXZlID0gaXNPcnRob2dyYXBoaWNDYW1lcmEgPyAnJyA6IGAke2Zvdn1weGA7XG4gICAgICAgICAgaWYgKHRyYW5zZm9ybU91dGVyUmVmLmN1cnJlbnQgJiYgdHJhbnNmb3JtSW5uZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtT3V0ZXJSZWYuY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPSBgJHtjYW1lcmFUcmFuc2Zvcm19JHtjYW1lcmFNYXRyaXh9dHJhbnNsYXRlKCR7d2lkdGhIYWxmfXB4LCR7aGVpZ2h0SGFsZn1weClgO1xuICAgICAgICAgICAgdHJhbnNmb3JtSW5uZXJSZWYuY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPSBnZXRPYmplY3RDU1NNYXRyaXgobWF0cml4LCAxIC8gKChkaXN0YW5jZUZhY3RvciB8fCAxMCkgLyA0MDApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc2NhbGUgPSBkaXN0YW5jZUZhY3RvciA9PT0gdW5kZWZpbmVkID8gMSA6IG9iamVjdFNjYWxlKGdyb3VwLmN1cnJlbnQsIGNhbWVyYSkgKiBkaXN0YW5jZUZhY3RvcjtcbiAgICAgICAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt2ZWNbMF19cHgsJHt2ZWNbMV19cHgsMCkgc2NhbGUoJHtzY2FsZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBvbGRQb3NpdGlvbi5jdXJyZW50ID0gdmVjO1xuICAgICAgICBvbGRab29tLmN1cnJlbnQgPSBjYW1lcmEuem9vbTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1JheUNhc3RPY2NsdXNpb24gJiYgb2NjbHVzaW9uTWVzaFJlZi5jdXJyZW50ICYmICFpc01lc2hTaXplU2V0LmN1cnJlbnQpIHtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybU91dGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBjb25zdCBlbCA9IHRyYW5zZm9ybU91dGVyUmVmLmN1cnJlbnQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgaWYgKGVsICE9IG51bGwgJiYgZWwuY2xpZW50V2lkdGggJiYgZWwgIT0gbnVsbCAmJiBlbC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaXNPcnRob2dyYXBoaWNDYW1lcmFcbiAgICAgICAgICAgIH0gPSBjYW1lcmE7XG4gICAgICAgICAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEgfHwgZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BzLnNjYWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzLnNjYWxlKSkge1xuICAgICAgICAgICAgICAgICAgb2NjbHVzaW9uTWVzaFJlZi5jdXJyZW50LnNjYWxlLnNldFNjYWxhcigxIC8gcHJvcHMuc2NhbGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcHMuc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IzKSB7XG4gICAgICAgICAgICAgICAgICBvY2NsdXNpb25NZXNoUmVmLmN1cnJlbnQuc2NhbGUuY29weShwcm9wcy5zY2FsZS5jbG9uZSgpLmRpdmlkZVNjYWxhcigxKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG9jY2x1c2lvbk1lc2hSZWYuY3VycmVudC5zY2FsZS5zZXQoMSAvIHByb3BzLnNjYWxlWzBdLCAxIC8gcHJvcHMuc2NhbGVbMV0sIDEgLyBwcm9wcy5zY2FsZVsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCByYXRpbyA9IChkaXN0YW5jZUZhY3RvciB8fCAxMCkgLyA0MDA7XG4gICAgICAgICAgICAgIGNvbnN0IHcgPSBlbC5jbGllbnRXaWR0aCAqIHJhdGlvO1xuICAgICAgICAgICAgICBjb25zdCBoID0gZWwuY2xpZW50SGVpZ2h0ICogcmF0aW87XG4gICAgICAgICAgICAgIG9jY2x1c2lvbk1lc2hSZWYuY3VycmVudC5zY2FsZS5zZXQodywgaCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc01lc2hTaXplU2V0LmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZWxlID0gZWwuY2hpbGRyZW5bMF07XG4gICAgICAgIGlmIChlbGUgIT0gbnVsbCAmJiBlbGUuY2xpZW50V2lkdGggJiYgZWxlICE9IG51bGwgJiYgZWxlLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgIGNvbnN0IHJhdGlvID0gMSAvIHZpZXdwb3J0LmZhY3RvcjtcbiAgICAgICAgICBjb25zdCB3ID0gZWxlLmNsaWVudFdpZHRoICogcmF0aW87XG4gICAgICAgICAgY29uc3QgaCA9IGVsZS5jbGllbnRIZWlnaHQgKiByYXRpbztcbiAgICAgICAgICBvY2NsdXNpb25NZXNoUmVmLmN1cnJlbnQuc2NhbGUuc2V0KHcsIGgsIDEpO1xuICAgICAgICAgIGlzTWVzaFNpemVTZXQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgb2NjbHVzaW9uTWVzaFJlZi5jdXJyZW50Lmxvb2tBdChnbC5jYW1lcmEucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHNoYWRlcnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgdmVydGV4U2hhZGVyOiAhdHJhbnNmb3JtID8gLyogZ2xzbCAqL2BcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgVGhpcyBzaGFkZXIgaXMgZnJvbSB0aGUgVEhSRUUncyBTcHJpdGVNYXRlcmlhbC5cbiAgICAgICAgICAgIFdlIG5lZWQgdG8gdHVybiB0aGUgYmFja2luZyBwbGFuZSBpbnRvIGEgU3ByaXRlXG4gICAgICAgICAgICAobWFrZSBpdCBhbHdheXMgZmFjZSB0aGUgY2FtZXJhKSBpZiBcInRyYW5zZnJvbVwiXG4gICAgICAgICAgICBpcyBmYWxzZS5cbiAgICAgICAgICAqL1xuICAgICAgICAgICNpbmNsdWRlIDxjb21tb24+XG5cbiAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICB2ZWMyIGNlbnRlciA9IHZlYzIoMC4sIDEuKTtcbiAgICAgICAgICAgIGZsb2F0IHJvdGF0aW9uID0gMC4wO1xuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHNvbWV3aGF0IGFyYml0cmFyeSwgYnV0IGl0IHNlZW1zIHRvIHdvcmsgd2VsbFxuICAgICAgICAgICAgLy8gTmVlZCB0byBmaWd1cmUgb3V0IGhvdyB0byBkZXJpdmUgdGhpcyBkeW5hbWljYWxseSBpZiBpdCBldmVuIG1hdHRlcnNcbiAgICAgICAgICAgIGZsb2F0IHNpemUgPSAwLjAzO1xuXG4gICAgICAgICAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcbiAgICAgICAgICAgIHZlYzIgc2NhbGU7XG4gICAgICAgICAgICBzY2FsZS54ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMCBdLngsIG1vZGVsTWF0cml4WyAwIF0ueSwgbW9kZWxNYXRyaXhbIDAgXS56ICkgKTtcbiAgICAgICAgICAgIHNjYWxlLnkgPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAxIF0ueCwgbW9kZWxNYXRyaXhbIDEgXS55LCBtb2RlbE1hdHJpeFsgMSBdLnogKSApO1xuXG4gICAgICAgICAgICBib29sIGlzUGVyc3BlY3RpdmUgPSBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICk7XG4gICAgICAgICAgICBpZiAoIGlzUGVyc3BlY3RpdmUgKSBzY2FsZSAqPSAtIG12UG9zaXRpb24uejtcblxuICAgICAgICAgICAgdmVjMiBhbGlnbmVkUG9zaXRpb24gPSAoIHBvc2l0aW9uLnh5IC0gKCBjZW50ZXIgLSB2ZWMyKCAwLjUgKSApICkgKiBzY2FsZSAqIHNpemU7XG4gICAgICAgICAgICB2ZWMyIHJvdGF0ZWRQb3NpdGlvbjtcbiAgICAgICAgICAgIHJvdGF0ZWRQb3NpdGlvbi54ID0gY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTtcbiAgICAgICAgICAgIHJvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTtcbiAgICAgICAgICAgIG12UG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uO1xuXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgIGAgOiB1bmRlZmluZWQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IC8qIGdsc2wgKi9gXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgIH1cbiAgICAgIGBcbiAgfSksIFt0cmFuc2Zvcm1dKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgcmVmOiBncm91cFxuICB9KSwgb2NjbHVkZSAmJiAhaXNSYXlDYXN0T2NjbHVzaW9uICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLCB7XG4gICAgY2FzdFNoYWRvdzogY2FzdFNoYWRvdyxcbiAgICByZWNlaXZlU2hhZG93OiByZWNlaXZlU2hhZG93LFxuICAgIHJlZjogb2NjbHVzaW9uTWVzaFJlZlxuICB9LCBnZW9tZXRyeSB8fCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBsYW5lR2VvbWV0cnlcIiwgbnVsbCksIG1hdGVyaWFsIHx8IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic2hhZGVyTWF0ZXJpYWxcIiwge1xuICAgIHNpZGU6IERvdWJsZVNpZGUsXG4gICAgdmVydGV4U2hhZGVyOiBzaGFkZXJzLnZlcnRleFNoYWRlcixcbiAgICBmcmFnbWVudFNoYWRlcjogc2hhZGVycy5mcmFnbWVudFNoYWRlclxuICB9KSkpO1xufSk7XG5cbmV4cG9ydCB7IEh0bWwgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/web/Html.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/web/KeyboardControls.js":
/*!****************************************************************!*\
  !*** ./node_modules/@react-three/drei/web/KeyboardControls.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyboardControls: () => (/* binding */ KeyboardControls),\n/* harmony export */   useKeyboardControls: () => (/* binding */ useKeyboardControls)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/@react-three/drei/node_modules/zustand/esm/index.js\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/middleware */ \"(ssr)/./node_modules/@react-three/drei/node_modules/zustand/esm/middleware.js\");\n\n\n\n\n// These are removed in Zustand v4\n// unknown\n\n// Zustand v3 marked deprecations in 3.x, but there's no visible upgrade path\n\nconst context = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction KeyboardControls({\n  map,\n  children,\n  onChange,\n  domElement\n}) {\n  const key = map.map(item => item.name + item.keys).join('-');\n  const useControls = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return (0,zustand__WEBPACK_IMPORTED_MODULE_1__[\"default\"])((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.subscribeWithSelector)(() => map.reduce((prev, cur) => ({\n      ...prev,\n      [cur.name]: false\n    }), {})));\n  }, [key]);\n  const api = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => [useControls.subscribe, useControls.getState, useControls], [key]);\n  const set = useControls.setState;\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const config = map.map(({\n      name,\n      keys,\n      up\n    }) => ({\n      keys,\n      up,\n      fn: value => {\n        // Set zustand state\n        set({\n          [name]: value\n        });\n        // Inform callback\n        if (onChange) onChange(name, value, api[1]());\n      }\n    }));\n    const keyMap = config.reduce((out, {\n      keys,\n      fn,\n      up = true\n    }) => {\n      keys.forEach(key => out[key] = {\n        fn,\n        pressed: false,\n        up\n      });\n      return out;\n    }, {});\n    const downHandler = ({\n      key,\n      code\n    }) => {\n      const obj = keyMap[key] || keyMap[code];\n      if (!obj) return;\n      const {\n        fn,\n        pressed,\n        up\n      } = obj;\n      obj.pressed = true;\n      if (up || !pressed) fn(true);\n    };\n    const upHandler = ({\n      key,\n      code\n    }) => {\n      const obj = keyMap[key] || keyMap[code];\n      if (!obj) return;\n      const {\n        fn,\n        up\n      } = obj;\n      obj.pressed = false;\n      if (up) fn(false);\n    };\n    const source = domElement || window;\n    source.addEventListener('keydown', downHandler, {\n      passive: true\n    });\n    source.addEventListener('keyup', upHandler, {\n      passive: true\n    });\n    return () => {\n      source.removeEventListener('keydown', downHandler);\n      source.removeEventListener('keyup', upHandler);\n    };\n  }, [domElement, key]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n    value: api,\n    children: children\n  });\n}\nfunction useKeyboardControls(sel) {\n  const [sub, get, store] = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n  if (sel) return store(sel);else return [sub, get];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvd2ViL0tleWJvYXJkQ29udHJvbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStCO0FBQ0Y7QUFDOEI7O0FBRTNEO0FBQ0E7O0FBRUE7O0FBRUEsK0JBQStCLGdEQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCLDBDQUFhO0FBQ25DLFdBQVcsbURBQU0sQ0FBQyx5RUFBcUI7QUFDdkM7QUFDQTtBQUNBLEtBQUssS0FBSztBQUNWLEdBQUc7QUFDSCxjQUFjLDBDQUFhO0FBQzNCO0FBQ0EsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsZ0RBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRCQUE0Qiw2Q0FBZ0I7QUFDNUMsNkJBQTZCO0FBQzdCOztBQUVpRCIsInNvdXJjZXMiOlsid2VicGFjazovL2phd2FyYS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS93ZWIvS2V5Ym9hcmRDb250cm9scy5qcz9lNTI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjcmVhdGUgZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgeyBzdWJzY3JpYmVXaXRoU2VsZWN0b3IgfSBmcm9tICd6dXN0YW5kL21pZGRsZXdhcmUnO1xuXG4vLyBUaGVzZSBhcmUgcmVtb3ZlZCBpbiBadXN0YW5kIHY0XG4vLyB1bmtub3duXG5cbi8vIFp1c3RhbmQgdjMgbWFya2VkIGRlcHJlY2F0aW9ucyBpbiAzLngsIGJ1dCB0aGVyZSdzIG5vIHZpc2libGUgdXBncmFkZSBwYXRoXG5cbmNvbnN0IGNvbnRleHQgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gS2V5Ym9hcmRDb250cm9scyh7XG4gIG1hcCxcbiAgY2hpbGRyZW4sXG4gIG9uQ2hhbmdlLFxuICBkb21FbGVtZW50XG59KSB7XG4gIGNvbnN0IGtleSA9IG1hcC5tYXAoaXRlbSA9PiBpdGVtLm5hbWUgKyBpdGVtLmtleXMpLmpvaW4oJy0nKTtcbiAgY29uc3QgdXNlQ29udHJvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlKHN1YnNjcmliZVdpdGhTZWxlY3RvcigoKSA9PiBtYXAucmVkdWNlKChwcmV2LCBjdXIpID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgW2N1ci5uYW1lXTogZmFsc2VcbiAgICB9KSwge30pKSk7XG4gIH0sIFtrZXldKTtcbiAgY29uc3QgYXBpID0gUmVhY3QudXNlTWVtbygoKSA9PiBbdXNlQ29udHJvbHMuc3Vic2NyaWJlLCB1c2VDb250cm9scy5nZXRTdGF0ZSwgdXNlQ29udHJvbHNdLCBba2V5XSk7XG4gIGNvbnN0IHNldCA9IHVzZUNvbnRyb2xzLnNldFN0YXRlO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IG1hcC5tYXAoKHtcbiAgICAgIG5hbWUsXG4gICAgICBrZXlzLFxuICAgICAgdXBcbiAgICB9KSA9PiAoe1xuICAgICAga2V5cyxcbiAgICAgIHVwLFxuICAgICAgZm46IHZhbHVlID0+IHtcbiAgICAgICAgLy8gU2V0IHp1c3RhbmQgc3RhdGVcbiAgICAgICAgc2V0KHtcbiAgICAgICAgICBbbmFtZV06IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJbmZvcm0gY2FsbGJhY2tcbiAgICAgICAgaWYgKG9uQ2hhbmdlKSBvbkNoYW5nZShuYW1lLCB2YWx1ZSwgYXBpWzFdKCkpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBrZXlNYXAgPSBjb25maWcucmVkdWNlKChvdXQsIHtcbiAgICAgIGtleXMsXG4gICAgICBmbixcbiAgICAgIHVwID0gdHJ1ZVxuICAgIH0pID0+IHtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gb3V0W2tleV0gPSB7XG4gICAgICAgIGZuLFxuICAgICAgICBwcmVzc2VkOiBmYWxzZSxcbiAgICAgICAgdXBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgZG93bkhhbmRsZXIgPSAoe1xuICAgICAga2V5LFxuICAgICAgY29kZVxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IG9iaiA9IGtleU1hcFtrZXldIHx8IGtleU1hcFtjb2RlXTtcbiAgICAgIGlmICghb2JqKSByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZuLFxuICAgICAgICBwcmVzc2VkLFxuICAgICAgICB1cFxuICAgICAgfSA9IG9iajtcbiAgICAgIG9iai5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgIGlmICh1cCB8fCAhcHJlc3NlZCkgZm4odHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCB1cEhhbmRsZXIgPSAoe1xuICAgICAga2V5LFxuICAgICAgY29kZVxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IG9iaiA9IGtleU1hcFtrZXldIHx8IGtleU1hcFtjb2RlXTtcbiAgICAgIGlmICghb2JqKSByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZuLFxuICAgICAgICB1cFxuICAgICAgfSA9IG9iajtcbiAgICAgIG9iai5wcmVzc2VkID0gZmFsc2U7XG4gICAgICBpZiAodXApIGZuKGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IHNvdXJjZSA9IGRvbUVsZW1lbnQgfHwgd2luZG93O1xuICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duSGFuZGxlcik7XG4gICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgIH07XG4gIH0sIFtkb21FbGVtZW50LCBrZXldKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogYXBpLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZUtleWJvYXJkQ29udHJvbHMoc2VsKSB7XG4gIGNvbnN0IFtzdWIsIGdldCwgc3RvcmVdID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgaWYgKHNlbCkgcmV0dXJuIHN0b3JlKHNlbCk7ZWxzZSByZXR1cm4gW3N1YiwgZ2V0XTtcbn1cblxuZXhwb3J0IHsgS2V5Ym9hcmRDb250cm9scywgdXNlS2V5Ym9hcmRDb250cm9scyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/web/KeyboardControls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/index-99983b2d.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/index-99983b2d.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useThree),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useFrame),\n/* harmony export */   D: () => (/* binding */ useGraph),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useLoader),\n/* harmony export */   a: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   b: () => (/* binding */ createRoot),\n/* harmony export */   c: () => (/* binding */ createEvents),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ context),\n/* harmony export */   g: () => (/* binding */ createPortal),\n/* harmony export */   h: () => (/* binding */ reconciler),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ applyProps),\n/* harmony export */   k: () => (/* binding */ dispose),\n/* harmony export */   l: () => (/* binding */ invalidate),\n/* harmony export */   m: () => (/* binding */ advance),\n/* harmony export */   n: () => (/* binding */ addEffect),\n/* harmony export */   o: () => (/* binding */ addAfterEffect),\n/* harmony export */   p: () => (/* binding */ addTail),\n/* harmony export */   q: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   r: () => (/* binding */ render),\n/* harmony export */   s: () => (/* binding */ getRootState),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useMutableCallback),\n/* harmony export */   v: () => (/* binding */ act),\n/* harmony export */   w: () => (/* binding */ buildGraph),\n/* harmony export */   x: () => (/* binding */ roots),\n/* harmony export */   y: () => (/* binding */ useInstanceHandle),\n/* harmony export */   z: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nconst catalogue = {};\nconst extend = objects => void Object.assign(catalogue, objects);\nfunction createRenderer(_roots, _getEventPriority) {\n  function createInstance(type, {\n    args = [],\n    attach,\n    ...props\n  }, root) {\n    let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n    let instance;\n    if (type === 'primitive') {\n      if (props.object === undefined) throw new Error(\"R3F: Primitives without 'object' are invalid!\");\n      const object = props.object;\n      instance = prepare(object, {\n        type,\n        root,\n        attach,\n        primitive: true\n      });\n    } else {\n      const target = catalogue[name];\n      if (!target) {\n        throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n      }\n\n      // Throw if an object or literal was passed for args\n      if (!Array.isArray(args)) throw new Error('R3F: The args prop must be an array!');\n\n      // Instanciate new object, link it to the root\n      // Append memoized props with args so it's not forgotten\n      instance = prepare(new target(...args), {\n        type,\n        root,\n        attach,\n        // Save args in case we need to reconstruct later for HMR\n        memoizedProps: {\n          args\n        }\n      });\n    }\n\n    // Auto-attach geometries and materials\n    if (instance.__r3f.attach === undefined) {\n      if (instance instanceof three__WEBPACK_IMPORTED_MODULE_5__.BufferGeometry) instance.__r3f.attach = 'geometry';else if (instance instanceof three__WEBPACK_IMPORTED_MODULE_5__.Material) instance.__r3f.attach = 'material';\n    }\n\n    // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n    // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n    // why it passes \"true\" here\n    // There is no reason to apply props to injects\n    if (name !== 'inject') applyProps$1(instance, props);\n    return instance;\n  }\n  function appendChild(parentInstance, child) {\n    let added = false;\n    if (child) {\n      var _child$__r3f, _parentInstance$__r3f;\n      // The attach attribute implies that the object attaches itself on the parent\n      if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {\n        attach(parentInstance, child, child.__r3f.attach);\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        // add in the usual parent-child way\n        parentInstance.add(child);\n        added = true;\n      }\n      // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n      // that is, anything that's a child in React but not a child in the scenegraph.\n      if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);\n      if (!child.__r3f) prepare(child, {});\n      child.__r3f.parent = parentInstance;\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n  function insertBefore(parentInstance, child, beforeChild) {\n    let added = false;\n    if (child) {\n      var _child$__r3f2, _parentInstance$__r3f2;\n      if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {\n        attach(parentInstance, child, child.__r3f.attach);\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        child.parent = parentInstance;\n        child.dispatchEvent({\n          type: 'added'\n        });\n        parentInstance.dispatchEvent({\n          type: 'childadded',\n          child\n        });\n        const restSiblings = parentInstance.children.filter(sibling => sibling !== child);\n        const index = restSiblings.indexOf(beforeChild);\n        parentInstance.children = [...restSiblings.slice(0, index), child, ...restSiblings.slice(index)];\n        added = true;\n      }\n      if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);\n      if (!child.__r3f) prepare(child, {});\n      child.__r3f.parent = parentInstance;\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n  function removeRecursive(array, parent, dispose = false) {\n    if (array) [...array].forEach(child => removeChild(parent, child, dispose));\n  }\n  function removeChild(parentInstance, child, dispose) {\n    if (child) {\n      var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;\n      // Clear the parent reference\n      if (child.__r3f) child.__r3f.parent = null;\n      // Remove child from the parents objects\n      if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter(x => x !== child);\n      // Remove attachment\n      if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {\n        detach(parentInstance, child, child.__r3f.attach);\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        var _child$__r3f4;\n        parentInstance.remove(child);\n        // @ts-expect-error\n        // Remove interactivity on the initial root\n        if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {\n          removeInteractivity(findInitialRoot(child), child);\n        }\n      }\n\n      // Allow objects to bail out of recursive dispose altogether by passing dispose={null}\n      // Never dispose of primitives because their state may be kept outside of React!\n      // In order for an object to be able to dispose it has to have\n      //   - a dispose method,\n      //   - it cannot be a <primitive object={...} />\n      //   - it cannot be a THREE.Scene, because three has broken it's own api\n      //\n      // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n      // when the reconciler calls it, but then carry our own check recursively\n      const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;\n      const shouldDispose = !isPrimitive && (dispose === undefined ? child.dispose !== null : dispose);\n\n      // Remove nested child objects. Primitives should not have objects and children that are\n      // attached to them declaratively ...\n      if (!isPrimitive) {\n        var _child$__r3f6;\n        removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);\n        removeRecursive(child.children, child, shouldDispose);\n      }\n\n      // Remove references\n      delete child.__r3f;\n\n      // Dispose item whenever the reconciler feels like it\n      if (shouldDispose && child.dispose && child.type !== 'Scene') {\n        const callback = () => {\n          try {\n            child.dispose();\n          } catch (e) {\n            /* ... */\n          }\n        };\n\n        // Schedule async at runtime, flush sync in testing\n        if (typeof IS_REACT_ACT_ENVIRONMENT === 'undefined') {\n          (0,scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_IdlePriority, callback);\n        } else {\n          callback();\n        }\n      }\n      invalidateInstance(parentInstance);\n    }\n  }\n  function switchInstance(instance, type, newProps, fiber) {\n    var _instance$__r3f;\n    const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;\n    if (!parent) return;\n    const newInstance = createInstance(type, newProps, instance.__r3f.root);\n\n    // https://github.com/pmndrs/react-three-fiber/issues/1348\n    // When args change the instance has to be re-constructed, which then\n    // forces r3f to re-parent the children and non-scene objects\n    if (instance.children) {\n      for (const child of instance.children) {\n        if (child.__r3f) appendChild(newInstance, child);\n      }\n      instance.children = instance.children.filter(child => !child.__r3f);\n    }\n    instance.__r3f.objects.forEach(child => appendChild(newInstance, child));\n    instance.__r3f.objects = [];\n    if (!instance.__r3f.autoRemovedBeforeAppend) {\n      removeChild(parent, instance);\n    }\n    if (newInstance.parent) {\n      newInstance.__r3f.autoRemovedBeforeAppend = true;\n    }\n    appendChild(parent, newInstance);\n\n    // Re-bind event handlers on the initial root\n    if (newInstance.raycast && newInstance.__r3f.eventCount) {\n      const rootState = findInitialRoot(newInstance).getState();\n      rootState.internal.interaction.push(newInstance);\n    }\n    [fiber, fiber.alternate].forEach(fiber => {\n      if (fiber !== null) {\n        fiber.stateNode = newInstance;\n        if (fiber.ref) {\n          if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;\n        }\n      }\n    });\n  }\n\n  // Don't handle text instances, warn on undefined behavior\n  const handleTextInstance = () => console.warn('Text is not allowed in the R3F tree! This could be stray whitespace or characters.');\n  const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_2___default()({\n    createInstance,\n    removeChild,\n    appendChild,\n    appendInitialChild: appendChild,\n    insertBefore,\n    supportsMutation: true,\n    isPrimaryRenderer: false,\n    supportsPersistence: false,\n    supportsHydration: false,\n    noTimeout: -1,\n    appendChildToContainer: (container, child) => {\n      if (!child) return;\n\n      // Don't append to unmounted container\n      const scene = container.getState().scene;\n      if (!scene.__r3f) return;\n\n      // Link current root to the default scene\n      scene.__r3f.root = container;\n      appendChild(scene, child);\n    },\n    removeChildFromContainer: (container, child) => {\n      if (!child) return;\n      removeChild(container.getState().scene, child);\n    },\n    insertInContainerBefore: (container, child, beforeChild) => {\n      if (!child || !beforeChild) return;\n\n      // Don't append to unmounted container\n      const scene = container.getState().scene;\n      if (!scene.__r3f) return;\n      insertBefore(scene, child, beforeChild);\n    },\n    getRootHostContext: () => null,\n    getChildHostContext: parentHostContext => parentHostContext,\n    finalizeInitialChildren(instance) {\n      var _instance$__r3f2;\n      const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};\n      // https://github.com/facebook/react/issues/20271\n      // Returning true will trigger commitMount\n      return Boolean(localState.handlers);\n    },\n    prepareUpdate(instance, _type, oldProps, newProps) {\n      var _instance$__r3f3;\n      const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n\n      // Create diff-sets\n      if (localState.primitive && newProps.object && newProps.object !== instance) {\n        return [true];\n      } else {\n        // This is a data object, let's extract critical information about it\n        const {\n          args: argsNew = [],\n          children: cN,\n          ...restNew\n        } = newProps;\n        const {\n          args: argsOld = [],\n          children: cO,\n          ...restOld\n        } = oldProps;\n\n        // Throw if an object or literal was passed for args\n        if (!Array.isArray(argsNew)) throw new Error('R3F: the args prop must be an array!');\n\n        // If it has new props or arguments, then it needs to be re-instantiated\n        if (argsNew.some((value, index) => value !== argsOld[index])) return [true];\n        // Create a diff-set, flag if there are any changes\n        const diff = diffProps(instance, restNew, restOld, true);\n        if (diff.changes.length) return [false, diff];\n\n        // Otherwise do not touch the instance\n        return null;\n      }\n    },\n    commitUpdate(instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {\n      // Reconstruct when args or <primitive object={...} have changes\n      if (reconstruct) switchInstance(instance, type, newProps, fiber);\n      // Otherwise just overwrite props\n      else applyProps$1(instance, diff);\n    },\n    commitMount(instance, _type, _props, _int) {\n      var _instance$__r3f4;\n      // https://github.com/facebook/react/issues/20271\n      // This will make sure events are only added once to the central container on the initial root\n      const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};\n      if (instance.raycast && localState.handlers && localState.eventCount) {\n        findInitialRoot(instance).getState().internal.interaction.push(instance);\n      }\n    },\n    getPublicInstance: instance => instance,\n    prepareForCommit: () => null,\n    preparePortalMount: container => prepare(container.getState().scene),\n    resetAfterCommit: () => {},\n    shouldSetTextContent: () => false,\n    clearContainer: () => false,\n    hideInstance(instance) {\n      var _instance$__r3f5;\n      // Detach while the instance is hidden\n      const {\n        attach: type,\n        parent\n      } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};\n      if (type && parent) detach(parent, instance, type);\n      if (instance.isObject3D) instance.visible = false;\n      invalidateInstance(instance);\n    },\n    unhideInstance(instance, props) {\n      var _instance$__r3f6;\n      // Re-attach when the instance is unhidden\n      const {\n        attach: type,\n        parent\n      } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};\n      if (type && parent) attach(parent, instance, type);\n      if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;\n      invalidateInstance(instance);\n    },\n    createTextInstance: handleTextInstance,\n    hideTextInstance: handleTextInstance,\n    unhideTextInstance: handleTextInstance,\n    // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874\n    // @ts-expect-error\n    getCurrentEventPriority: () => _getEventPriority ? _getEventPriority() : react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority,\n    beforeActiveInstanceBlur: () => {},\n    afterActiveInstanceBlur: () => {},\n    detachDeletedInstance: () => {},\n    now: typeof performance !== 'undefined' && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : () => 0,\n    // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503\n    scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined\n  });\n  return {\n    reconciler,\n    applyProps: applyProps$1\n  };\n}\n\nvar _window$document, _window$navigator;\n/**\r\n * Returns `true` with correct TS type inference if an object has a configurable color space (since r152).\r\n */\nconst hasColorSpace = object => 'colorSpace' in object || 'outputColorSpace' in object;\n/**\r\n * The current THREE.ColorManagement instance, if present.\r\n */\nconst getColorManagement = () => {\n  var _ColorManagement;\n  return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;\n};\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nconst isRef = obj => obj && obj.hasOwnProperty('current');\n\n/**\r\n * An SSR-friendly useLayoutEffect.\r\n *\r\n * React currently throws a warning when using useLayoutEffect on the server.\r\n * To get around it, we can conditionally useEffect on the server (no-op) and\r\n * useLayoutEffect elsewhere.\r\n *\r\n * @see https://github.com/facebook/react/issues/14927\r\n */\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && ((_window$document = window.document) != null && _window$document.createElement || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === 'ReactNative') ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n  useIsomorphicLayoutEffect(() => void (ref.current = fn), [fn]);\n  return ref;\n}\nfunction Block({\n  set\n}) {\n  useIsomorphicLayoutEffect(() => {\n    set(new Promise(() => null));\n    return () => set(false);\n  }, [set]);\n  return null;\n}\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      error: false\n    };\n  }\n  componentDidCatch(err) {\n    this.props.set(err);\n  }\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n}\nErrorBoundary.getDerivedStateFromError = () => ({\n  error: true\n});\nconst DEFAULT = '__default';\nconst DEFAULTS = new Map();\nconst isDiffSet = def => def && !!def.memoized && !!def.changes;\nfunction calculateDpr(dpr) {\n  var _window$devicePixelRa;\n  // Err on the side of progress by assuming 2x dpr if we can't detect it\n  // This will happen in workers where window is defined but dpr isn't.\n  const target = typeof window !== 'undefined' ? (_window$devicePixelRa = window.devicePixelRatio) != null ? _window$devicePixelRa : 2 : 1;\n  return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n\n/**\r\n * Returns instance root state\r\n */\nconst getRootState = obj => {\n  var _r3f;\n  return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n};\n\n/**\r\n * Returns the instances initial (outmost) root\r\n */\nfunction findInitialRoot(child) {\n  let root = child.__r3f.root;\n  while (root.getState().previousRoot) root = root.getState().previousRoot;\n  return root;\n}\n// A collection of compare functions\nconst is = {\n  obj: a => a === Object(a) && !is.arr(a) && typeof a !== 'function',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  boo: a => typeof a === 'boolean',\n  und: a => a === void 0,\n  arr: a => Array.isArray(a),\n  equ(a, b, {\n    arrays = 'shallow',\n    objects = 'reference',\n    strict = true\n  } = {}) {\n    // Wrong type or one of the two undefined, doesn't match\n    if (typeof a !== typeof b || !!a !== !!b) return false;\n    // Atomic, just compare a against b\n    if (is.str(a) || is.num(a) || is.boo(a)) return a === b;\n    const isObj = is.obj(a);\n    if (isObj && objects === 'reference') return a === b;\n    const isArr = is.arr(a);\n    if (isArr && arrays === 'reference') return a === b;\n    // Array or Object, shallow compare first to see if it's a match\n    if ((isArr || isObj) && a === b) return true;\n    // Last resort, go through keys\n    let i;\n    // Check if a has all the keys of b\n    for (i in a) if (!(i in b)) return false;\n    // Check if values between keys match\n    if (isObj && arrays === 'shallow' && objects === 'shallow') {\n      for (i in strict ? b : a) if (!is.equ(a[i], b[i], {\n        strict,\n        objects: 'reference'\n      })) return false;\n    } else {\n      for (i in strict ? b : a) if (a[i] !== b[i]) return false;\n    }\n    // If i is undefined\n    if (is.und(i)) {\n      // If both arrays are empty we consider them equal\n      if (isArr && a.length === 0 && b.length === 0) return true;\n      // If both objects are empty we consider them equal\n      if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n      // Otherwise match them by value\n      if (a !== b) return false;\n    }\n    return true;\n  }\n};\n\n/**\r\n * Collects nodes and materials from a THREE.Object3D.\r\n */\nfunction buildGraph(object) {\n  const data = {\n    nodes: {},\n    materials: {}\n  };\n  if (object) {\n    object.traverse(obj => {\n      if (obj.name) data.nodes[obj.name] = obj;\n      if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n    });\n  }\n  return data;\n}\n\n// Disposes an object and all its properties\nfunction dispose(obj) {\n  if (obj.dispose && obj.type !== 'Scene') obj.dispose();\n  for (const p in obj) {\n    p.dispose == null ? void 0 : p.dispose();\n    delete obj[p];\n  }\n}\n\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(object, state) {\n  const instance = object;\n  instance.__r3f = {\n    type: '',\n    root: null,\n    previousAttach: null,\n    memoizedProps: {},\n    eventCount: 0,\n    handlers: {},\n    objects: [],\n    parent: null,\n    ...state\n  };\n  return object;\n}\nfunction resolve(instance, key) {\n  let target = instance;\n  if (key.includes('-')) {\n    const entries = key.split('-');\n    const last = entries.pop();\n    target = entries.reduce((acc, key) => acc[key], instance);\n    return {\n      target,\n      key: last\n    };\n  } else return {\n    target,\n    key\n  };\n}\n\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child, type) {\n  if (is.str(type)) {\n    // If attaching into an array (foo-0), create one\n    if (INDEX_REGEX.test(type)) {\n      const root = type.replace(INDEX_REGEX, '');\n      const {\n        target,\n        key\n      } = resolve(parent, root);\n      if (!Array.isArray(target[key])) target[key] = [];\n    }\n    const {\n      target,\n      key\n    } = resolve(parent, type);\n    child.__r3f.previousAttach = target[key];\n    target[key] = child;\n  } else child.__r3f.previousAttach = type(parent, child);\n}\nfunction detach(parent, child, type) {\n  var _child$__r3f, _child$__r3f2;\n  if (is.str(type)) {\n    const {\n      target,\n      key\n    } = resolve(parent, type);\n    const previous = child.__r3f.previousAttach;\n    // When the previous value was undefined, it means the value was never set to begin with\n    if (previous === undefined) delete target[key];\n    // Otherwise set the previous value\n    else target[key] = previous;\n  } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);\n  (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, {\n  children: cN,\n  key: kN,\n  ref: rN,\n  ...props\n}, {\n  children: cP,\n  key: kP,\n  ref: rP,\n  ...previous\n} = {}, remove = false) {\n  const localState = instance.__r3f;\n  const entries = Object.entries(props);\n  const changes = [];\n\n  // Catch removed props, prepend them so they can be reset or removed\n  if (remove) {\n    const previousKeys = Object.keys(previous);\n    for (let i = 0; i < previousKeys.length; i++) {\n      if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([previousKeys[i], DEFAULT + 'remove']);\n    }\n  }\n  entries.forEach(([key, value]) => {\n    var _instance$__r3f;\n    // Bail out on primitive object\n    if ((_instance$__r3f = instance.__r3f) != null && _instance$__r3f.primitive && key === 'object') return;\n    // When props match bail out\n    if (is.equ(value, previous[key])) return;\n    // Collect handlers and bail out\n    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([key, value, true, []]);\n    // Split dashed props\n    let entries = [];\n    if (key.includes('-')) entries = key.split('-');\n    changes.push([key, value, false, entries]);\n\n    // Reset pierced props\n    for (const prop in props) {\n      const value = props[prop];\n      if (prop.startsWith(`${key}-`)) changes.push([prop, value, false, prop.split('-')]);\n    }\n  });\n  const memoized = {\n    ...props\n  };\n  if (localState != null && localState.memoizedProps && localState != null && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n  if (localState != null && localState.memoizedProps && localState != null && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n  return {\n    memoized,\n    changes\n  };\n}\nconst __DEV__ = typeof process !== 'undefined' && \"development\" !== 'production';\n\n// This function applies a set of changes to the instance\nfunction applyProps$1(instance, data) {\n  var _instance$__r3f2;\n  // Filter equals, events and reserved props\n  const localState = instance.__r3f;\n  const root = localState == null ? void 0 : localState.root;\n  const rootState = root == null ? void 0 : root.getState == null ? void 0 : root.getState();\n  const {\n    memoized,\n    changes\n  } = isDiffSet(data) ? data : diffProps(instance, data);\n  const prevHandlers = localState == null ? void 0 : localState.eventCount;\n\n  // Prepare memoized props\n  if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n  for (let i = 0; i < changes.length; i++) {\n    let [key, value, isEvent, keys] = changes[i];\n\n    // Alias (output)encoding => (output)colorSpace (since r152)\n    // https://github.com/pmndrs/react-three-fiber/pull/2829\n    if (hasColorSpace(instance)) {\n      const sRGBEncoding = 3001;\n      const SRGBColorSpace = 'srgb';\n      const LinearSRGBColorSpace = 'srgb-linear';\n      if (key === 'encoding') {\n        key = 'colorSpace';\n        value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n      } else if (key === 'outputEncoding') {\n        key = 'outputColorSpace';\n        value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n      }\n    }\n    let currentInstance = instance;\n    let targetProp = currentInstance[key];\n\n    // Revolve dashed props\n    if (keys.length) {\n      targetProp = keys.reduce((acc, key) => acc[key], instance);\n      // If the target is atomic, it forces us to switch the root\n      if (!(targetProp && targetProp.set)) {\n        const [name, ...reverseEntries] = keys.reverse();\n        currentInstance = reverseEntries.reverse().reduce((acc, key) => acc[key], instance);\n        key = name;\n      }\n    }\n\n    // https://github.com/mrdoob/three.js/issues/21209\n    // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n    // has no means to do this. Hence we curate a small collection of value-classes\n    // with their respective constructor/set arguments\n    // For removed props, try to set default values, if possible\n    if (value === DEFAULT + 'remove') {\n      if (currentInstance.constructor) {\n        // create a blank slate of the instance and copy the particular parameter.\n        let ctor = DEFAULTS.get(currentInstance.constructor);\n        if (!ctor) {\n          // @ts-expect-error\n          ctor = new currentInstance.constructor();\n          DEFAULTS.set(currentInstance.constructor, ctor);\n        }\n        value = ctor[key];\n      } else {\n        // instance does not have constructor, just set it to 0\n        value = 0;\n      }\n    }\n\n    // Deal with pointer events ...\n    if (isEvent && localState) {\n      if (value) localState.handlers[key] = value;else delete localState.handlers[key];\n      localState.eventCount = Object.keys(localState.handlers).length;\n    }\n    // Special treatment for objects with support for set/copy, and layers\n    else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof three__WEBPACK_IMPORTED_MODULE_5__.Layers)) {\n      // If value is an array\n      if (Array.isArray(value)) {\n        if (targetProp.fromArray) targetProp.fromArray(value);else targetProp.set(...value);\n      }\n      // Test again target.copy(class) next ...\n      else if (targetProp.copy && value && value.constructor && (\n      // Some environments may break strict identity checks by duplicating versions of three.js.\n      // Loosen to unminified names, ignoring descendents.\n      // https://github.com/pmndrs/react-three-fiber/issues/2856\n      // TODO: fix upstream and remove in v9\n      __DEV__ ? targetProp.constructor.name === value.constructor.name : targetProp.constructor === value.constructor)) {\n        targetProp.copy(value);\n      }\n      // If nothing else fits, just set the single value, ignore undefined\n      // https://github.com/pmndrs/react-three-fiber/issues/274\n      else if (value !== undefined) {\n        const isColor = targetProp instanceof three__WEBPACK_IMPORTED_MODULE_5__.Color;\n        // Allow setting array scalars\n        if (!isColor && targetProp.setScalar) targetProp.setScalar(value);\n        // Layers have no copy function, we must therefore copy the mask property\n        else if (targetProp instanceof three__WEBPACK_IMPORTED_MODULE_5__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_5__.Layers) targetProp.mask = value.mask;\n        // Otherwise just set ...\n        else targetProp.set(value);\n        // For versions of three which don't support THREE.ColorManagement,\n        // Auto-convert sRGB colors\n        // https://github.com/pmndrs/react-three-fiber/issues/344\n        if (!getColorManagement() && rootState && !rootState.linear && isColor) targetProp.convertSRGBToLinear();\n      }\n      // Else, just overwrite the value\n    } else {\n      currentInstance[key] = value;\n\n      // Auto-convert sRGB textures, for now ...\n      // https://github.com/pmndrs/react-three-fiber/issues/344\n      if (currentInstance[key] instanceof three__WEBPACK_IMPORTED_MODULE_5__.Texture &&\n      // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n      currentInstance[key].format === three__WEBPACK_IMPORTED_MODULE_5__.RGBAFormat && currentInstance[key].type === three__WEBPACK_IMPORTED_MODULE_5__.UnsignedByteType && rootState) {\n        const texture = currentInstance[key];\n        if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;else texture.encoding = rootState.gl.outputEncoding;\n      }\n    }\n    invalidateInstance(instance);\n  }\n  if (localState && localState.parent && instance.raycast && prevHandlers !== localState.eventCount) {\n    // Get the initial root state's internals\n    const internal = findInitialRoot(instance).getState().internal;\n    // Pre-emptively remove the instance from the interaction manager\n    const index = internal.interaction.indexOf(instance);\n    if (index > -1) internal.interaction.splice(index, 1);\n    // Add the instance to the interaction manager only when it has handlers\n    if (localState.eventCount) internal.interaction.push(instance);\n  }\n\n  // Call the update lifecycle when it is being updated, but only when it is part of the scene.\n  // Skip updates to the `onUpdate` prop itself\n  const isCircular = changes.length === 1 && changes[0][0] === 'onUpdate';\n  if (!isCircular && changes.length && (_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.parent) updateInstance(instance);\n  return instance;\n}\nfunction invalidateInstance(instance) {\n  var _instance$__r3f3, _instance$__r3f3$root;\n  const state = (_instance$__r3f3 = instance.__r3f) == null ? void 0 : (_instance$__r3f3$root = _instance$__r3f3.root) == null ? void 0 : _instance$__r3f3$root.getState == null ? void 0 : _instance$__r3f3$root.getState();\n  if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateInstance(instance) {\n  instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n}\nfunction updateCamera(camera, size) {\n  // https://github.com/pmndrs/react-three-fiber/issues/92\n  // Do not mess with the camera if it belongs to the user\n  if (!camera.manual) {\n    if (isOrthographicCamera(camera)) {\n      camera.left = size.width / -2;\n      camera.right = size.width / 2;\n      camera.top = size.height / 2;\n      camera.bottom = size.height / -2;\n    } else {\n      camera.aspect = size.width / size.height;\n    }\n    camera.updateProjectionMatrix();\n    // https://github.com/pmndrs/react-three-fiber/issues/178\n    // Update matrix world since the renderer is a frame late\n    camera.updateMatrixWorld();\n  }\n}\n\nfunction makeId(event) {\n  return (event.eventObject || event.object).uuid + '/' + event.index + event.instanceId;\n}\n\n// https://github.com/facebook/react/tree/main/packages/react-reconciler#getcurrenteventpriority\n// Gives React a clue as to how import the current interaction is\nfunction getEventPriority() {\n  var _globalScope$event;\n  // Get a handle to the current global scope in window and worker contexts if able\n  // https://github.com/pmndrs/react-three-fiber/pull/2493\n  const globalScope = typeof self !== 'undefined' && self || typeof window !== 'undefined' && window;\n  if (!globalScope) return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n  const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;\n  switch (name) {\n    case 'click':\n    case 'contextmenu':\n    case 'dblclick':\n    case 'pointercancel':\n    case 'pointerdown':\n    case 'pointerup':\n      return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n    case 'pointermove':\n    case 'pointerout':\n    case 'pointerover':\n    case 'pointerenter':\n    case 'pointerleave':\n    case 'wheel':\n      return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n    default:\n      return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n  }\n}\n\n/**\r\n * Release pointer captures.\r\n * This is called by releasePointerCapture in the API, and when an object is removed.\r\n */\nfunction releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n  const captureData = captures.get(obj);\n  if (captureData) {\n    captures.delete(obj);\n    // If this was the last capturing object for this pointer\n    if (captures.size === 0) {\n      capturedMap.delete(pointerId);\n      captureData.target.releasePointerCapture(pointerId);\n    }\n  }\n}\nfunction removeInteractivity(store, object) {\n  const {\n    internal\n  } = store.getState();\n  // Removes every trace of an object from the data store\n  internal.interaction = internal.interaction.filter(o => o !== object);\n  internal.initialHits = internal.initialHits.filter(o => o !== object);\n  internal.hovered.forEach((value, key) => {\n    if (value.eventObject === object || value.object === object) {\n      // Clear out intersects, they are outdated by now\n      internal.hovered.delete(key);\n    }\n  });\n  internal.capturedMap.forEach((captures, pointerId) => {\n    releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n  });\n}\nfunction createEvents(store) {\n  /** Calculates delta */\n  function calculateDistance(event) {\n    const {\n      internal\n    } = store.getState();\n    const dx = event.offsetX - internal.initialClick[0];\n    const dy = event.offsetY - internal.initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }\n\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n  function filterPointerEvents(objects) {\n    return objects.filter(obj => ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(name => {\n      var _r3f;\n      return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers['onPointer' + name];\n    }));\n  }\n  function intersect(event, filter) {\n    const state = store.getState();\n    const duplicates = new Set();\n    const intersections = [];\n    // Allow callers to eliminate event objects\n    const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n    // Reset all raycaster cameras to undefined\n    for (let i = 0; i < eventsObjects.length; i++) {\n      const state = getRootState(eventsObjects[i]);\n      if (state) {\n        state.raycaster.camera = undefined;\n      }\n    }\n    if (!state.previousRoot) {\n      // Make sure root-level pointer and ray are set up\n      state.events.compute == null ? void 0 : state.events.compute(event, state);\n    }\n    function handleRaycast(obj) {\n      const state = getRootState(obj);\n      // Skip event handling when noEvents is set, or when the raycasters camera is null\n      if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n\n      // When the camera is undefined we have to call the event layers update function\n      if (state.raycaster.camera === undefined) {\n        var _state$previousRoot;\n        state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n        // If the camera is still undefined we have to skip this layer entirely\n        if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n      }\n\n      // Intersect object by object\n      return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n    }\n\n    // Collect events\n    let hits = eventsObjects\n    // Intersect objects\n    .flatMap(handleRaycast)\n    // Sort by event priority and distance\n    .sort((a, b) => {\n      const aState = getRootState(a.object);\n      const bState = getRootState(b.object);\n      if (!aState || !bState) return a.distance - b.distance;\n      return bState.events.priority - aState.events.priority || a.distance - b.distance;\n    })\n    // Filter out duplicates\n    .filter(item => {\n      const id = makeId(item);\n      if (duplicates.has(id)) return false;\n      duplicates.add(id);\n      return true;\n    });\n\n    // https://github.com/mrdoob/three.js/issues/16031\n    // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n    if (state.events.filter) hits = state.events.filter(hits, state);\n\n    // Bubble up the events, find the event source (eventObject)\n    for (const hit of hits) {\n      let eventObject = hit.object;\n      // Bubble event up\n      while (eventObject) {\n        var _r3f2;\n        if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n          ...hit,\n          eventObject\n        });\n        eventObject = eventObject.parent;\n      }\n    }\n\n    // If the interaction is captured, make all capturing targets part of the intersect.\n    if ('pointerId' in event && state.internal.capturedMap.has(event.pointerId)) {\n      for (let captureData of state.internal.capturedMap.get(event.pointerId).values()) {\n        if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n      }\n    }\n    return intersections;\n  }\n\n  /**  Handles intersections by forwarding them to handlers */\n  function handleIntersects(intersections, event, delta, callback) {\n    const rootState = store.getState();\n\n    // If anything has been found, forward it to the event listeners\n    if (intersections.length) {\n      const localState = {\n        stopped: false\n      };\n      for (const hit of intersections) {\n        const state = getRootState(hit.object) || rootState;\n        const {\n          raycaster,\n          pointer,\n          camera,\n          internal\n        } = state;\n        const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n        const hasPointerCapture = id => {\n          var _internal$capturedMap, _internal$capturedMap2;\n          return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n        };\n        const setPointerCapture = id => {\n          const captureData = {\n            intersection: hit,\n            target: event.target\n          };\n          if (internal.capturedMap.has(id)) {\n            // if the pointerId was previously captured, we add the hit to the\n            // event capturedMap.\n            internal.capturedMap.get(id).set(hit.eventObject, captureData);\n          } else {\n            // if the pointerId was not previously captured, we create a map\n            // containing the hitObject, and the hit. hitObject is used for\n            // faster access.\n            internal.capturedMap.set(id, new Map([[hit.eventObject, captureData]]));\n          }\n          event.target.setPointerCapture(id);\n        };\n        const releasePointerCapture = id => {\n          const captures = internal.capturedMap.get(id);\n          if (captures) {\n            releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n          }\n        };\n\n        // Add native event props\n        let extractEventProps = {};\n        // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n        for (let prop in event) {\n          let property = event[prop];\n          // Only copy over atomics, leave functions alone as these should be\n          // called as event.nativeEvent.fn()\n          if (typeof property !== 'function') extractEventProps[prop] = property;\n        }\n        let raycastEvent = {\n          ...hit,\n          ...extractEventProps,\n          pointer,\n          intersections,\n          stopped: localState.stopped,\n          delta,\n          unprojectedPoint,\n          ray: raycaster.ray,\n          camera: camera,\n          // Hijack stopPropagation, which just sets a flag\n          stopPropagation() {\n            // https://github.com/pmndrs/react-three-fiber/issues/596\n            // Events are not allowed to stop propagation if the pointer has been captured\n            const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId);\n\n            // We only authorize stopPropagation...\n            if (\n            // ...if this pointer hasn't been captured\n            !capturesForPointer ||\n            // ... or if the hit object is capturing the pointer\n            capturesForPointer.has(hit.eventObject)) {\n              raycastEvent.stopped = localState.stopped = true;\n              // Propagation is stopped, remove all other hover records\n              // An event handler is only allowed to flush other handlers if it is hovered itself\n              if (internal.hovered.size && Array.from(internal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\n                // Objects cannot flush out higher up objects that have already caught the event\n                const higher = intersections.slice(0, intersections.indexOf(hit));\n                cancelPointer([...higher, hit]);\n              }\n            }\n          },\n          // there should be a distinction between target and currentTarget\n          target: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          currentTarget: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          nativeEvent: event\n        };\n\n        // Call subscribers\n        callback(raycastEvent);\n        // Event bubbling may be interrupted by stopPropagation\n        if (localState.stopped === true) break;\n      }\n    }\n    return intersections;\n  }\n  function cancelPointer(intersections) {\n    const {\n      internal\n    } = store.getState();\n    for (const hoveredObj of internal.hovered.values()) {\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n      if (!intersections.length || !intersections.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n        const eventObject = hoveredObj.eventObject;\n        const instance = eventObject.__r3f;\n        const handlers = instance == null ? void 0 : instance.handlers;\n        internal.hovered.delete(makeId(hoveredObj));\n        if (instance != null && instance.eventCount) {\n          // Clear out intersects, they are outdated by now\n          const data = {\n            ...hoveredObj,\n            intersections\n          };\n          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n        }\n      }\n    }\n  }\n  function pointerMissed(event, objects) {\n    for (let i = 0; i < objects.length; i++) {\n      const instance = objects[i].__r3f;\n      instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n    }\n  }\n  function handlePointer(name) {\n    // Deal with cancelation\n    switch (name) {\n      case 'onPointerLeave':\n      case 'onPointerCancel':\n        return () => cancelPointer([]);\n      case 'onLostPointerCapture':\n        return event => {\n          const {\n            internal\n          } = store.getState();\n          if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n            // If the object event interface had onLostPointerCapture, we'd call it here on every\n            // object that's getting removed. We call it on the next frame because onLostPointerCapture\n            // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n            // happen in the object it originated from, leaving components in a in-between state.\n            requestAnimationFrame(() => {\n              // Only release if pointer-up didn't do it already\n              if (internal.capturedMap.has(event.pointerId)) {\n                internal.capturedMap.delete(event.pointerId);\n                cancelPointer([]);\n              }\n            });\n          }\n        };\n    }\n\n    // Any other pointer goes here ...\n    return function handleEvent(event) {\n      const {\n        onPointerMissed,\n        internal\n      } = store.getState();\n\n      // prepareRay(event)\n      internal.lastEvent.current = event;\n\n      // Get fresh intersects\n      const isPointerMove = name === 'onPointerMove';\n      const isClickEvent = name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick';\n      const filter = isPointerMove ? filterPointerEvents : undefined;\n      const hits = intersect(event, filter);\n      const delta = isClickEvent ? calculateDistance(event) : 0;\n\n      // Save initial coordinates on pointer-down\n      if (name === 'onPointerDown') {\n        internal.initialClick = [event.offsetX, event.offsetY];\n        internal.initialHits = hits.map(hit => hit.eventObject);\n      }\n\n      // If a click yields no results, pass it back to the user as a miss\n      // Missed events have to come first in order to establish user-land side-effect clean up\n      if (isClickEvent && !hits.length) {\n        if (delta <= 2) {\n          pointerMissed(event, internal.interaction);\n          if (onPointerMissed) onPointerMissed(event);\n        }\n      }\n      // Take care of unhover\n      if (isPointerMove) cancelPointer(hits);\n      function onIntersect(data) {\n        const eventObject = data.eventObject;\n        const instance = eventObject.__r3f;\n        const handlers = instance == null ? void 0 : instance.handlers;\n\n        // Check presence of handlers\n        if (!(instance != null && instance.eventCount)) return;\n\n        /*\r\n        MAYBE TODO, DELETE IF NOT: \r\n          Check if the object is captured, captured events should not have intersects running in parallel\r\n          But wouldn't it be better to just replace capturedMap with a single entry?\r\n          Also, are we OK with straight up making picking up multiple objects impossible?\r\n          \r\n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \r\n        if (pointerId !== undefined) {\r\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\r\n          if (capturedMeshSet) {\r\n            const captured = capturedMeshSet.get(eventObject)\r\n            if (captured && captured.localState.stopped) return\r\n          }\r\n        }*/\n\n        if (isPointerMove) {\n          // Move event ...\n          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n            // When enter or out is present take care of hover-state\n            const id = makeId(data);\n            const hoveredItem = internal.hovered.get(id);\n            if (!hoveredItem) {\n              // If the object wasn't previously hovered, book it and call its handler\n              internal.hovered.set(id, data);\n              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n            } else if (hoveredItem.stopped) {\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n              data.stopPropagation();\n            }\n          }\n          // Call mouse move\n          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n        } else {\n          // All other events ...\n          const handler = handlers[name];\n          if (handler) {\n            // Forward all events back to their respective handlers with the exception of click events,\n            // which must use the initial target\n            if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n              // Missed events have to come first\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object)));\n              // Now call the handler\n              handler(data);\n            }\n          } else {\n            // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n            if (isClickEvent && internal.initialHits.includes(eventObject)) {\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object)));\n            }\n          }\n        }\n      }\n      handleIntersects(hits, event, delta, onIntersect);\n    };\n  }\n  return {\n    handlePointer\n  };\n}\n\n// Keys that shouldn't be copied between R3F stores\nconst privateKeys = ['set', 'get', 'setSize', 'setFrameloop', 'setDpr', 'events', 'invalidate', 'advance', 'size', 'viewport'];\nconst isRenderer = def => !!(def != null && def.render);\nconst context = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance) => {\n  const rootState = (0,zustand__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((set, get) => {\n    const position = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n    const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n    const tempTarget = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n    function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n      const {\n        width,\n        height,\n        top,\n        left\n      } = size;\n      const aspect = width / height;\n      if (target instanceof three__WEBPACK_IMPORTED_MODULE_5__.Vector3) tempTarget.copy(target);else tempTarget.set(...target);\n      const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n      if (isOrthographicCamera(camera)) {\n        return {\n          width: width / camera.zoom,\n          height: height / camera.zoom,\n          top,\n          left,\n          factor: 1,\n          distance,\n          aspect\n        };\n      } else {\n        const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n        const h = 2 * Math.tan(fov / 2) * distance; // visible height\n        const w = h * (width / height);\n        return {\n          width: w,\n          height: h,\n          top,\n          left,\n          factor: width / w,\n          distance,\n          aspect\n        };\n      }\n    }\n    let performanceTimeout = undefined;\n    const setPerformanceCurrent = current => set(state => ({\n      performance: {\n        ...state.performance,\n        current\n      }\n    }));\n    const pointer = new three__WEBPACK_IMPORTED_MODULE_5__.Vector2();\n    const rootState = {\n      set,\n      get,\n      // Mock objects that have to be configured\n      gl: null,\n      camera: null,\n      raycaster: null,\n      events: {\n        priority: 1,\n        enabled: true,\n        connected: false\n      },\n      xr: null,\n      scene: null,\n      invalidate: (frames = 1) => invalidate(get(), frames),\n      advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\n      legacy: false,\n      linear: false,\n      flat: false,\n      controls: null,\n      clock: new three__WEBPACK_IMPORTED_MODULE_5__.Clock(),\n      pointer,\n      mouse: pointer,\n      frameloop: 'always',\n      onPointerMissed: undefined,\n      performance: {\n        current: 1,\n        min: 0.5,\n        max: 1,\n        debounce: 200,\n        regress: () => {\n          const state = get();\n          // Clear timeout\n          if (performanceTimeout) clearTimeout(performanceTimeout);\n          // Set lower bound performance\n          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n          // Go back to upper bound performance after a while unless something regresses meanwhile\n          performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\n        }\n      },\n      size: {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        updateStyle: false\n      },\n      viewport: {\n        initialDpr: 0,\n        dpr: 0,\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        aspect: 0,\n        distance: 0,\n        factor: 0,\n        getCurrentViewport\n      },\n      setEvents: events => set(state => ({\n        ...state,\n        events: {\n          ...state.events,\n          ...events\n        }\n      })),\n      setSize: (width, height, updateStyle, top, left) => {\n        const camera = get().camera;\n        const size = {\n          width,\n          height,\n          top: top || 0,\n          left: left || 0,\n          updateStyle\n        };\n        set(state => ({\n          size,\n          viewport: {\n            ...state.viewport,\n            ...getCurrentViewport(camera, defaultTarget, size)\n          }\n        }));\n      },\n      setDpr: dpr => set(state => {\n        const resolved = calculateDpr(dpr);\n        return {\n          viewport: {\n            ...state.viewport,\n            dpr: resolved,\n            initialDpr: state.viewport.initialDpr || resolved\n          }\n        };\n      }),\n      setFrameloop: (frameloop = 'always') => {\n        const clock = get().clock;\n\n        // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n        clock.stop();\n        clock.elapsedTime = 0;\n        if (frameloop !== 'never') {\n          clock.start();\n          clock.elapsedTime = 0;\n        }\n        set(() => ({\n          frameloop\n        }));\n      },\n      previousRoot: undefined,\n      internal: {\n        active: false,\n        priority: 0,\n        frames: 0,\n        lastEvent: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n        interaction: [],\n        hovered: new Map(),\n        subscribers: [],\n        initialClick: [0, 0],\n        initialHits: [],\n        capturedMap: new Map(),\n        subscribe: (ref, priority, store) => {\n          const internal = get().internal;\n          // If this subscription was given a priority, it takes rendering into its own hands\n          // For that reason we switch off automatic rendering and increase the manual flag\n          // As long as this flag is positive there can be no internal rendering at all\n          // because there could be multiple render subscriptions\n          internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n          internal.subscribers.push({\n            ref,\n            priority,\n            store\n          });\n          // Register subscriber and sort layers from lowest to highest, meaning,\n          // highest priority renders last (on top of the other frames)\n          internal.subscribers = internal.subscribers.sort((a, b) => a.priority - b.priority);\n          return () => {\n            const internal = get().internal;\n            if (internal != null && internal.subscribers) {\n              // Decrease manual flag if this subscription had a priority\n              internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n              // Remove subscriber from list\n              internal.subscribers = internal.subscribers.filter(s => s.ref !== ref);\n            }\n          };\n        }\n      }\n    };\n    return rootState;\n  });\n  const state = rootState.getState();\n  let oldSize = state.size;\n  let oldDpr = state.viewport.dpr;\n  let oldCamera = state.camera;\n  rootState.subscribe(() => {\n    const {\n      camera,\n      size,\n      viewport,\n      gl,\n      set\n    } = rootState.getState();\n\n    // Resize camera and renderer on changes to size and pixelratio\n    if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n      var _size$updateStyle;\n      oldSize = size;\n      oldDpr = viewport.dpr;\n      // Update camera & renderer\n      updateCamera(camera, size);\n      gl.setPixelRatio(viewport.dpr);\n      const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== 'undefined' && gl.domElement instanceof HTMLCanvasElement;\n      gl.setSize(size.width, size.height, updateStyle);\n    }\n\n    // Update viewport once the camera changes\n    if (camera !== oldCamera) {\n      oldCamera = camera;\n      // Update viewport\n      set(state => ({\n        viewport: {\n          ...state.viewport,\n          ...state.viewport.getCurrentViewport(camera)\n        }\n      }));\n    }\n  });\n\n  // Invalidate on any change\n  rootState.subscribe(state => invalidate(state));\n\n  // Return root state\n  return rootState;\n};\n\nfunction createSubs(callback, subs) {\n  const sub = {\n    callback\n  };\n  subs.add(sub);\n  return () => void subs.delete(sub);\n}\nlet i;\nlet globalEffects = new Set();\nlet globalAfterEffects = new Set();\nlet globalTailEffects = new Set();\n\n/**\r\n * Adds a global render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\r\n */\nconst addEffect = callback => createSubs(callback, globalEffects);\n\n/**\r\n * Adds a global after-render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\r\n */\nconst addAfterEffect = callback => createSubs(callback, globalAfterEffects);\n\n/**\r\n * Adds a global callback which is called when rendering stops.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\r\n */\nconst addTail = callback => createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n  if (!effects.size) return;\n  for (const {\n    callback\n  } of effects.values()) {\n    callback(timestamp);\n  }\n}\nfunction flushGlobalEffects(type, timestamp) {\n  switch (type) {\n    case 'before':\n      return run(globalEffects, timestamp);\n    case 'after':\n      return run(globalAfterEffects, timestamp);\n    case 'tail':\n      return run(globalTailEffects, timestamp);\n  }\n}\nlet subscribers;\nlet subscription;\nfunction render$1(timestamp, state, frame) {\n  // Run local effects\n  let delta = state.clock.getDelta();\n  // In frameloop='never' mode, clock times are updated using the provided timestamp\n  if (state.frameloop === 'never' && typeof timestamp === 'number') {\n    delta = timestamp - state.clock.elapsedTime;\n    state.clock.oldTime = state.clock.elapsedTime;\n    state.clock.elapsedTime = timestamp;\n  }\n  // Call subscribers (useFrame)\n  subscribers = state.internal.subscribers;\n  for (i = 0; i < subscribers.length; i++) {\n    subscription = subscribers[i];\n    subscription.ref.current(subscription.store.getState(), delta, frame);\n  }\n  // Render content\n  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n  // Decrease frame count\n  state.internal.frames = Math.max(0, state.internal.frames - 1);\n  return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n  let running = false;\n  let useFrameInProgress = false;\n  let repeat;\n  let frame;\n  let state;\n  function loop(timestamp) {\n    frame = requestAnimationFrame(loop);\n    running = true;\n    repeat = 0;\n\n    // Run effects\n    flushGlobalEffects('before', timestamp);\n\n    // Render all roots\n    useFrameInProgress = true;\n    for (const root of roots.values()) {\n      var _state$gl$xr;\n      state = root.store.getState();\n      // If the frameloop is invalidated, do not run another frame\n      if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n        repeat += render$1(timestamp, state);\n      }\n    }\n    useFrameInProgress = false;\n\n    // Run after-effects\n    flushGlobalEffects('after', timestamp);\n\n    // Stop the loop if nothing invalidates it\n    if (repeat === 0) {\n      // Tail call effects, they are called when rendering stops\n      flushGlobalEffects('tail', timestamp);\n\n      // Flag end of operation\n      running = false;\n      return cancelAnimationFrame(frame);\n    }\n  }\n  function invalidate(state, frames = 1) {\n    var _state$gl$xr2;\n    if (!state) return roots.forEach(root => invalidate(root.store.getState(), frames));\n    if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === 'never') return;\n    if (frames > 1) {\n      // legacy support for people using frames parameters\n      // Increase frames, do not go higher than 60\n      state.internal.frames = Math.min(60, state.internal.frames + frames);\n    } else {\n      if (useFrameInProgress) {\n        //called from within a useFrame, it means the user wants an additional frame\n        state.internal.frames = 2;\n      } else {\n        //the user need a new frame, no need to increment further than 1\n        state.internal.frames = 1;\n      }\n    }\n\n    // If the render-loop isn't active, start it\n    if (!running) {\n      running = true;\n      requestAnimationFrame(loop);\n    }\n  }\n  function advance(timestamp, runGlobalEffects = true, state, frame) {\n    if (runGlobalEffects) flushGlobalEffects('before', timestamp);\n    if (!state) for (const root of roots.values()) render$1(timestamp, root.store.getState());else render$1(timestamp, state, frame);\n    if (runGlobalEffects) flushGlobalEffects('after', timestamp);\n  }\n  return {\n    loop,\n    invalidate,\n    advance\n  };\n}\n\n/**\r\n * Exposes an object's {@link LocalState}.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\r\n *\r\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\r\n */\nfunction useInstanceHandle(ref) {\n  const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  useIsomorphicLayoutEffect(() => void (instance.current = ref.current.__r3f), [ref]);\n  return instance;\n}\nfunction useStore() {\n  const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n  if (!store) throw new Error('R3F: Hooks can only be used within the Canvas component!');\n  return store;\n}\n\n/**\r\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\r\n */\nfunction useThree(selector = state => state, equalityFn) {\n  return useStore()(selector, equalityFn);\n}\n\n/**\r\n * Executes a callback before render in a shared frame loop.\r\n * Can order effects with render priority or manually render with a positive priority.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\r\n */\nfunction useFrame(callback, renderPriority = 0) {\n  const store = useStore();\n  const subscribe = store.getState().internal.subscribe;\n  // Memoize ref\n  const ref = useMutableCallback(callback);\n  // Subscribe on mount, unsubscribe on unmount\n  useIsomorphicLayoutEffect(() => subscribe(ref, renderPriority, store), [renderPriority, subscribe, store]);\n  return null;\n}\n\n/**\r\n * Returns a node graph of an object with named nodes & materials.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\r\n */\nfunction useGraph(object) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => buildGraph(object), [object]);\n}\nconst memoizedLoaders = new WeakMap();\nfunction loadingFn(extensions, onProgress) {\n  return function (Proto, ...input) {\n    // Construct new loader and run extensions\n    let loader = memoizedLoaders.get(Proto);\n    if (!loader) {\n      loader = new Proto();\n      memoizedLoaders.set(Proto, loader);\n    }\n    if (extensions) extensions(loader);\n    // Go through the urls and load them\n    return Promise.all(input.map(input => new Promise((res, reject) => loader.load(input, data => {\n      if (data.scene) Object.assign(data, buildGraph(data.scene));\n      res(data);\n    }, onProgress, error => reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`))))));\n  };\n}\n/**\r\n * Synchronously loads and caches assets with a three loader.\r\n *\r\n * Note: this hook's caller must be wrapped with `React.Suspense`\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\r\n */\nfunction useLoader(Proto, input, extensions, onProgress) {\n  // Use suspense to load async assets\n  const keys = Array.isArray(input) ? input : [input];\n  const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_7__.suspend)(loadingFn(extensions, onProgress), [Proto, ...keys], {\n    equal: is.equ\n  });\n  // Return the object/s\n  return Array.isArray(input) ? results : results[0];\n}\n\n/**\r\n * Preloads an asset into cache as a side-effect.\r\n */\nuseLoader.preload = function (Proto, input, extensions) {\n  const keys = Array.isArray(input) ? input : [input];\n  return (0,suspend_react__WEBPACK_IMPORTED_MODULE_7__.preload)(loadingFn(extensions), [Proto, ...keys]);\n};\n\n/**\r\n * Removes a loaded asset from cache.\r\n */\nuseLoader.clear = function (Proto, input) {\n  const keys = Array.isArray(input) ? input : [input];\n  return (0,suspend_react__WEBPACK_IMPORTED_MODULE_7__.clear)([Proto, ...keys]);\n};\n\nconst roots = new Map();\nconst {\n  invalidate,\n  advance\n} = createLoop(roots);\nconst {\n  reconciler,\n  applyProps\n} = createRenderer(roots, getEventPriority);\nconst shallowLoose = {\n  objects: 'shallow',\n  strict: false\n};\nconst createRendererInstance = (gl, canvas) => {\n  const customRenderer = typeof gl === 'function' ? gl(canvas) : gl;\n  if (isRenderer(customRenderer)) return customRenderer;else return new three__WEBPACK_IMPORTED_MODULE_5__.WebGLRenderer({\n    powerPreference: 'high-performance',\n    canvas: canvas,\n    antialias: true,\n    alpha: true,\n    ...gl\n  });\n};\nfunction computeInitialSize(canvas, defaultSize) {\n  const defaultStyle = typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement;\n  if (defaultSize) {\n    const {\n      width,\n      height,\n      top,\n      left,\n      updateStyle = defaultStyle\n    } = defaultSize;\n    return {\n      width,\n      height,\n      top,\n      left,\n      updateStyle\n    };\n  } else if (typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n    const {\n      width,\n      height,\n      top,\n      left\n    } = canvas.parentElement.getBoundingClientRect();\n    return {\n      width,\n      height,\n      top,\n      left,\n      updateStyle: defaultStyle\n    };\n  } else if (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n    return {\n      width: canvas.width,\n      height: canvas.height,\n      top: 0,\n      left: 0,\n      updateStyle: defaultStyle\n    };\n  }\n  return {\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0\n  };\n}\nfunction createRoot(canvas) {\n  // Check against mistaken use of createRoot\n  const prevRoot = roots.get(canvas);\n  const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n  const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n  if (prevRoot) console.warn('R3F.createRoot should only be called once!');\n\n  // Report when an error was detected in a previous render\n  // https://github.com/pmndrs/react-three-fiber/pull/2261\n  const logRecoverableError = typeof reportError === 'function' ?\n  // In modern browsers, reportError will dispatch an error event,\n  // emulating an uncaught JavaScript error.\n  reportError :\n  // In older browsers and test environments, fallback to console.error.\n  console.error;\n\n  // Create store\n  const store = prevStore || createStore(invalidate, advance);\n  // Create renderer\n  const fiber = prevFiber || reconciler.createContainer(store, react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot, null, false, null, '', logRecoverableError, null);\n  // Map it\n  if (!prevRoot) roots.set(canvas, {\n    fiber,\n    store\n  });\n\n  // Locals\n  let onCreated;\n  let configured = false;\n  let lastCamera;\n  return {\n    configure(props = {}) {\n      let {\n        gl: glConfig,\n        size: propsSize,\n        scene: sceneOptions,\n        events,\n        onCreated: onCreatedCallback,\n        shadows = false,\n        linear = false,\n        flat = false,\n        legacy = false,\n        orthographic = false,\n        frameloop = 'always',\n        dpr = [1, 2],\n        performance,\n        raycaster: raycastOptions,\n        camera: cameraOptions,\n        onPointerMissed\n      } = props;\n      let state = store.getState();\n\n      // Set up renderer (one time only!)\n      let gl = state.gl;\n      if (!state.gl) state.set({\n        gl: gl = createRendererInstance(glConfig, canvas)\n      });\n\n      // Set up raycaster (one time only!)\n      let raycaster = state.raycaster;\n      if (!raycaster) state.set({\n        raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_5__.Raycaster()\n      });\n\n      // Set raycaster options\n      const {\n        params,\n        ...options\n      } = raycastOptions || {};\n      if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n        ...options\n      });\n      if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n        params: {\n          ...raycaster.params,\n          ...params\n        }\n      });\n\n      // Create default camera, don't overwrite any user-set state\n      if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n        lastCamera = cameraOptions;\n        const isCamera = cameraOptions instanceof three__WEBPACK_IMPORTED_MODULE_5__.Camera;\n        const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_5__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_5__.PerspectiveCamera(75, 0, 0.1, 1000);\n        if (!isCamera) {\n          camera.position.z = 5;\n          if (cameraOptions) {\n            applyProps(camera, cameraOptions);\n            // Preserve user-defined frustum if possible\n            // https://github.com/pmndrs/react-three-fiber/issues/3160\n            if ('aspect' in cameraOptions || 'left' in cameraOptions || 'right' in cameraOptions || 'bottom' in cameraOptions || 'top' in cameraOptions) {\n              camera.manual = true;\n              camera.updateProjectionMatrix();\n            }\n          }\n          // Always look at center by default\n          if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n        }\n        state.set({\n          camera\n        });\n\n        // Configure raycaster\n        // https://github.com/pmndrs/react-xr/issues/300\n        raycaster.camera = camera;\n      }\n\n      // Set up scene (one time only!)\n      if (!state.scene) {\n        let scene;\n        if (sceneOptions instanceof three__WEBPACK_IMPORTED_MODULE_5__.Scene) {\n          scene = sceneOptions;\n        } else {\n          scene = new three__WEBPACK_IMPORTED_MODULE_5__.Scene();\n          if (sceneOptions) applyProps(scene, sceneOptions);\n        }\n        state.set({\n          scene: prepare(scene)\n        });\n      }\n\n      // Set up XR (one time only!)\n      if (!state.xr) {\n        var _gl$xr;\n        // Handle frame behavior in WebXR\n        const handleXRFrame = (timestamp, frame) => {\n          const state = store.getState();\n          if (state.frameloop === 'never') return;\n          advance(timestamp, true, state, frame);\n        };\n\n        // Toggle render switching on session\n        const handleSessionChange = () => {\n          const state = store.getState();\n          state.gl.xr.enabled = state.gl.xr.isPresenting;\n          state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n          if (!state.gl.xr.isPresenting) invalidate(state);\n        };\n\n        // WebXR session manager\n        const xr = {\n          connect() {\n            const gl = store.getState().gl;\n            gl.xr.addEventListener('sessionstart', handleSessionChange);\n            gl.xr.addEventListener('sessionend', handleSessionChange);\n          },\n          disconnect() {\n            const gl = store.getState().gl;\n            gl.xr.removeEventListener('sessionstart', handleSessionChange);\n            gl.xr.removeEventListener('sessionend', handleSessionChange);\n          }\n        };\n\n        // Subscribe to WebXR session events\n        if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === 'function') xr.connect();\n        state.set({\n          xr\n        });\n      }\n\n      // Set shadowmap\n      if (gl.shadowMap) {\n        const oldEnabled = gl.shadowMap.enabled;\n        const oldType = gl.shadowMap.type;\n        gl.shadowMap.enabled = !!shadows;\n        if (is.boo(shadows)) {\n          gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap;\n        } else if (is.str(shadows)) {\n          var _types$shadows;\n          const types = {\n            basic: three__WEBPACK_IMPORTED_MODULE_5__.BasicShadowMap,\n            percentage: three__WEBPACK_IMPORTED_MODULE_5__.PCFShadowMap,\n            soft: three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap,\n            variance: three__WEBPACK_IMPORTED_MODULE_5__.VSMShadowMap\n          };\n          gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap;\n        } else if (is.obj(shadows)) {\n          Object.assign(gl.shadowMap, shadows);\n        }\n        if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n      }\n\n      // Safely set color management if available.\n      // Avoid accessing THREE.ColorManagement to play nice with older versions\n      const ColorManagement = getColorManagement();\n      if (ColorManagement) {\n        if ('enabled' in ColorManagement) ColorManagement.enabled = !legacy;else if ('legacyMode' in ColorManagement) ColorManagement.legacyMode = legacy;\n      }\n      if (!configured) {\n        // Set color space and tonemapping preferences, once\n        const LinearEncoding = 3000;\n        const sRGBEncoding = 3001;\n        applyProps(gl, {\n          outputEncoding: linear ? LinearEncoding : sRGBEncoding,\n          toneMapping: flat ? three__WEBPACK_IMPORTED_MODULE_5__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_5__.ACESFilmicToneMapping\n        });\n      }\n\n      // Update color management state\n      if (state.legacy !== legacy) state.set(() => ({\n        legacy\n      }));\n      if (state.linear !== linear) state.set(() => ({\n        linear\n      }));\n      if (state.flat !== flat) state.set(() => ({\n        flat\n      }));\n\n      // Set gl props\n      if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n      // Store events internally\n      if (events && !state.events.handlers) state.set({\n        events: events(store)\n      });\n      // Check size, allow it to take on container bounds initially\n      const size = computeInitialSize(canvas, propsSize);\n      if (!is.equ(size, state.size, shallowLoose)) {\n        state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);\n      }\n      // Check pixelratio\n      if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n      // Check frameloop\n      if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n      // Check pointer missed\n      if (!state.onPointerMissed) state.set({\n        onPointerMissed\n      });\n      // Check performance\n      if (performance && !is.equ(performance, state.performance, shallowLoose)) state.set(state => ({\n        performance: {\n          ...state.performance,\n          ...performance\n        }\n      }));\n\n      // Set locals\n      onCreated = onCreatedCallback;\n      configured = true;\n      return this;\n    },\n    render(children) {\n      // The root has to be configured before it can be rendered\n      if (!configured) this.configure();\n      reconciler.updateContainer( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Provider, {\n        store: store,\n        children: children,\n        onCreated: onCreated,\n        rootElement: canvas\n      }), fiber, null, () => undefined);\n      return store;\n    },\n    unmount() {\n      unmountComponentAtNode(canvas);\n    }\n  };\n}\nfunction render(children, canvas, config) {\n  console.warn('R3F.render is no longer supported in React 18. Use createRoot instead!');\n  const root = createRoot(canvas);\n  root.configure(config);\n  return root.render(children);\n}\nfunction Provider({\n  store,\n  children,\n  onCreated,\n  rootElement\n}) {\n  useIsomorphicLayoutEffect(() => {\n    const state = store.getState();\n    // Flag the canvas active, rendering will now begin\n    state.set(state => ({\n      internal: {\n        ...state.internal,\n        active: true\n      }\n    }));\n    // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n    if (onCreated) onCreated(state);\n    // Connect events to the targets parent, this is done to ensure events are registered on\n    // a shared target, and not on the canvas itself\n    if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(context.Provider, {\n    value: store,\n    children: children\n  });\n}\nfunction unmountComponentAtNode(canvas, callback) {\n  const root = roots.get(canvas);\n  const fiber = root == null ? void 0 : root.fiber;\n  if (fiber) {\n    const state = root == null ? void 0 : root.store.getState();\n    if (state) state.internal.active = false;\n    reconciler.updateContainer(null, fiber, null, () => {\n      if (state) {\n        setTimeout(() => {\n          try {\n            var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n            state.events.disconnect == null ? void 0 : state.events.disconnect();\n            (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n            (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n            if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n            dispose(state);\n            roots.delete(canvas);\n            if (callback) callback(canvas);\n          } catch (e) {\n            /* ... */\n          }\n        }, 500);\n      }\n    });\n  }\n}\nfunction createPortal(children, container, state) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Portal, {\n    children: children,\n    container: container,\n    state: state\n  }, container.uuid);\n}\nfunction Portal({\n  state = {},\n  children,\n  container\n}) {\n  /** This has to be a component because it would not be able to call useThree/useStore otherwise since\r\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\r\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\r\n   *  <Canvas>\r\n   *    {createPortal(...)} */\n  const {\n    events,\n    size,\n    ...rest\n  } = state;\n  const previousRoot = useStore();\n  const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new three__WEBPACK_IMPORTED_MODULE_5__.Raycaster());\n  const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new three__WEBPACK_IMPORTED_MODULE_5__.Vector2());\n  const inject = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootState, injectState) => {\n    const intersect = {\n      ...rootState\n    }; // all prev state props\n\n    // Only the fields of \"rootState\" that do not differ from injectState\n    // Some props should be off-limits\n    // Otherwise filter out the props that are different and let the inject layer take precedence\n    Object.keys(rootState).forEach(key => {\n      if (\n      // Some props should be off-limits\n      privateKeys.includes(key) ||\n      // Otherwise filter out the props that are different and let the inject layer take precedence\n      // Unless the inject layer props is undefined, then we keep the root layer\n      rootState[key] !== injectState[key] && injectState[key]) {\n        delete intersect[key];\n      }\n    });\n    let viewport = undefined;\n    if (injectState && size) {\n      const camera = injectState.camera;\n      // Calculate the override viewport, if present\n      viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(), size);\n      // Update the portal camera, if it differs from the previous layer\n      if (camera !== rootState.camera) updateCamera(camera, size);\n    }\n    return {\n      // The intersect consists of the previous root state\n      ...intersect,\n      // Portals have their own scene, which forms the root, a raycaster and a pointer\n      scene: container,\n      raycaster,\n      pointer,\n      mouse: pointer,\n      // Their previous root is the layer before it\n      previousRoot,\n      // Events, size and viewport can be overridden by the inject layer\n      events: {\n        ...rootState.events,\n        ...(injectState == null ? void 0 : injectState.events),\n        ...events\n      },\n      size: {\n        ...rootState.size,\n        ...size\n      },\n      viewport: {\n        ...rootState.viewport,\n        ...viewport\n      },\n      ...rest\n    };\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [state]);\n  const [usePortalStore] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {\n    // Create a mirrored store, based on the previous root with a few overrides ...\n    const previousState = previousRoot.getState();\n    const store = (0,zustand__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((set, get) => ({\n      ...previousState,\n      scene: container,\n      raycaster,\n      pointer,\n      mouse: pointer,\n      previousRoot,\n      events: {\n        ...previousState.events,\n        ...events\n      },\n      size: {\n        ...previousState.size,\n        ...size\n      },\n      ...rest,\n      // Set and get refer to this root-state\n      set,\n      get,\n      // Layers are allowed to override events\n      setEvents: events => set(state => ({\n        ...state,\n        events: {\n          ...state.events,\n          ...events\n        }\n      }))\n    }));\n    return store;\n  });\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n    const unsub = previousRoot.subscribe(prev => usePortalStore.setState(state => inject(prev, state)));\n    return () => {\n      unsub();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [inject]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    usePortalStore.setState(injectState => inject(previousRoot.getState(), injectState));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [inject]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return () => {\n      usePortalStore.destroy();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {\n    children: reconciler.createPortal( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(context.Provider, {\n      value: usePortalStore,\n      children: children\n    }), usePortalStore, null)\n  });\n}\nreconciler.injectIntoDevTools({\n  bundleType:  false ? 0 : 1,\n  rendererPackageName: '@react-three/fiber',\n  version: react__WEBPACK_IMPORTED_MODULE_0__.version\n});\nconst act = react__WEBPACK_IMPORTED_MODULE_0__.unstable_act;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtOTk5ODNiMmQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDQTtBQUNtRztBQUNyRztBQUNhO0FBQ21DO0FBQ3JCO0FBQ047O0FBRWxEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQixzQkFBc0IsRUFBRSxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixpREFBb0IscUNBQXFDLDZCQUE2QiwyQ0FBYztBQUNsSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixxQ0FBcUMsMENBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtVQUErVTtBQUMvVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQiwyQ0FBYztBQUN6QztBQUNBO0FBQ0Esa0JBQWtCLG1EQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLHNEQUFHLENBQUMsdURBQVE7QUFDbEMsb0RBQW9ELHNEQUFHO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLE1BQXFDLEdBQUcsQ0FBQztBQUN2RDtBQUNBLFdBQVcsMENBQWE7QUFDeEIsQ0FBQztBQUNELFlBQVksK0NBQWtCOztBQUV1aEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qYXdhcmEvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtOTk5ODNiMmQuZXNtLmpzPzBkZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGVmYXVsdEV2ZW50UHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5LCBEaXNjcmV0ZUV2ZW50UHJpb3JpdHksIENvbmN1cnJlbnRSb290IH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0IGNyZWF0ZSBmcm9tICd6dXN0YW5kJztcbmltcG9ydCBSZWNvbmNpbGVyIGZyb20gJ3JlYWN0LXJlY29uY2lsZXInO1xuaW1wb3J0IHsgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaywgdW5zdGFibGVfSWRsZVByaW9yaXR5IH0gZnJvbSAnc2NoZWR1bGVyJztcbmltcG9ydCB7IHN1c3BlbmQsIHByZWxvYWQsIGNsZWFyIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG52YXIgdGhyZWVUeXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxuY29uc3QgY2F0YWxvZ3VlID0ge307XG5jb25zdCBleHRlbmQgPSBvYmplY3RzID0+IHZvaWQgT2JqZWN0LmFzc2lnbihjYXRhbG9ndWUsIG9iamVjdHMpO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIoX3Jvb3RzLCBfZ2V0RXZlbnRQcmlvcml0eSkge1xuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh0eXBlLCB7XG4gICAgYXJncyA9IFtdLFxuICAgIGF0dGFjaCxcbiAgICAuLi5wcm9wc1xuICB9LCByb290KSB7XG4gICAgbGV0IG5hbWUgPSBgJHt0eXBlWzBdLnRvVXBwZXJDYXNlKCl9JHt0eXBlLnNsaWNlKDEpfWA7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGlmICh0eXBlID09PSAncHJpbWl0aXZlJykge1xuICAgICAgaWYgKHByb3BzLm9iamVjdCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJSM0Y6IFByaW1pdGl2ZXMgd2l0aG91dCAnb2JqZWN0JyBhcmUgaW52YWxpZCFcIik7XG4gICAgICBjb25zdCBvYmplY3QgPSBwcm9wcy5vYmplY3Q7XG4gICAgICBpbnN0YW5jZSA9IHByZXBhcmUob2JqZWN0LCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJvb3QsXG4gICAgICAgIGF0dGFjaCxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gY2F0YWxvZ3VlW25hbWVdO1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSM0Y6ICR7bmFtZX0gaXMgbm90IHBhcnQgb2YgdGhlIFRIUkVFIG5hbWVzcGFjZSEgRGlkIHlvdSBmb3JnZXQgdG8gZXh0ZW5kPyBTZWU6IGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9vYmplY3RzI3VzaW5nLTNyZC1wYXJ0eS1vYmplY3RzLWRlY2xhcmF0aXZlbHlgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhyb3cgaWYgYW4gb2JqZWN0IG9yIGxpdGVyYWwgd2FzIHBhc3NlZCBmb3IgYXJnc1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MpKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogVGhlIGFyZ3MgcHJvcCBtdXN0IGJlIGFuIGFycmF5IScpO1xuXG4gICAgICAvLyBJbnN0YW5jaWF0ZSBuZXcgb2JqZWN0LCBsaW5rIGl0IHRvIHRoZSByb290XG4gICAgICAvLyBBcHBlbmQgbWVtb2l6ZWQgcHJvcHMgd2l0aCBhcmdzIHNvIGl0J3Mgbm90IGZvcmdvdHRlblxuICAgICAgaW5zdGFuY2UgPSBwcmVwYXJlKG5ldyB0YXJnZXQoLi4uYXJncyksIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgYXR0YWNoLFxuICAgICAgICAvLyBTYXZlIGFyZ3MgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlY29uc3RydWN0IGxhdGVyIGZvciBITVJcbiAgICAgICAgbWVtb2l6ZWRQcm9wczoge1xuICAgICAgICAgIGFyZ3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQXV0by1hdHRhY2ggZ2VvbWV0cmllcyBhbmQgbWF0ZXJpYWxzXG4gICAgaWYgKGluc3RhbmNlLl9fcjNmLmF0dGFjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSkgaW5zdGFuY2UuX19yM2YuYXR0YWNoID0gJ2dlb21ldHJ5JztlbHNlIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFRIUkVFLk1hdGVyaWFsKSBpbnN0YW5jZS5fX3IzZi5hdHRhY2ggPSAnbWF0ZXJpYWwnO1xuICAgIH1cblxuICAgIC8vIEl0IHNob3VsZCBOT1QgY2FsbCBvblVwZGF0ZSBvbiBvYmplY3QgaW5zdGFuY2lhdGlvbiwgYmVjYXVzZSBpdCBoYXNuJ3QgYmVlbiBhZGRlZCB0byB0aGVcbiAgICAvLyB2aWV3IHlldC4gSWYgdGhlIGNhbGxiYWNrIHJlbGllcyBvbiByZWZlcmVuY2VzIGZvciBpbnN0YW5jZSwgdGhleSB3b24ndCBiZSByZWFkeSB5ZXQsIHRoaXMgaXNcbiAgICAvLyB3aHkgaXQgcGFzc2VzIFwidHJ1ZVwiIGhlcmVcbiAgICAvLyBUaGVyZSBpcyBubyByZWFzb24gdG8gYXBwbHkgcHJvcHMgdG8gaW5qZWN0c1xuICAgIGlmIChuYW1lICE9PSAnaW5qZWN0JykgYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9jaGlsZCRfX3IzZiwgX3BhcmVudEluc3RhbmNlJF9fcjNmO1xuICAgICAgLy8gVGhlIGF0dGFjaCBhdHRyaWJ1dGUgaW1wbGllcyB0aGF0IHRoZSBvYmplY3QgYXR0YWNoZXMgaXRzZWxmIG9uIHRoZSBwYXJlbnRcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgLy8gYWRkIGluIHRoZSB1c3VhbCBwYXJlbnQtY2hpbGQgd2F5XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmFkZChjaGlsZCk7XG4gICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaXMgZm9yIGFueXRoaW5nIHRoYXQgdXNlZCBhdHRhY2gsIGFuZCBmb3Igbm9uLU9iamVjdDNEcyB0aGF0IGRvbid0IGdldCBhdHRhY2hlZCB0byBwcm9wcztcbiAgICAgIC8vIHRoYXQgaXMsIGFueXRoaW5nIHRoYXQncyBhIGNoaWxkIGluIFJlYWN0IGJ1dCBub3QgYSBjaGlsZCBpbiB0aGUgc2NlbmVncmFwaC5cbiAgICAgIGlmICghYWRkZWQpIChfcGFyZW50SW5zdGFuY2UkX19yM2YgPSBwYXJlbnRJbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJlbnRJbnN0YW5jZSRfX3IzZi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9jaGlsZCRfX3IzZjIsIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjI7XG4gICAgICBpZiAoKF9jaGlsZCRfX3IzZjIgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2YyLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICAgIGNoaWxkLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdhZGRlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdjaGlsZGFkZGVkJyxcbiAgICAgICAgICBjaGlsZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdFNpYmxpbmdzID0gcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4uZmlsdGVyKHNpYmxpbmcgPT4gc2libGluZyAhPT0gY2hpbGQpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHJlc3RTaWJsaW5ncy5pbmRleE9mKGJlZm9yZUNoaWxkKTtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4gPSBbLi4ucmVzdFNpYmxpbmdzLnNsaWNlKDAsIGluZGV4KSwgY2hpbGQsIC4uLnJlc3RTaWJsaW5ncy5zbGljZShpbmRleCldO1xuICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWFkZGVkKSAoX3BhcmVudEluc3RhbmNlJF9fcjNmMiA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudEluc3RhbmNlJF9fcjNmMi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVSZWN1cnNpdmUoYXJyYXksIHBhcmVudCwgZGlzcG9zZSA9IGZhbHNlKSB7XG4gICAgaWYgKGFycmF5KSBbLi4uYXJyYXldLmZvckVhY2goY2hpbGQgPT4gcmVtb3ZlQ2hpbGQocGFyZW50LCBjaGlsZCwgZGlzcG9zZSkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgZGlzcG9zZSkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjMsIF9jaGlsZCRfX3IzZjMsIF9jaGlsZCRfX3IzZjU7XG4gICAgICAvLyBDbGVhciB0aGUgcGFyZW50IHJlZmVyZW5jZVxuICAgICAgaWYgKGNoaWxkLl9fcjNmKSBjaGlsZC5fX3IzZi5wYXJlbnQgPSBudWxsO1xuICAgICAgLy8gUmVtb3ZlIGNoaWxkIGZyb20gdGhlIHBhcmVudHMgb2JqZWN0c1xuICAgICAgaWYgKChfcGFyZW50SW5zdGFuY2UkX19yM2YzID0gcGFyZW50SW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX3BhcmVudEluc3RhbmNlJF9fcjNmMy5vYmplY3RzKSBwYXJlbnRJbnN0YW5jZS5fX3IzZi5vYmplY3RzID0gcGFyZW50SW5zdGFuY2UuX19yM2Yub2JqZWN0cy5maWx0ZXIoeCA9PiB4ICE9PSBjaGlsZCk7XG4gICAgICAvLyBSZW1vdmUgYXR0YWNobWVudFxuICAgICAgaWYgKChfY2hpbGQkX19yM2YzID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmMy5hdHRhY2gpIHtcbiAgICAgICAgZGV0YWNoKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgY2hpbGQuX19yM2YuYXR0YWNoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQuaXNPYmplY3QzRCAmJiBwYXJlbnRJbnN0YW5jZS5pc09iamVjdDNEKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y0O1xuICAgICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmUoY2hpbGQpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIC8vIFJlbW92ZSBpbnRlcmFjdGl2aXR5IG9uIHRoZSBpbml0aWFsIHJvb3RcbiAgICAgICAgaWYgKChfY2hpbGQkX19yM2Y0ID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmNC5yb290KSB7XG4gICAgICAgICAgcmVtb3ZlSW50ZXJhY3Rpdml0eShmaW5kSW5pdGlhbFJvb3QoY2hpbGQpLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgb2JqZWN0cyB0byBiYWlsIG91dCBvZiByZWN1cnNpdmUgZGlzcG9zZSBhbHRvZ2V0aGVyIGJ5IHBhc3NpbmcgZGlzcG9zZT17bnVsbH1cbiAgICAgIC8vIE5ldmVyIGRpc3Bvc2Ugb2YgcHJpbWl0aXZlcyBiZWNhdXNlIHRoZWlyIHN0YXRlIG1heSBiZSBrZXB0IG91dHNpZGUgb2YgUmVhY3QhXG4gICAgICAvLyBJbiBvcmRlciBmb3IgYW4gb2JqZWN0IHRvIGJlIGFibGUgdG8gZGlzcG9zZSBpdCBoYXMgdG8gaGF2ZVxuICAgICAgLy8gICAtIGEgZGlzcG9zZSBtZXRob2QsXG4gICAgICAvLyAgIC0gaXQgY2Fubm90IGJlIGEgPHByaW1pdGl2ZSBvYmplY3Q9ey4uLn0gLz5cbiAgICAgIC8vICAgLSBpdCBjYW5ub3QgYmUgYSBUSFJFRS5TY2VuZSwgYmVjYXVzZSB0aHJlZSBoYXMgYnJva2VuIGl0J3Mgb3duIGFwaVxuICAgICAgLy9cbiAgICAgIC8vIFNpbmNlIGRpc3Bvc2FsIGlzIHJlY3Vyc2l2ZSwgd2UgY2FuIGNoZWNrIHRoZSBvcHRpb25hbCBkaXNwb3NlIGFyZywgd2hpY2ggd2lsbCBiZSB1bmRlZmluZWRcbiAgICAgIC8vIHdoZW4gdGhlIHJlY29uY2lsZXIgY2FsbHMgaXQsIGJ1dCB0aGVuIGNhcnJ5IG91ciBvd24gY2hlY2sgcmVjdXJzaXZlbHlcbiAgICAgIGNvbnN0IGlzUHJpbWl0aXZlID0gKF9jaGlsZCRfX3IzZjUgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjUucHJpbWl0aXZlO1xuICAgICAgY29uc3Qgc2hvdWxkRGlzcG9zZSA9ICFpc1ByaW1pdGl2ZSAmJiAoZGlzcG9zZSA9PT0gdW5kZWZpbmVkID8gY2hpbGQuZGlzcG9zZSAhPT0gbnVsbCA6IGRpc3Bvc2UpO1xuXG4gICAgICAvLyBSZW1vdmUgbmVzdGVkIGNoaWxkIG9iamVjdHMuIFByaW1pdGl2ZXMgc2hvdWxkIG5vdCBoYXZlIG9iamVjdHMgYW5kIGNoaWxkcmVuIHRoYXQgYXJlXG4gICAgICAvLyBhdHRhY2hlZCB0byB0aGVtIGRlY2xhcmF0aXZlbHkgLi4uXG4gICAgICBpZiAoIWlzUHJpbWl0aXZlKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y2O1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoKF9jaGlsZCRfX3IzZjYgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjYub2JqZWN0cywgY2hpbGQsIHNob3VsZERpc3Bvc2UpO1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoY2hpbGQuY2hpbGRyZW4sIGNoaWxkLCBzaG91bGREaXNwb3NlKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgIGRlbGV0ZSBjaGlsZC5fX3IzZjtcblxuICAgICAgLy8gRGlzcG9zZSBpdGVtIHdoZW5ldmVyIHRoZSByZWNvbmNpbGVyIGZlZWxzIGxpa2UgaXRcbiAgICAgIGlmIChzaG91bGREaXNwb3NlICYmIGNoaWxkLmRpc3Bvc2UgJiYgY2hpbGQudHlwZSAhPT0gJ1NjZW5lJykge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2hpbGQuZGlzcG9zZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIC4uLiAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTY2hlZHVsZSBhc3luYyBhdCBydW50aW1lLCBmbHVzaCBzeW5jIGluIHRlc3RpbmdcbiAgICAgICAgaWYgKHR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayh1bnN0YWJsZV9JZGxlUHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UocGFyZW50SW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzd2l0Y2hJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGZpYmVyKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRfX3IzZjtcbiAgICBjb25zdCBwYXJlbnQgPSAoX2luc3RhbmNlJF9fcjNmID0gaW5zdGFuY2UuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2YucGFyZW50O1xuICAgIGlmICghcGFyZW50KSByZXR1cm47XG4gICAgY29uc3QgbmV3SW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcywgaW5zdGFuY2UuX19yM2Yucm9vdCk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8xMzQ4XG4gICAgLy8gV2hlbiBhcmdzIGNoYW5nZSB0aGUgaW5zdGFuY2UgaGFzIHRvIGJlIHJlLWNvbnN0cnVjdGVkLCB3aGljaCB0aGVuXG4gICAgLy8gZm9yY2VzIHIzZiB0byByZS1wYXJlbnQgdGhlIGNoaWxkcmVuIGFuZCBub24tc2NlbmUgb2JqZWN0c1xuICAgIGlmIChpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQuX19yM2YpIGFwcGVuZENoaWxkKG5ld0luc3RhbmNlLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS5jaGlsZHJlbiA9IGluc3RhbmNlLmNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiAhY2hpbGQuX19yM2YpO1xuICAgIH1cbiAgICBpbnN0YW5jZS5fX3IzZi5vYmplY3RzLmZvckVhY2goY2hpbGQgPT4gYXBwZW5kQ2hpbGQobmV3SW5zdGFuY2UsIGNoaWxkKSk7XG4gICAgaW5zdGFuY2UuX19yM2Yub2JqZWN0cyA9IFtdO1xuICAgIGlmICghaW5zdGFuY2UuX19yM2YuYXV0b1JlbW92ZWRCZWZvcmVBcHBlbmQpIHtcbiAgICAgIHJlbW92ZUNoaWxkKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAobmV3SW5zdGFuY2UucGFyZW50KSB7XG4gICAgICBuZXdJbnN0YW5jZS5fX3IzZi5hdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCA9IHRydWU7XG4gICAgfVxuICAgIGFwcGVuZENoaWxkKHBhcmVudCwgbmV3SW5zdGFuY2UpO1xuXG4gICAgLy8gUmUtYmluZCBldmVudCBoYW5kbGVycyBvbiB0aGUgaW5pdGlhbCByb290XG4gICAgaWYgKG5ld0luc3RhbmNlLnJheWNhc3QgJiYgbmV3SW5zdGFuY2UuX19yM2YuZXZlbnRDb3VudCkge1xuICAgICAgY29uc3Qgcm9vdFN0YXRlID0gZmluZEluaXRpYWxSb290KG5ld0luc3RhbmNlKS5nZXRTdGF0ZSgpO1xuICAgICAgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnB1c2gobmV3SW5zdGFuY2UpO1xuICAgIH1cbiAgICBbZmliZXIsIGZpYmVyLmFsdGVybmF0ZV0uZm9yRWFjaChmaWJlciA9PiB7XG4gICAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIGlmIChmaWJlci5yZWYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpYmVyLnJlZiA9PT0gJ2Z1bmN0aW9uJykgZmliZXIucmVmKG5ld0luc3RhbmNlKTtlbHNlIGZpYmVyLnJlZi5jdXJyZW50ID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIERvbid0IGhhbmRsZSB0ZXh0IGluc3RhbmNlcywgd2FybiBvbiB1bmRlZmluZWQgYmVoYXZpb3JcbiAgY29uc3QgaGFuZGxlVGV4dEluc3RhbmNlID0gKCkgPT4gY29uc29sZS53YXJuKCdUZXh0IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBSM0YgdHJlZSEgVGhpcyBjb3VsZCBiZSBzdHJheSB3aGl0ZXNwYWNlIG9yIGNoYXJhY3RlcnMuJyk7XG4gIGNvbnN0IHJlY29uY2lsZXIgPSBSZWNvbmNpbGVyKHtcbiAgICBjcmVhdGVJbnN0YW5jZSxcbiAgICByZW1vdmVDaGlsZCxcbiAgICBhcHBlbmRDaGlsZCxcbiAgICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICAgIGluc2VydEJlZm9yZSxcbiAgICBzdXBwb3J0c011dGF0aW9uOiB0cnVlLFxuICAgIGlzUHJpbWFyeVJlbmRlcmVyOiBmYWxzZSxcbiAgICBzdXBwb3J0c1BlcnNpc3RlbmNlOiBmYWxzZSxcbiAgICBzdXBwb3J0c0h5ZHJhdGlvbjogZmFsc2UsXG4gICAgbm9UaW1lb3V0OiAtMSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiAoY29udGFpbmVyLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuXG4gICAgICAvLyBEb24ndCBhcHBlbmQgdG8gdW5tb3VudGVkIGNvbnRhaW5lclxuICAgICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZTtcbiAgICAgIGlmICghc2NlbmUuX19yM2YpIHJldHVybjtcblxuICAgICAgLy8gTGluayBjdXJyZW50IHJvb3QgdG8gdGhlIGRlZmF1bHQgc2NlbmVcbiAgICAgIHNjZW5lLl9fcjNmLnJvb3QgPSBjb250YWluZXI7XG4gICAgICBhcHBlbmRDaGlsZChzY2VuZSwgY2hpbGQpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOiAoY29udGFpbmVyLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuICAgICAgcmVtb3ZlQ2hpbGQoY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUsIGNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQgfHwgIWJlZm9yZUNoaWxkKSByZXR1cm47XG5cbiAgICAgIC8vIERvbid0IGFwcGVuZCB0byB1bm1vdW50ZWQgY29udGFpbmVyXG4gICAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lO1xuICAgICAgaWYgKCFzY2VuZS5fX3IzZikgcmV0dXJuO1xuICAgICAgaW5zZXJ0QmVmb3JlKHNjZW5lLCBjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgIH0sXG4gICAgZ2V0Um9vdEhvc3RDb250ZXh0OiAoKSA9PiBudWxsLFxuICAgIGdldENoaWxkSG9zdENvbnRleHQ6IHBhcmVudEhvc3RDb250ZXh0ID0+IHBhcmVudEhvc3RDb250ZXh0LFxuICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGluc3RhbmNlKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmMjtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMiA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjIgOiB7fTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAyNzFcbiAgICAgIC8vIFJldHVybmluZyB0cnVlIHdpbGwgdHJpZ2dlciBjb21taXRNb3VudFxuICAgICAgcmV0dXJuIEJvb2xlYW4obG9jYWxTdGF0ZS5oYW5kbGVycyk7XG4gICAgfSxcbiAgICBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCBfdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmMztcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjMgOiB7fTtcblxuICAgICAgLy8gQ3JlYXRlIGRpZmYtc2V0c1xuICAgICAgaWYgKGxvY2FsU3RhdGUucHJpbWl0aXZlICYmIG5ld1Byb3BzLm9iamVjdCAmJiBuZXdQcm9wcy5vYmplY3QgIT09IGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBbdHJ1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZGF0YSBvYmplY3QsIGxldCdzIGV4dHJhY3QgY3JpdGljYWwgaW5mb3JtYXRpb24gYWJvdXQgaXRcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFyZ3M6IGFyZ3NOZXcgPSBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogY04sXG4gICAgICAgICAgLi4ucmVzdE5ld1xuICAgICAgICB9ID0gbmV3UHJvcHM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhcmdzOiBhcmdzT2xkID0gW10sXG4gICAgICAgICAgY2hpbGRyZW46IGNPLFxuICAgICAgICAgIC4uLnJlc3RPbGRcbiAgICAgICAgfSA9IG9sZFByb3BzO1xuXG4gICAgICAgIC8vIFRocm93IGlmIGFuIG9iamVjdCBvciBsaXRlcmFsIHdhcyBwYXNzZWQgZm9yIGFyZ3NcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3NOZXcpKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogdGhlIGFyZ3MgcHJvcCBtdXN0IGJlIGFuIGFycmF5IScpO1xuXG4gICAgICAgIC8vIElmIGl0IGhhcyBuZXcgcHJvcHMgb3IgYXJndW1lbnRzLCB0aGVuIGl0IG5lZWRzIHRvIGJlIHJlLWluc3RhbnRpYXRlZFxuICAgICAgICBpZiAoYXJnc05ldy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlICE9PSBhcmdzT2xkW2luZGV4XSkpIHJldHVybiBbdHJ1ZV07XG4gICAgICAgIC8vIENyZWF0ZSBhIGRpZmYtc2V0LCBmbGFnIGlmIHRoZXJlIGFyZSBhbnkgY2hhbmdlc1xuICAgICAgICBjb25zdCBkaWZmID0gZGlmZlByb3BzKGluc3RhbmNlLCByZXN0TmV3LCByZXN0T2xkLCB0cnVlKTtcbiAgICAgICAgaWYgKGRpZmYuY2hhbmdlcy5sZW5ndGgpIHJldHVybiBbZmFsc2UsIGRpZmZdO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBkbyBub3QgdG91Y2ggdGhlIGluc3RhbmNlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCBbcmVjb25zdHJ1Y3QsIGRpZmZdLCB0eXBlLCBfb2xkUHJvcHMsIG5ld1Byb3BzLCBmaWJlcikge1xuICAgICAgLy8gUmVjb25zdHJ1Y3Qgd2hlbiBhcmdzIG9yIDxwcmltaXRpdmUgb2JqZWN0PXsuLi59IGhhdmUgY2hhbmdlc1xuICAgICAgaWYgKHJlY29uc3RydWN0KSBzd2l0Y2hJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGZpYmVyKTtcbiAgICAgIC8vIE90aGVyd2lzZSBqdXN0IG92ZXJ3cml0ZSBwcm9wc1xuICAgICAgZWxzZSBhcHBseVByb3BzJDEoaW5zdGFuY2UsIGRpZmYpO1xuICAgIH0sXG4gICAgY29tbWl0TW91bnQoaW5zdGFuY2UsIF90eXBlLCBfcHJvcHMsIF9pbnQpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y0O1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDI3MVxuICAgICAgLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSBldmVudHMgYXJlIG9ubHkgYWRkZWQgb25jZSB0byB0aGUgY2VudHJhbCBjb250YWluZXIgb24gdGhlIGluaXRpYWwgcm9vdFxuICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2Y0ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2Y0IDoge307XG4gICAgICBpZiAoaW5zdGFuY2UucmF5Y2FzdCAmJiBsb2NhbFN0YXRlLmhhbmRsZXJzICYmIGxvY2FsU3RhdGUuZXZlbnRDb3VudCkge1xuICAgICAgICBmaW5kSW5pdGlhbFJvb3QoaW5zdGFuY2UpLmdldFN0YXRlKCkuaW50ZXJuYWwuaW50ZXJhY3Rpb24ucHVzaChpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRQdWJsaWNJbnN0YW5jZTogaW5zdGFuY2UgPT4gaW5zdGFuY2UsXG4gICAgcHJlcGFyZUZvckNvbW1pdDogKCkgPT4gbnVsbCxcbiAgICBwcmVwYXJlUG9ydGFsTW91bnQ6IGNvbnRhaW5lciA9PiBwcmVwYXJlKGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lKSxcbiAgICByZXNldEFmdGVyQ29tbWl0OiAoKSA9PiB7fSxcbiAgICBzaG91bGRTZXRUZXh0Q29udGVudDogKCkgPT4gZmFsc2UsXG4gICAgY2xlYXJDb250YWluZXI6ICgpID0+IGZhbHNlLFxuICAgIGhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjU7XG4gICAgICAvLyBEZXRhY2ggd2hpbGUgdGhlIGluc3RhbmNlIGlzIGhpZGRlblxuICAgICAgY29uc3Qge1xuICAgICAgICBhdHRhY2g6IHR5cGUsXG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IChfaW5zdGFuY2UkX19yM2Y1ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2Y1IDoge307XG4gICAgICBpZiAodHlwZSAmJiBwYXJlbnQpIGRldGFjaChwYXJlbnQsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIGlmIChpbnN0YW5jZS5pc09iamVjdDNEKSBpbnN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIH0sXG4gICAgdW5oaWRlSW5zdGFuY2UoaW5zdGFuY2UsIHByb3BzKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmNjtcbiAgICAgIC8vIFJlLWF0dGFjaCB3aGVuIHRoZSBpbnN0YW5jZSBpcyB1bmhpZGRlblxuICAgICAgY29uc3Qge1xuICAgICAgICBhdHRhY2g6IHR5cGUsXG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IChfaW5zdGFuY2UkX19yM2Y2ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2Y2IDoge307XG4gICAgICBpZiAodHlwZSAmJiBwYXJlbnQpIGF0dGFjaChwYXJlbnQsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIGlmIChpbnN0YW5jZS5pc09iamVjdDNEICYmIHByb3BzLnZpc2libGUgPT0gbnVsbCB8fCBwcm9wcy52aXNpYmxlKSBpbnN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfSxcbiAgICBjcmVhdGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgICBoaWRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gICAgdW5oaWRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIzNjAjZGlzY3Vzc2lvbl9yOTE2MzU2ODc0XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGdldEN1cnJlbnRFdmVudFByaW9yaXR5OiAoKSA9PiBfZ2V0RXZlbnRQcmlvcml0eSA/IF9nZXRFdmVudFByaW9yaXR5KCkgOiBEZWZhdWx0RXZlbnRQcmlvcml0eSxcbiAgICBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXI6ICgpID0+IHt9LFxuICAgIGFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyOiAoKSA9PiB7fSxcbiAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2U6ICgpID0+IHt9LFxuICAgIG5vdzogdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBpcy5mdW4ocGVyZm9ybWFuY2Uubm93KSA/IHBlcmZvcm1hbmNlLm5vdyA6IGlzLmZ1bihEYXRlLm5vdykgPyBEYXRlLm5vdyA6ICgpID0+IDAsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIzNjAjZGlzY3Vzc2lvbl9yOTIwODgzNTAzXG4gICAgc2NoZWR1bGVUaW1lb3V0OiBpcy5mdW4oc2V0VGltZW91dCkgPyBzZXRUaW1lb3V0IDogdW5kZWZpbmVkLFxuICAgIGNhbmNlbFRpbWVvdXQ6IGlzLmZ1bihjbGVhclRpbWVvdXQpID8gY2xlYXJUaW1lb3V0IDogdW5kZWZpbmVkXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJlY29uY2lsZXIsXG4gICAgYXBwbHlQcm9wczogYXBwbHlQcm9wcyQxXG4gIH07XG59XG5cbnZhciBfd2luZG93JGRvY3VtZW50LCBfd2luZG93JG5hdmlnYXRvcjtcbi8qKlxyXG4gKiBSZXR1cm5zIGB0cnVlYCB3aXRoIGNvcnJlY3QgVFMgdHlwZSBpbmZlcmVuY2UgaWYgYW4gb2JqZWN0IGhhcyBhIGNvbmZpZ3VyYWJsZSBjb2xvciBzcGFjZSAoc2luY2UgcjE1MikuXHJcbiAqL1xuY29uc3QgaGFzQ29sb3JTcGFjZSA9IG9iamVjdCA9PiAnY29sb3JTcGFjZScgaW4gb2JqZWN0IHx8ICdvdXRwdXRDb2xvclNwYWNlJyBpbiBvYmplY3Q7XG4vKipcclxuICogVGhlIGN1cnJlbnQgVEhSRUUuQ29sb3JNYW5hZ2VtZW50IGluc3RhbmNlLCBpZiBwcmVzZW50LlxyXG4gKi9cbmNvbnN0IGdldENvbG9yTWFuYWdlbWVudCA9ICgpID0+IHtcbiAgdmFyIF9Db2xvck1hbmFnZW1lbnQ7XG4gIHJldHVybiAoX0NvbG9yTWFuYWdlbWVudCA9IGNhdGFsb2d1ZS5Db2xvck1hbmFnZW1lbnQpICE9IG51bGwgPyBfQ29sb3JNYW5hZ2VtZW50IDogbnVsbDtcbn07XG5jb25zdCBpc09ydGhvZ3JhcGhpY0NhbWVyYSA9IGRlZiA9PiBkZWYgJiYgZGVmLmlzT3J0aG9ncmFwaGljQ2FtZXJhO1xuY29uc3QgaXNSZWYgPSBvYmogPT4gb2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpO1xuXG4vKipcclxuICogQW4gU1NSLWZyaWVuZGx5IHVzZUxheW91dEVmZmVjdC5cclxuICpcclxuICogUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci5cclxuICogVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcclxuICogdXNlTGF5b3V0RWZmZWN0IGVsc2V3aGVyZS5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0OTI3XHJcbiAqL1xuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgoX3dpbmRvdyRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCkgIT0gbnVsbCAmJiBfd2luZG93JGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgfHwgKChfd2luZG93JG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JG5hdmlnYXRvci5wcm9kdWN0KSA9PT0gJ1JlYWN0TmF0aXZlJykgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VNdXRhYmxlQ2FsbGJhY2soZm4pIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKGZuKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB2b2lkIChyZWYuY3VycmVudCA9IGZuKSwgW2ZuXSk7XG4gIHJldHVybiByZWY7XG59XG5mdW5jdGlvbiBCbG9jayh7XG4gIHNldFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBzZXQobmV3IFByb21pc2UoKCkgPT4gbnVsbCkpO1xuICAgIHJldHVybiAoKSA9PiBzZXQoZmFsc2UpO1xuICB9LCBbc2V0XSk7XG4gIHJldHVybiBudWxsO1xufVxuY2xhc3MgRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZXJyb3I6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnIpIHtcbiAgICB0aGlzLnByb3BzLnNldChlcnIpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciA/IG51bGwgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59XG5FcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9ICgpID0+ICh7XG4gIGVycm9yOiB0cnVlXG59KTtcbmNvbnN0IERFRkFVTFQgPSAnX19kZWZhdWx0JztcbmNvbnN0IERFRkFVTFRTID0gbmV3IE1hcCgpO1xuY29uc3QgaXNEaWZmU2V0ID0gZGVmID0+IGRlZiAmJiAhIWRlZi5tZW1vaXplZCAmJiAhIWRlZi5jaGFuZ2VzO1xuZnVuY3Rpb24gY2FsY3VsYXRlRHByKGRwcikge1xuICB2YXIgX3dpbmRvdyRkZXZpY2VQaXhlbFJhO1xuICAvLyBFcnIgb24gdGhlIHNpZGUgb2YgcHJvZ3Jlc3MgYnkgYXNzdW1pbmcgMnggZHByIGlmIHdlIGNhbid0IGRldGVjdCBpdFxuICAvLyBUaGlzIHdpbGwgaGFwcGVuIGluIHdvcmtlcnMgd2hlcmUgd2luZG93IGlzIGRlZmluZWQgYnV0IGRwciBpc24ndC5cbiAgY29uc3QgdGFyZ2V0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoX3dpbmRvdyRkZXZpY2VQaXhlbFJhID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8pICE9IG51bGwgPyBfd2luZG93JGRldmljZVBpeGVsUmEgOiAyIDogMTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZHByKSA/IE1hdGgubWluKE1hdGgubWF4KGRwclswXSwgdGFyZ2V0KSwgZHByWzFdKSA6IGRwcjtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgaW5zdGFuY2Ugcm9vdCBzdGF0ZVxyXG4gKi9cbmNvbnN0IGdldFJvb3RTdGF0ZSA9IG9iaiA9PiB7XG4gIHZhciBfcjNmO1xuICByZXR1cm4gKF9yM2YgPSBvYmouX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfcjNmLnJvb3QuZ2V0U3RhdGUoKTtcbn07XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbnN0YW5jZXMgaW5pdGlhbCAob3V0bW9zdCkgcm9vdFxyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbml0aWFsUm9vdChjaGlsZCkge1xuICBsZXQgcm9vdCA9IGNoaWxkLl9fcjNmLnJvb3Q7XG4gIHdoaWxlIChyb290LmdldFN0YXRlKCkucHJldmlvdXNSb290KSByb290ID0gcm9vdC5nZXRTdGF0ZSgpLnByZXZpb3VzUm9vdDtcbiAgcmV0dXJuIHJvb3Q7XG59XG4vLyBBIGNvbGxlY3Rpb24gb2YgY29tcGFyZSBmdW5jdGlvbnNcbmNvbnN0IGlzID0ge1xuICBvYmo6IGEgPT4gYSA9PT0gT2JqZWN0KGEpICYmICFpcy5hcnIoYSkgJiYgdHlwZW9mIGEgIT09ICdmdW5jdGlvbicsXG4gIGZ1bjogYSA9PiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyxcbiAgc3RyOiBhID0+IHR5cGVvZiBhID09PSAnc3RyaW5nJyxcbiAgbnVtOiBhID0+IHR5cGVvZiBhID09PSAnbnVtYmVyJyxcbiAgYm9vOiBhID0+IHR5cGVvZiBhID09PSAnYm9vbGVhbicsXG4gIHVuZDogYSA9PiBhID09PSB2b2lkIDAsXG4gIGFycjogYSA9PiBBcnJheS5pc0FycmF5KGEpLFxuICBlcXUoYSwgYiwge1xuICAgIGFycmF5cyA9ICdzaGFsbG93JyxcbiAgICBvYmplY3RzID0gJ3JlZmVyZW5jZScsXG4gICAgc3RyaWN0ID0gdHJ1ZVxuICB9ID0ge30pIHtcbiAgICAvLyBXcm9uZyB0eXBlIG9yIG9uZSBvZiB0aGUgdHdvIHVuZGVmaW5lZCwgZG9lc24ndCBtYXRjaFxuICAgIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIgfHwgISFhICE9PSAhIWIpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBdG9taWMsIGp1c3QgY29tcGFyZSBhIGFnYWluc3QgYlxuICAgIGlmIChpcy5zdHIoYSkgfHwgaXMubnVtKGEpIHx8IGlzLmJvbyhhKSkgcmV0dXJuIGEgPT09IGI7XG4gICAgY29uc3QgaXNPYmogPSBpcy5vYmooYSk7XG4gICAgaWYgKGlzT2JqICYmIG9iamVjdHMgPT09ICdyZWZlcmVuY2UnKSByZXR1cm4gYSA9PT0gYjtcbiAgICBjb25zdCBpc0FyciA9IGlzLmFycihhKTtcbiAgICBpZiAoaXNBcnIgJiYgYXJyYXlzID09PSAncmVmZXJlbmNlJykgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gQXJyYXkgb3IgT2JqZWN0LCBzaGFsbG93IGNvbXBhcmUgZmlyc3QgdG8gc2VlIGlmIGl0J3MgYSBtYXRjaFxuICAgIGlmICgoaXNBcnIgfHwgaXNPYmopICYmIGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIC8vIExhc3QgcmVzb3J0LCBnbyB0aHJvdWdoIGtleXNcbiAgICBsZXQgaTtcbiAgICAvLyBDaGVjayBpZiBhIGhhcyBhbGwgdGhlIGtleXMgb2YgYlxuICAgIGZvciAoaSBpbiBhKSBpZiAoIShpIGluIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQ2hlY2sgaWYgdmFsdWVzIGJldHdlZW4ga2V5cyBtYXRjaFxuICAgIGlmIChpc09iaiAmJiBhcnJheXMgPT09ICdzaGFsbG93JyAmJiBvYmplY3RzID09PSAnc2hhbGxvdycpIHtcbiAgICAgIGZvciAoaSBpbiBzdHJpY3QgPyBiIDogYSkgaWYgKCFpcy5lcXUoYVtpXSwgYltpXSwge1xuICAgICAgICBzdHJpY3QsXG4gICAgICAgIG9iamVjdHM6ICdyZWZlcmVuY2UnXG4gICAgICB9KSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgaW4gc3RyaWN0ID8gYiA6IGEpIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIGkgaXMgdW5kZWZpbmVkXG4gICAgaWYgKGlzLnVuZChpKSkge1xuICAgICAgLy8gSWYgYm90aCBhcnJheXMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc0FyciAmJiBhLmxlbmd0aCA9PT0gMCAmJiBiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBJZiBib3RoIG9iamVjdHMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc09iaiAmJiBPYmplY3Qua2V5cyhhKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoYikubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIE90aGVyd2lzZSBtYXRjaCB0aGVtIGJ5IHZhbHVlXG4gICAgICBpZiAoYSAhPT0gYikgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXHJcbiAqIENvbGxlY3RzIG5vZGVzIGFuZCBtYXRlcmlhbHMgZnJvbSBhIFRIUkVFLk9iamVjdDNELlxyXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkR3JhcGgob2JqZWN0KSB7XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgbm9kZXM6IHt9LFxuICAgIG1hdGVyaWFsczoge31cbiAgfTtcbiAgaWYgKG9iamVjdCkge1xuICAgIG9iamVjdC50cmF2ZXJzZShvYmogPT4ge1xuICAgICAgaWYgKG9iai5uYW1lKSBkYXRhLm5vZGVzW29iai5uYW1lXSA9IG9iajtcbiAgICAgIGlmIChvYmoubWF0ZXJpYWwgJiYgIWRhdGEubWF0ZXJpYWxzW29iai5tYXRlcmlhbC5uYW1lXSkgZGF0YS5tYXRlcmlhbHNbb2JqLm1hdGVyaWFsLm5hbWVdID0gb2JqLm1hdGVyaWFsO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vLyBEaXNwb3NlcyBhbiBvYmplY3QgYW5kIGFsbCBpdHMgcHJvcGVydGllc1xuZnVuY3Rpb24gZGlzcG9zZShvYmopIHtcbiAgaWYgKG9iai5kaXNwb3NlICYmIG9iai50eXBlICE9PSAnU2NlbmUnKSBvYmouZGlzcG9zZSgpO1xuICBmb3IgKGNvbnN0IHAgaW4gb2JqKSB7XG4gICAgcC5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBwLmRpc3Bvc2UoKTtcbiAgICBkZWxldGUgb2JqW3BdO1xuICB9XG59XG5cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBzY2VuZSBjYXJyaWVzIGEgc21hbGwgTG9jYWxTdGF0ZSBkZXNjcmlwdG9yXG5mdW5jdGlvbiBwcmVwYXJlKG9iamVjdCwgc3RhdGUpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3Q7XG4gIGluc3RhbmNlLl9fcjNmID0ge1xuICAgIHR5cGU6ICcnLFxuICAgIHJvb3Q6IG51bGwsXG4gICAgcHJldmlvdXNBdHRhY2g6IG51bGwsXG4gICAgbWVtb2l6ZWRQcm9wczoge30sXG4gICAgZXZlbnRDb3VudDogMCxcbiAgICBoYW5kbGVyczoge30sXG4gICAgb2JqZWN0czogW10sXG4gICAgcGFyZW50OiBudWxsLFxuICAgIC4uLnN0YXRlXG4gIH07XG4gIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiByZXNvbHZlKGluc3RhbmNlLCBrZXkpIHtcbiAgbGV0IHRhcmdldCA9IGluc3RhbmNlO1xuICBpZiAoa2V5LmluY2x1ZGVzKCctJykpIHtcbiAgICBjb25zdCBlbnRyaWVzID0ga2V5LnNwbGl0KCctJyk7XG4gICAgY29uc3QgbGFzdCA9IGVudHJpZXMucG9wKCk7XG4gICAgdGFyZ2V0ID0gZW50cmllcy5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgIHJldHVybiB7XG4gICAgICB0YXJnZXQsXG4gICAgICBrZXk6IGxhc3RcbiAgICB9O1xuICB9IGVsc2UgcmV0dXJuIHtcbiAgICB0YXJnZXQsXG4gICAga2V5XG4gIH07XG59XG5cbi8vIENoZWNrcyBpZiBhIGRhc2gtY2FzZWQgc3RyaW5nIGVuZHMgd2l0aCBhbiBpbnRlZ2VyXG5jb25zdCBJTkRFWF9SRUdFWCA9IC8tXFxkKyQvO1xuZnVuY3Rpb24gYXR0YWNoKHBhcmVudCwgY2hpbGQsIHR5cGUpIHtcbiAgaWYgKGlzLnN0cih0eXBlKSkge1xuICAgIC8vIElmIGF0dGFjaGluZyBpbnRvIGFuIGFycmF5IChmb28tMCksIGNyZWF0ZSBvbmVcbiAgICBpZiAoSU5ERVhfUkVHRVgudGVzdCh0eXBlKSkge1xuICAgICAgY29uc3Qgcm9vdCA9IHR5cGUucmVwbGFjZShJTkRFWF9SRUdFWCwgJycpO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGtleVxuICAgICAgfSA9IHJlc29sdmUocGFyZW50LCByb290KTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXRba2V5XSkpIHRhcmdldFtrZXldID0gW107XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKHBhcmVudCwgdHlwZSk7XG4gICAgY2hpbGQuX19yM2YucHJldmlvdXNBdHRhY2ggPSB0YXJnZXRba2V5XTtcbiAgICB0YXJnZXRba2V5XSA9IGNoaWxkO1xuICB9IGVsc2UgY2hpbGQuX19yM2YucHJldmlvdXNBdHRhY2ggPSB0eXBlKHBhcmVudCwgY2hpbGQpO1xufVxuZnVuY3Rpb24gZGV0YWNoKHBhcmVudCwgY2hpbGQsIHR5cGUpIHtcbiAgdmFyIF9jaGlsZCRfX3IzZiwgX2NoaWxkJF9fcjNmMjtcbiAgaWYgKGlzLnN0cih0eXBlKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKHBhcmVudCwgdHlwZSk7XG4gICAgY29uc3QgcHJldmlvdXMgPSBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaDtcbiAgICAvLyBXaGVuIHRoZSBwcmV2aW91cyB2YWx1ZSB3YXMgdW5kZWZpbmVkLCBpdCBtZWFucyB0aGUgdmFsdWUgd2FzIG5ldmVyIHNldCB0byBiZWdpbiB3aXRoXG4gICAgaWYgKHByZXZpb3VzID09PSB1bmRlZmluZWQpIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgICAvLyBPdGhlcndpc2Ugc2V0IHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgIGVsc2UgdGFyZ2V0W2tleV0gPSBwcmV2aW91cztcbiAgfSBlbHNlIChfY2hpbGQkX19yM2YgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZi5wcmV2aW91c0F0dGFjaCA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmLnByZXZpb3VzQXR0YWNoKHBhcmVudCwgY2hpbGQpO1xuICAoX2NoaWxkJF9fcjNmMiA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdHJ1ZSA6IGRlbGV0ZSBfY2hpbGQkX19yM2YyLnByZXZpb3VzQXR0YWNoO1xufVxuLy8gVGhpcyBmdW5jdGlvbiBwcmVwYXJlcyBhIHNldCBvZiBjaGFuZ2VzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGluc3RhbmNlXG5mdW5jdGlvbiBkaWZmUHJvcHMoaW5zdGFuY2UsIHtcbiAgY2hpbGRyZW46IGNOLFxuICBrZXk6IGtOLFxuICByZWY6IHJOLFxuICAuLi5wcm9wc1xufSwge1xuICBjaGlsZHJlbjogY1AsXG4gIGtleToga1AsXG4gIHJlZjogclAsXG4gIC4uLnByZXZpb3VzXG59ID0ge30sIHJlbW92ZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGxvY2FsU3RhdGUgPSBpbnN0YW5jZS5fX3IzZjtcbiAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHByb3BzKTtcbiAgY29uc3QgY2hhbmdlcyA9IFtdO1xuXG4gIC8vIENhdGNoIHJlbW92ZWQgcHJvcHMsIHByZXBlbmQgdGhlbSBzbyB0aGV5IGNhbiBiZSByZXNldCBvciByZW1vdmVkXG4gIGlmIChyZW1vdmUpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleXMgPSBPYmplY3Qua2V5cyhwcmV2aW91cyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2aW91c0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJldmlvdXNLZXlzW2ldKSkgZW50cmllcy51bnNoaWZ0KFtwcmV2aW91c0tleXNbaV0sIERFRkFVTFQgKyAncmVtb3ZlJ10pO1xuICAgIH1cbiAgfVxuICBlbnRyaWVzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIHZhciBfaW5zdGFuY2UkX19yM2Y7XG4gICAgLy8gQmFpbCBvdXQgb24gcHJpbWl0aXZlIG9iamVjdFxuICAgIGlmICgoX2luc3RhbmNlJF9fcjNmID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX2luc3RhbmNlJF9fcjNmLnByaW1pdGl2ZSAmJiBrZXkgPT09ICdvYmplY3QnKSByZXR1cm47XG4gICAgLy8gV2hlbiBwcm9wcyBtYXRjaCBiYWlsIG91dFxuICAgIGlmIChpcy5lcXUodmFsdWUsIHByZXZpb3VzW2tleV0pKSByZXR1cm47XG4gICAgLy8gQ29sbGVjdCBoYW5kbGVycyBhbmQgYmFpbCBvdXRcbiAgICBpZiAoL15vbihQb2ludGVyfENsaWNrfERvdWJsZUNsaWNrfENvbnRleHRNZW51fFdoZWVsKS8udGVzdChrZXkpKSByZXR1cm4gY2hhbmdlcy5wdXNoKFtrZXksIHZhbHVlLCB0cnVlLCBbXV0pO1xuICAgIC8vIFNwbGl0IGRhc2hlZCBwcm9wc1xuICAgIGxldCBlbnRyaWVzID0gW107XG4gICAgaWYgKGtleS5pbmNsdWRlcygnLScpKSBlbnRyaWVzID0ga2V5LnNwbGl0KCctJyk7XG4gICAgY2hhbmdlcy5wdXNoKFtrZXksIHZhbHVlLCBmYWxzZSwgZW50cmllc10pO1xuXG4gICAgLy8gUmVzZXQgcGllcmNlZCBwcm9wc1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wXTtcbiAgICAgIGlmIChwcm9wLnN0YXJ0c1dpdGgoYCR7a2V5fS1gKSkgY2hhbmdlcy5wdXNoKFtwcm9wLCB2YWx1ZSwgZmFsc2UsIHByb3Auc3BsaXQoJy0nKV0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG1lbW9pemVkID0ge1xuICAgIC4uLnByb3BzXG4gIH07XG4gIGlmIChsb2NhbFN0YXRlICE9IG51bGwgJiYgbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzICYmIGxvY2FsU3RhdGUgIT0gbnVsbCAmJiBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXJncykgbWVtb2l6ZWQuYXJncyA9IGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hcmdzO1xuICBpZiAobG9jYWxTdGF0ZSAhPSBudWxsICYmIGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcyAmJiBsb2NhbFN0YXRlICE9IG51bGwgJiYgbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmF0dGFjaCkgbWVtb2l6ZWQuYXR0YWNoID0gbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmF0dGFjaDtcbiAgcmV0dXJuIHtcbiAgICBtZW1vaXplZCxcbiAgICBjaGFuZ2VzXG4gIH07XG59XG5jb25zdCBfX0RFVl9fID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG5cbi8vIFRoaXMgZnVuY3Rpb24gYXBwbGllcyBhIHNldCBvZiBjaGFuZ2VzIHRvIHRoZSBpbnN0YW5jZVxuZnVuY3Rpb24gYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBkYXRhKSB7XG4gIHZhciBfaW5zdGFuY2UkX19yM2YyO1xuICAvLyBGaWx0ZXIgZXF1YWxzLCBldmVudHMgYW5kIHJlc2VydmVkIHByb3BzXG4gIGNvbnN0IGxvY2FsU3RhdGUgPSBpbnN0YW5jZS5fX3IzZjtcbiAgY29uc3Qgcm9vdCA9IGxvY2FsU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY2FsU3RhdGUucm9vdDtcbiAgY29uc3Qgcm9vdFN0YXRlID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5nZXRTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5nZXRTdGF0ZSgpO1xuICBjb25zdCB7XG4gICAgbWVtb2l6ZWQsXG4gICAgY2hhbmdlc1xuICB9ID0gaXNEaWZmU2V0KGRhdGEpID8gZGF0YSA6IGRpZmZQcm9wcyhpbnN0YW5jZSwgZGF0YSk7XG4gIGNvbnN0IHByZXZIYW5kbGVycyA9IGxvY2FsU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY2FsU3RhdGUuZXZlbnRDb3VudDtcblxuICAvLyBQcmVwYXJlIG1lbW9pemVkIHByb3BzXG4gIGlmIChpbnN0YW5jZS5fX3IzZikgaW5zdGFuY2UuX19yM2YubWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgW2tleSwgdmFsdWUsIGlzRXZlbnQsIGtleXNdID0gY2hhbmdlc1tpXTtcblxuICAgIC8vIEFsaWFzIChvdXRwdXQpZW5jb2RpbmcgPT4gKG91dHB1dCljb2xvclNwYWNlIChzaW5jZSByMTUyKVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yODI5XG4gICAgaWYgKGhhc0NvbG9yU3BhY2UoaW5zdGFuY2UpKSB7XG4gICAgICBjb25zdCBzUkdCRW5jb2RpbmcgPSAzMDAxO1xuICAgICAgY29uc3QgU1JHQkNvbG9yU3BhY2UgPSAnc3JnYic7XG4gICAgICBjb25zdCBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9ICdzcmdiLWxpbmVhcic7XG4gICAgICBpZiAoa2V5ID09PSAnZW5jb2RpbmcnKSB7XG4gICAgICAgIGtleSA9ICdjb2xvclNwYWNlJztcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gc1JHQkVuY29kaW5nID8gU1JHQkNvbG9yU3BhY2UgOiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnb3V0cHV0RW5jb2RpbmcnKSB7XG4gICAgICAgIGtleSA9ICdvdXRwdXRDb2xvclNwYWNlJztcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gc1JHQkVuY29kaW5nID8gU1JHQkNvbG9yU3BhY2UgOiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGN1cnJlbnRJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGxldCB0YXJnZXRQcm9wID0gY3VycmVudEluc3RhbmNlW2tleV07XG5cbiAgICAvLyBSZXZvbHZlIGRhc2hlZCBwcm9wc1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgdGFyZ2V0UHJvcCA9IGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIGluc3RhbmNlKTtcbiAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYXRvbWljLCBpdCBmb3JjZXMgdXMgdG8gc3dpdGNoIHRoZSByb290XG4gICAgICBpZiAoISh0YXJnZXRQcm9wICYmIHRhcmdldFByb3Auc2V0KSkge1xuICAgICAgICBjb25zdCBbbmFtZSwgLi4ucmV2ZXJzZUVudHJpZXNdID0ga2V5cy5yZXZlcnNlKCk7XG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IHJldmVyc2VFbnRyaWVzLnJldmVyc2UoKS5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgICAgICBrZXkgPSBuYW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzIxMjA5XG4gICAgLy8gSE1SL2Zhc3QtcmVmcmVzaCByZWxpZXMgb24gdGhlIGFiaWxpdHkgdG8gY2FuY2VsIG91dCBwcm9wcywgYnV0IHRocmVlanNcbiAgICAvLyBoYXMgbm8gbWVhbnMgdG8gZG8gdGhpcy4gSGVuY2Ugd2UgY3VyYXRlIGEgc21hbGwgY29sbGVjdGlvbiBvZiB2YWx1ZS1jbGFzc2VzXG4gICAgLy8gd2l0aCB0aGVpciByZXNwZWN0aXZlIGNvbnN0cnVjdG9yL3NldCBhcmd1bWVudHNcbiAgICAvLyBGb3IgcmVtb3ZlZCBwcm9wcywgdHJ5IHRvIHNldCBkZWZhdWx0IHZhbHVlcywgaWYgcG9zc2libGVcbiAgICBpZiAodmFsdWUgPT09IERFRkFVTFQgKyAncmVtb3ZlJykge1xuICAgICAgaWYgKGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAvLyBjcmVhdGUgYSBibGFuayBzbGF0ZSBvZiB0aGUgaW5zdGFuY2UgYW5kIGNvcHkgdGhlIHBhcnRpY3VsYXIgcGFyYW1ldGVyLlxuICAgICAgICBsZXQgY3RvciA9IERFRkFVTFRTLmdldChjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoIWN0b3IpIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgY3RvciA9IG5ldyBjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IoKTtcbiAgICAgICAgICBERUZBVUxUUy5zZXQoY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yLCBjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGN0b3Jba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluc3RhbmNlIGRvZXMgbm90IGhhdmUgY29uc3RydWN0b3IsIGp1c3Qgc2V0IGl0IHRvIDBcbiAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlYWwgd2l0aCBwb2ludGVyIGV2ZW50cyAuLi5cbiAgICBpZiAoaXNFdmVudCAmJiBsb2NhbFN0YXRlKSB7XG4gICAgICBpZiAodmFsdWUpIGxvY2FsU3RhdGUuaGFuZGxlcnNba2V5XSA9IHZhbHVlO2Vsc2UgZGVsZXRlIGxvY2FsU3RhdGUuaGFuZGxlcnNba2V5XTtcbiAgICAgIGxvY2FsU3RhdGUuZXZlbnRDb3VudCA9IE9iamVjdC5rZXlzKGxvY2FsU3RhdGUuaGFuZGxlcnMpLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gU3BlY2lhbCB0cmVhdG1lbnQgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvciBzZXQvY29weSwgYW5kIGxheWVyc1xuICAgIGVsc2UgaWYgKHRhcmdldFByb3AgJiYgdGFyZ2V0UHJvcC5zZXQgJiYgKHRhcmdldFByb3AuY29weSB8fCB0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzKSkge1xuICAgICAgLy8gSWYgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAodGFyZ2V0UHJvcC5mcm9tQXJyYXkpIHRhcmdldFByb3AuZnJvbUFycmF5KHZhbHVlKTtlbHNlIHRhcmdldFByb3Auc2V0KC4uLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIFRlc3QgYWdhaW4gdGFyZ2V0LmNvcHkoY2xhc3MpIG5leHQgLi4uXG4gICAgICBlbHNlIGlmICh0YXJnZXRQcm9wLmNvcHkgJiYgdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgKFxuICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgbWF5IGJyZWFrIHN0cmljdCBpZGVudGl0eSBjaGVja3MgYnkgZHVwbGljYXRpbmcgdmVyc2lvbnMgb2YgdGhyZWUuanMuXG4gICAgICAvLyBMb29zZW4gdG8gdW5taW5pZmllZCBuYW1lcywgaWdub3JpbmcgZGVzY2VuZGVudHMuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8yODU2XG4gICAgICAvLyBUT0RPOiBmaXggdXBzdHJlYW0gYW5kIHJlbW92ZSBpbiB2OVxuICAgICAgX19ERVZfXyA/IHRhcmdldFByb3AuY29uc3RydWN0b3IubmFtZSA9PT0gdmFsdWUuY29uc3RydWN0b3IubmFtZSA6IHRhcmdldFByb3AuY29uc3RydWN0b3IgPT09IHZhbHVlLmNvbnN0cnVjdG9yKSkge1xuICAgICAgICB0YXJnZXRQcm9wLmNvcHkodmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbm90aGluZyBlbHNlIGZpdHMsIGp1c3Qgc2V0IHRoZSBzaW5nbGUgdmFsdWUsIGlnbm9yZSB1bmRlZmluZWRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzI3NFxuICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBpc0NvbG9yID0gdGFyZ2V0UHJvcCBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yO1xuICAgICAgICAvLyBBbGxvdyBzZXR0aW5nIGFycmF5IHNjYWxhcnNcbiAgICAgICAgaWYgKCFpc0NvbG9yICYmIHRhcmdldFByb3Auc2V0U2NhbGFyKSB0YXJnZXRQcm9wLnNldFNjYWxhcih2YWx1ZSk7XG4gICAgICAgIC8vIExheWVycyBoYXZlIG5vIGNvcHkgZnVuY3Rpb24sIHdlIG11c3QgdGhlcmVmb3JlIGNvcHkgdGhlIG1hc2sgcHJvcGVydHlcbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0UHJvcCBpbnN0YW5jZW9mIFRIUkVFLkxheWVycyAmJiB2YWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkxheWVycykgdGFyZ2V0UHJvcC5tYXNrID0gdmFsdWUubWFzaztcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3Qgc2V0IC4uLlxuICAgICAgICBlbHNlIHRhcmdldFByb3Auc2V0KHZhbHVlKTtcbiAgICAgICAgLy8gRm9yIHZlcnNpb25zIG9mIHRocmVlIHdoaWNoIGRvbid0IHN1cHBvcnQgVEhSRUUuQ29sb3JNYW5hZ2VtZW50LFxuICAgICAgICAvLyBBdXRvLWNvbnZlcnQgc1JHQiBjb2xvcnNcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzQ0XG4gICAgICAgIGlmICghZ2V0Q29sb3JNYW5hZ2VtZW50KCkgJiYgcm9vdFN0YXRlICYmICFyb290U3RhdGUubGluZWFyICYmIGlzQ29sb3IpIHRhcmdldFByb3AuY29udmVydFNSR0JUb0xpbmVhcigpO1xuICAgICAgfVxuICAgICAgLy8gRWxzZSwganVzdCBvdmVyd3JpdGUgdGhlIHZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRJbnN0YW5jZVtrZXldID0gdmFsdWU7XG5cbiAgICAgIC8vIEF1dG8tY29udmVydCBzUkdCIHRleHR1cmVzLCBmb3Igbm93IC4uLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzQ0XG4gICAgICBpZiAoY3VycmVudEluc3RhbmNlW2tleV0gaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICYmXG4gICAgICAvLyBzUkdCIHRleHR1cmVzIG11c3QgYmUgUkdCQTggc2luY2UgcjEzNyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjMxMjlcbiAgICAgIGN1cnJlbnRJbnN0YW5jZVtrZXldLmZvcm1hdCA9PT0gVEhSRUUuUkdCQUZvcm1hdCAmJiBjdXJyZW50SW5zdGFuY2Vba2V5XS50eXBlID09PSBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlICYmIHJvb3RTdGF0ZSkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gY3VycmVudEluc3RhbmNlW2tleV07XG4gICAgICAgIGlmIChoYXNDb2xvclNwYWNlKHRleHR1cmUpICYmIGhhc0NvbG9yU3BhY2Uocm9vdFN0YXRlLmdsKSkgdGV4dHVyZS5jb2xvclNwYWNlID0gcm9vdFN0YXRlLmdsLm91dHB1dENvbG9yU3BhY2U7ZWxzZSB0ZXh0dXJlLmVuY29kaW5nID0gcm9vdFN0YXRlLmdsLm91dHB1dEVuY29kaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICB9XG4gIGlmIChsb2NhbFN0YXRlICYmIGxvY2FsU3RhdGUucGFyZW50ICYmIGluc3RhbmNlLnJheWNhc3QgJiYgcHJldkhhbmRsZXJzICE9PSBsb2NhbFN0YXRlLmV2ZW50Q291bnQpIHtcbiAgICAvLyBHZXQgdGhlIGluaXRpYWwgcm9vdCBzdGF0ZSdzIGludGVybmFsc1xuICAgIGNvbnN0IGludGVybmFsID0gZmluZEluaXRpYWxSb290KGluc3RhbmNlKS5nZXRTdGF0ZSgpLmludGVybmFsO1xuICAgIC8vIFByZS1lbXB0aXZlbHkgcmVtb3ZlIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBpbnRlcmFjdGlvbiBtYW5hZ2VyXG4gICAgY29uc3QgaW5kZXggPSBpbnRlcm5hbC5pbnRlcmFjdGlvbi5pbmRleE9mKGluc3RhbmNlKTtcbiAgICBpZiAoaW5kZXggPiAtMSkgaW50ZXJuYWwuaW50ZXJhY3Rpb24uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAvLyBBZGQgdGhlIGluc3RhbmNlIHRvIHRoZSBpbnRlcmFjdGlvbiBtYW5hZ2VyIG9ubHkgd2hlbiBpdCBoYXMgaGFuZGxlcnNcbiAgICBpZiAobG9jYWxTdGF0ZS5ldmVudENvdW50KSBpbnRlcm5hbC5pbnRlcmFjdGlvbi5wdXNoKGluc3RhbmNlKTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIHVwZGF0ZSBsaWZlY3ljbGUgd2hlbiBpdCBpcyBiZWluZyB1cGRhdGVkLCBidXQgb25seSB3aGVuIGl0IGlzIHBhcnQgb2YgdGhlIHNjZW5lLlxuICAvLyBTa2lwIHVwZGF0ZXMgdG8gdGhlIGBvblVwZGF0ZWAgcHJvcCBpdHNlbGZcbiAgY29uc3QgaXNDaXJjdWxhciA9IGNoYW5nZXMubGVuZ3RoID09PSAxICYmIGNoYW5nZXNbMF1bMF0gPT09ICdvblVwZGF0ZSc7XG4gIGlmICghaXNDaXJjdWxhciAmJiBjaGFuZ2VzLmxlbmd0aCAmJiAoX2luc3RhbmNlJF9fcjNmMiA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsICYmIF9pbnN0YW5jZSRfX3IzZjIucGFyZW50KSB1cGRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICB2YXIgX2luc3RhbmNlJF9fcjNmMywgX2luc3RhbmNlJF9fcjNmMyRyb290O1xuICBjb25zdCBzdGF0ZSA9IChfaW5zdGFuY2UkX19yM2YzID0gaW5zdGFuY2UuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiAoX2luc3RhbmNlJF9fcjNmMyRyb290ID0gX2luc3RhbmNlJF9fcjNmMy5yb290KSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJF9fcjNmMyRyb290LmdldFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2YzJHJvb3QuZ2V0U3RhdGUoKTtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLmludGVybmFsLmZyYW1lcyA9PT0gMCkgc3RhdGUuaW52YWxpZGF0ZSgpO1xufVxuZnVuY3Rpb24gdXBkYXRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2Uub25VcGRhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLm9uVXBkYXRlKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvOTJcbiAgLy8gRG8gbm90IG1lc3Mgd2l0aCB0aGUgY2FtZXJhIGlmIGl0IGJlbG9uZ3MgdG8gdGhlIHVzZXJcbiAgaWYgKCFjYW1lcmEubWFudWFsKSB7XG4gICAgaWYgKGlzT3J0aG9ncmFwaGljQ2FtZXJhKGNhbWVyYSkpIHtcbiAgICAgIGNhbWVyYS5sZWZ0ID0gc2l6ZS53aWR0aCAvIC0yO1xuICAgICAgY2FtZXJhLnJpZ2h0ID0gc2l6ZS53aWR0aCAvIDI7XG4gICAgICBjYW1lcmEudG9wID0gc2l6ZS5oZWlnaHQgLyAyO1xuICAgICAgY2FtZXJhLmJvdHRvbSA9IHNpemUuaGVpZ2h0IC8gLTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbWVyYS5hc3BlY3QgPSBzaXplLndpZHRoIC8gc2l6ZS5oZWlnaHQ7XG4gICAgfVxuICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMTc4XG4gICAgLy8gVXBkYXRlIG1hdHJpeCB3b3JsZCBzaW5jZSB0aGUgcmVuZGVyZXIgaXMgYSBmcmFtZSBsYXRlXG4gICAgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUlkKGV2ZW50KSB7XG4gIHJldHVybiAoZXZlbnQuZXZlbnRPYmplY3QgfHwgZXZlbnQub2JqZWN0KS51dWlkICsgJy8nICsgZXZlbnQuaW5kZXggKyBldmVudC5pbnN0YW5jZUlkO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvdHJlZS9tYWluL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIjZ2V0Y3VycmVudGV2ZW50cHJpb3JpdHlcbi8vIEdpdmVzIFJlYWN0IGEgY2x1ZSBhcyB0byBob3cgaW1wb3J0IHRoZSBjdXJyZW50IGludGVyYWN0aW9uIGlzXG5mdW5jdGlvbiBnZXRFdmVudFByaW9yaXR5KCkge1xuICB2YXIgX2dsb2JhbFNjb3BlJGV2ZW50O1xuICAvLyBHZXQgYSBoYW5kbGUgdG8gdGhlIGN1cnJlbnQgZ2xvYmFsIHNjb3BlIGluIHdpbmRvdyBhbmQgd29ya2VyIGNvbnRleHRzIGlmIGFibGVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzI0OTNcbiAgY29uc3QgZ2xvYmFsU2NvcGUgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiB8fCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3c7XG4gIGlmICghZ2xvYmFsU2NvcGUpIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgY29uc3QgbmFtZSA9IChfZ2xvYmFsU2NvcGUkZXZlbnQgPSBnbG9iYWxTY29wZS5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxTY29wZSRldmVudC50eXBlO1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdjbGljayc6XG4gICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgIGNhc2UgJ2RibGNsaWNrJzpcbiAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICBjYXNlICdwb2ludGVyZG93bic6XG4gICAgY2FzZSAncG9pbnRlcnVwJzpcbiAgICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gICAgY2FzZSAncG9pbnRlcm1vdmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVyZW50ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJsZWF2ZSc6XG4gICAgY2FzZSAnd2hlZWwnOlxuICAgICAgcmV0dXJuIENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFJlbGVhc2UgcG9pbnRlciBjYXB0dXJlcy5cclxuICogVGhpcyBpcyBjYWxsZWQgYnkgcmVsZWFzZVBvaW50ZXJDYXB0dXJlIGluIHRoZSBBUEksIGFuZCB3aGVuIGFuIG9iamVjdCBpcyByZW1vdmVkLlxyXG4gKi9cbmZ1bmN0aW9uIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGNhcHR1cmVkTWFwLCBvYmosIGNhcHR1cmVzLCBwb2ludGVySWQpIHtcbiAgY29uc3QgY2FwdHVyZURhdGEgPSBjYXB0dXJlcy5nZXQob2JqKTtcbiAgaWYgKGNhcHR1cmVEYXRhKSB7XG4gICAgY2FwdHVyZXMuZGVsZXRlKG9iaik7XG4gICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3QgY2FwdHVyaW5nIG9iamVjdCBmb3IgdGhpcyBwb2ludGVyXG4gICAgaWYgKGNhcHR1cmVzLnNpemUgPT09IDApIHtcbiAgICAgIGNhcHR1cmVkTWFwLmRlbGV0ZShwb2ludGVySWQpO1xuICAgICAgY2FwdHVyZURhdGEudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlSW50ZXJhY3Rpdml0eShzdG9yZSwgb2JqZWN0KSB7XG4gIGNvbnN0IHtcbiAgICBpbnRlcm5hbFxuICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgLy8gUmVtb3ZlcyBldmVyeSB0cmFjZSBvZiBhbiBvYmplY3QgZnJvbSB0aGUgZGF0YSBzdG9yZVxuICBpbnRlcm5hbC5pbnRlcmFjdGlvbiA9IGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvID0+IG8gIT09IG9iamVjdCk7XG4gIGludGVybmFsLmluaXRpYWxIaXRzID0gaW50ZXJuYWwuaW5pdGlhbEhpdHMuZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaG92ZXJlZC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKHZhbHVlLmV2ZW50T2JqZWN0ID09PSBvYmplY3QgfHwgdmFsdWUub2JqZWN0ID09PSBvYmplY3QpIHtcbiAgICAgIC8vIENsZWFyIG91dCBpbnRlcnNlY3RzLCB0aGV5IGFyZSBvdXRkYXRlZCBieSBub3dcbiAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9KTtcbiAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZm9yRWFjaCgoY2FwdHVyZXMsIHBvaW50ZXJJZCkgPT4ge1xuICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGludGVybmFsLmNhcHR1cmVkTWFwLCBvYmplY3QsIGNhcHR1cmVzLCBwb2ludGVySWQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50cyhzdG9yZSkge1xuICAvKiogQ2FsY3VsYXRlcyBkZWx0YSAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZShldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZHggPSBldmVudC5vZmZzZXRYIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzBdO1xuICAgIGNvbnN0IGR5ID0gZXZlbnQub2Zmc2V0WSAtIGludGVybmFsLmluaXRpYWxDbGlja1sxXTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgYW4gaW5zdGFuY2UgaGFzIGEgdmFsaWQgcG9pbnRlci1ldmVudCByZWdpc3RlcmVkLCB0aGlzIGV4Y2x1ZGVzIHNjcm9sbCwgY2xpY2tzIGV0YyAqL1xuICBmdW5jdGlvbiBmaWx0ZXJQb2ludGVyRXZlbnRzKG9iamVjdHMpIHtcbiAgICByZXR1cm4gb2JqZWN0cy5maWx0ZXIob2JqID0+IFsnTW92ZScsICdPdmVyJywgJ0VudGVyJywgJ091dCcsICdMZWF2ZSddLnNvbWUobmFtZSA9PiB7XG4gICAgICB2YXIgX3IzZjtcbiAgICAgIHJldHVybiAoX3IzZiA9IG9iai5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9yM2YuaGFuZGxlcnNbJ29uUG9pbnRlcicgKyBuYW1lXTtcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGV2ZW50LCBmaWx0ZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZHVwbGljYXRlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgLy8gQWxsb3cgY2FsbGVycyB0byBlbGltaW5hdGUgZXZlbnQgb2JqZWN0c1xuICAgIGNvbnN0IGV2ZW50c09iamVjdHMgPSBmaWx0ZXIgPyBmaWx0ZXIoc3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24pIDogc3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb247XG4gICAgLy8gUmVzZXQgYWxsIHJheWNhc3RlciBjYW1lcmFzIHRvIHVuZGVmaW5lZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzT2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUoZXZlbnRzT2JqZWN0c1tpXSk7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5wcmV2aW91c1Jvb3QpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSByb290LWxldmVsIHBvaW50ZXIgYW5kIHJheSBhcmUgc2V0IHVwXG4gICAgICBzdGF0ZS5ldmVudHMuY29tcHV0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbXB1dGUoZXZlbnQsIHN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUmF5Y2FzdChvYmopIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0Um9vdFN0YXRlKG9iaik7XG4gICAgICAvLyBTa2lwIGV2ZW50IGhhbmRsaW5nIHdoZW4gbm9FdmVudHMgaXMgc2V0LCBvciB3aGVuIHRoZSByYXljYXN0ZXJzIGNhbWVyYSBpcyBudWxsXG4gICAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5ldmVudHMuZW5hYmxlZCB8fCBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSBudWxsKSByZXR1cm4gW107XG5cbiAgICAgIC8vIFdoZW4gdGhlIGNhbWVyYSBpcyB1bmRlZmluZWQgd2UgaGF2ZSB0byBjYWxsIHRoZSBldmVudCBsYXllcnMgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICBpZiAoc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfc3RhdGUkcHJldmlvdXNSb290O1xuICAgICAgICBzdGF0ZS5ldmVudHMuY29tcHV0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbXB1dGUoZXZlbnQsIHN0YXRlLCAoX3N0YXRlJHByZXZpb3VzUm9vdCA9IHN0YXRlLnByZXZpb3VzUm9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKSk7XG4gICAgICAgIC8vIElmIHRoZSBjYW1lcmEgaXMgc3RpbGwgdW5kZWZpbmVkIHdlIGhhdmUgdG8gc2tpcCB0aGlzIGxheWVyIGVudGlyZWx5XG4gICAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcnNlY3Qgb2JqZWN0IGJ5IG9iamVjdFxuICAgICAgcmV0dXJuIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPyBzdGF0ZS5yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KG9iaiwgdHJ1ZSkgOiBbXTtcbiAgICB9XG5cbiAgICAvLyBDb2xsZWN0IGV2ZW50c1xuICAgIGxldCBoaXRzID0gZXZlbnRzT2JqZWN0c1xuICAgIC8vIEludGVyc2VjdCBvYmplY3RzXG4gICAgLmZsYXRNYXAoaGFuZGxlUmF5Y2FzdClcbiAgICAvLyBTb3J0IGJ5IGV2ZW50IHByaW9yaXR5IGFuZCBkaXN0YW5jZVxuICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBhU3RhdGUgPSBnZXRSb290U3RhdGUoYS5vYmplY3QpO1xuICAgICAgY29uc3QgYlN0YXRlID0gZ2V0Um9vdFN0YXRlKGIub2JqZWN0KTtcbiAgICAgIGlmICghYVN0YXRlIHx8ICFiU3RhdGUpIHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICAgIHJldHVybiBiU3RhdGUuZXZlbnRzLnByaW9yaXR5IC0gYVN0YXRlLmV2ZW50cy5wcmlvcml0eSB8fCBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICB9KVxuICAgIC8vIEZpbHRlciBvdXQgZHVwbGljYXRlc1xuICAgIC5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICBjb25zdCBpZCA9IG1ha2VJZChpdGVtKTtcbiAgICAgIGlmIChkdXBsaWNhdGVzLmhhcyhpZCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGR1cGxpY2F0ZXMuYWRkKGlkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTYwMzFcbiAgICAvLyBBbGxvdyBjdXN0b20gdXNlcmxhbmQgaW50ZXJzZWN0IHNvcnQgb3JkZXIsIHRoaXMgbGlrZWx5IG9ubHkgbWFrZXMgc2Vuc2Ugb24gdGhlIHJvb3QgZmlsdGVyXG4gICAgaWYgKHN0YXRlLmV2ZW50cy5maWx0ZXIpIGhpdHMgPSBzdGF0ZS5ldmVudHMuZmlsdGVyKGhpdHMsIHN0YXRlKTtcblxuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZXZlbnRzLCBmaW5kIHRoZSBldmVudCBzb3VyY2UgKGV2ZW50T2JqZWN0KVxuICAgIGZvciAoY29uc3QgaGl0IG9mIGhpdHMpIHtcbiAgICAgIGxldCBldmVudE9iamVjdCA9IGhpdC5vYmplY3Q7XG4gICAgICAvLyBCdWJibGUgZXZlbnQgdXBcbiAgICAgIHdoaWxlIChldmVudE9iamVjdCkge1xuICAgICAgICB2YXIgX3IzZjI7XG4gICAgICAgIGlmICgoX3IzZjIgPSBldmVudE9iamVjdC5fX3IzZikgIT0gbnVsbCAmJiBfcjNmMi5ldmVudENvdW50KSBpbnRlcnNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICBldmVudE9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRPYmplY3QgPSBldmVudE9iamVjdC5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGludGVyYWN0aW9uIGlzIGNhcHR1cmVkLCBtYWtlIGFsbCBjYXB0dXJpbmcgdGFyZ2V0cyBwYXJ0IG9mIHRoZSBpbnRlcnNlY3QuXG4gICAgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50ICYmIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICBmb3IgKGxldCBjYXB0dXJlRGF0YSBvZiBzdGF0ZS5pbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoZXZlbnQucG9pbnRlcklkKS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoIWR1cGxpY2F0ZXMuaGFzKG1ha2VJZChjYXB0dXJlRGF0YS5pbnRlcnNlY3Rpb24pKSkgaW50ZXJzZWN0aW9ucy5wdXNoKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG5cbiAgLyoqICBIYW5kbGVzIGludGVyc2VjdGlvbnMgYnkgZm9yd2FyZGluZyB0aGVtIHRvIGhhbmRsZXJzICovXG4gIGZ1bmN0aW9uIGhhbmRsZUludGVyc2VjdHMoaW50ZXJzZWN0aW9ucywgZXZlbnQsIGRlbHRhLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb3RTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBJZiBhbnl0aGluZyBoYXMgYmVlbiBmb3VuZCwgZm9yd2FyZCBpdCB0byB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0ge1xuICAgICAgICBzdG9wcGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgaGl0IG9mIGludGVyc2VjdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUoaGl0Lm9iamVjdCkgfHwgcm9vdFN0YXRlO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmF5Y2FzdGVyLFxuICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgY2FtZXJhLFxuICAgICAgICAgIGludGVybmFsXG4gICAgICAgIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgdW5wcm9qZWN0ZWRQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKHBvaW50ZXIueCwgcG9pbnRlci55LCAwKS51bnByb2plY3QoY2FtZXJhKTtcbiAgICAgICAgY29uc3QgaGFzUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgdmFyIF9pbnRlcm5hbCRjYXB0dXJlZE1hcCwgX2ludGVybmFsJGNhcHR1cmVkTWFwMjtcbiAgICAgICAgICByZXR1cm4gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA9IChfaW50ZXJuYWwkY2FwdHVyZWRNYXAyID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIuaGFzKGhpdC5ldmVudE9iamVjdCkpICE9IG51bGwgPyBfaW50ZXJuYWwkY2FwdHVyZWRNYXAgOiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0UG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZURhdGEgPSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb246IGhpdCxcbiAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGlkKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50ZXJJZCB3YXMgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgYWRkIHRoZSBoaXQgdG8gdGhlXG4gICAgICAgICAgICAvLyBldmVudCBjYXB0dXJlZE1hcC5cbiAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCkuc2V0KGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBub3QgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgY3JlYXRlIGEgbWFwXG4gICAgICAgICAgICAvLyBjb250YWluaW5nIHRoZSBoaXRPYmplY3QsIGFuZCB0aGUgaGl0LiBoaXRPYmplY3QgaXMgdXNlZCBmb3JcbiAgICAgICAgICAgIC8vIGZhc3RlciBhY2Nlc3MuXG4gICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5zZXQoaWQsIG5ldyBNYXAoW1toaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVEYXRhXV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVsZWFzZVBvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhcHR1cmVzID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoY2FwdHVyZXMpIHtcbiAgICAgICAgICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGludGVybmFsLmNhcHR1cmVkTWFwLCBoaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVzLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFkZCBuYXRpdmUgZXZlbnQgcHJvcHNcbiAgICAgICAgbGV0IGV4dHJhY3RFdmVudFByb3BzID0ge307XG4gICAgICAgIC8vIFRoaXMgaXRlcmF0ZXMgb3ZlciB0aGUgZXZlbnQncyBwcm9wZXJ0aWVzIGluY2x1ZGluZyB0aGUgaW5oZXJpdGVkIG9uZXMuIE5hdGl2ZSBQb2ludGVyRXZlbnRzIGhhdmUgbW9zdCBvZiB0aGVpciBwcm9wcyBhcyBnZXR0ZXJzIHdoaWNoIGFyZSBpbmhlcml0ZWQsIGJ1dCBwb2x5ZmlsbGVkIFBvaW50ZXJFdmVudHMgaGF2ZSB0aGVtIGFsbCBhcyB0aGVpciBvd24gcHJvcGVydGllcyAoaS5lLiBub3QgaW5oZXJpdGVkKS4gV2UgY2FuJ3QgdXNlIE9iamVjdC5rZXlzKCkgb3IgT2JqZWN0LmVudHJpZXMoKSBhcyB0aGV5IG9ubHkgcmV0dXJuIFwib3duXCIgcHJvcGVydGllczsgbm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkgYXMgdGhhdCAqZG9lc24ndCogcmV0dXJuIFwib3duXCIgcHJvcGVydGllcywgb25seSBpbmhlcml0ZWQgb25lcy5cbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBldmVudCkge1xuICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGV2ZW50W3Byb3BdO1xuICAgICAgICAgIC8vIE9ubHkgY29weSBvdmVyIGF0b21pY3MsIGxlYXZlIGZ1bmN0aW9ucyBhbG9uZSBhcyB0aGVzZSBzaG91bGQgYmVcbiAgICAgICAgICAvLyBjYWxsZWQgYXMgZXZlbnQubmF0aXZlRXZlbnQuZm4oKVxuICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdmdW5jdGlvbicpIGV4dHJhY3RFdmVudFByb3BzW3Byb3BdID0gcHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJheWNhc3RFdmVudCA9IHtcbiAgICAgICAgICAuLi5oaXQsXG4gICAgICAgICAgLi4uZXh0cmFjdEV2ZW50UHJvcHMsXG4gICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zLFxuICAgICAgICAgIHN0b3BwZWQ6IGxvY2FsU3RhdGUuc3RvcHBlZCxcbiAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICB1bnByb2plY3RlZFBvaW50LFxuICAgICAgICAgIHJheTogcmF5Y2FzdGVyLnJheSxcbiAgICAgICAgICBjYW1lcmE6IGNhbWVyYSxcbiAgICAgICAgICAvLyBIaWphY2sgc3RvcFByb3BhZ2F0aW9uLCB3aGljaCBqdXN0IHNldHMgYSBmbGFnXG4gICAgICAgICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvNTk2XG4gICAgICAgICAgICAvLyBFdmVudHMgYXJlIG5vdCBhbGxvd2VkIHRvIHN0b3AgcHJvcGFnYXRpb24gaWYgdGhlIHBvaW50ZXIgaGFzIGJlZW4gY2FwdHVyZWRcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVzRm9yUG9pbnRlciA9ICdwb2ludGVySWQnIGluIGV2ZW50ICYmIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpO1xuXG4gICAgICAgICAgICAvLyBXZSBvbmx5IGF1dGhvcml6ZSBzdG9wUHJvcGFnYXRpb24uLi5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIC4uLmlmIHRoaXMgcG9pbnRlciBoYXNuJ3QgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgIWNhcHR1cmVzRm9yUG9pbnRlciB8fFxuICAgICAgICAgICAgLy8gLi4uIG9yIGlmIHRoZSBoaXQgb2JqZWN0IGlzIGNhcHR1cmluZyB0aGUgcG9pbnRlclxuICAgICAgICAgICAgY2FwdHVyZXNGb3JQb2ludGVyLmhhcyhoaXQuZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHJheWNhc3RFdmVudC5zdG9wcGVkID0gbG9jYWxTdGF0ZS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gUHJvcGFnYXRpb24gaXMgc3RvcHBlZCwgcmVtb3ZlIGFsbCBvdGhlciBob3ZlciByZWNvcmRzXG4gICAgICAgICAgICAgIC8vIEFuIGV2ZW50IGhhbmRsZXIgaXMgb25seSBhbGxvd2VkIHRvIGZsdXNoIG90aGVyIGhhbmRsZXJzIGlmIGl0IGlzIGhvdmVyZWQgaXRzZWxmXG4gICAgICAgICAgICAgIGlmIChpbnRlcm5hbC5ob3ZlcmVkLnNpemUgJiYgQXJyYXkuZnJvbShpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKS5maW5kKGkgPT4gaS5ldmVudE9iamVjdCA9PT0gaGl0LmV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIC8vIE9iamVjdHMgY2Fubm90IGZsdXNoIG91dCBoaWdoZXIgdXAgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBjYXVnaHQgdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgY29uc3QgaGlnaGVyID0gaW50ZXJzZWN0aW9ucy5zbGljZSgwLCBpbnRlcnNlY3Rpb25zLmluZGV4T2YoaGl0KSk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbLi4uaGlnaGVyLCBoaXRdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gdGhlcmUgc2hvdWxkIGJlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB0YXJnZXQgYW5kIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgIGhhc1BvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHtcbiAgICAgICAgICAgIGhhc1BvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmVcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbGwgc3Vic2NyaWJlcnNcbiAgICAgICAgY2FsbGJhY2socmF5Y2FzdEV2ZW50KTtcbiAgICAgICAgLy8gRXZlbnQgYnViYmxpbmcgbWF5IGJlIGludGVycnVwdGVkIGJ5IHN0b3BQcm9wYWdhdGlvblxuICAgICAgICBpZiAobG9jYWxTdGF0ZS5zdG9wcGVkID09PSB0cnVlKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsUG9pbnRlcihpbnRlcnNlY3Rpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBmb3IgKGNvbnN0IGhvdmVyZWRPYmogb2YgaW50ZXJuYWwuaG92ZXJlZC52YWx1ZXMoKSkge1xuICAgICAgLy8gV2hlbiBubyBvYmplY3RzIHdlcmUgaGl0IG9yIHRoZSB0aGUgaG92ZXJlZCBvYmplY3Qgd2Fzbid0IGZvdW5kIHVuZGVybmVhdGggdGhlIGN1cnNvclxuICAgICAgLy8gd2UgY2FsbCBvblBvaW50ZXJPdXQgYW5kIGRlbGV0ZSB0aGUgb2JqZWN0IGZyb20gdGhlIGhvdmVyZWQtZWxlbWVudHMgbWFwXG4gICAgICBpZiAoIWludGVyc2VjdGlvbnMubGVuZ3RoIHx8ICFpbnRlcnNlY3Rpb25zLmZpbmQoaGl0ID0+IGhpdC5vYmplY3QgPT09IGhvdmVyZWRPYmoub2JqZWN0ICYmIGhpdC5pbmRleCA9PT0gaG92ZXJlZE9iai5pbmRleCAmJiBoaXQuaW5zdGFuY2VJZCA9PT0gaG92ZXJlZE9iai5pbnN0YW5jZUlkKSkge1xuICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IGhvdmVyZWRPYmouZXZlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnRPYmplY3QuX19yM2Y7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzO1xuICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLmRlbGV0ZShtYWtlSWQoaG92ZXJlZE9iaikpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5ldmVudENvdW50KSB7XG4gICAgICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAuLi5ob3ZlcmVkT2JqLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uc1xuICAgICAgICAgIH07XG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyT3V0ID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJPdXQoZGF0YSk7XG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyTGVhdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlckxlYXZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJNaXNzZWQoZXZlbnQsIG9iamVjdHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gb2JqZWN0c1tpXS5fX3IzZjtcbiAgICAgIGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycy5vblBvaW50ZXJNaXNzZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXIobmFtZSkge1xuICAgIC8vIERlYWwgd2l0aCBjYW5jZWxhdGlvblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnb25Qb2ludGVyTGVhdmUnOlxuICAgICAgY2FzZSAnb25Qb2ludGVyQ2FuY2VsJzpcbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbFBvaW50ZXIoW10pO1xuICAgICAgY2FzZSAnb25Mb3N0UG9pbnRlckNhcHR1cmUnOlxuICAgICAgICByZXR1cm4gZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGludGVybmFsXG4gICAgICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50ICYmIGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGV2ZW50IGludGVyZmFjZSBoYWQgb25Mb3N0UG9pbnRlckNhcHR1cmUsIHdlJ2QgY2FsbCBpdCBoZXJlIG9uIGV2ZXJ5XG4gICAgICAgICAgICAvLyBvYmplY3QgdGhhdCdzIGdldHRpbmcgcmVtb3ZlZC4gV2UgY2FsbCBpdCBvbiB0aGUgbmV4dCBmcmFtZSBiZWNhdXNlIG9uTG9zdFBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgICAvLyBmaXJlcyBiZWZvcmUgb25Qb2ludGVyVXAuIE90aGVyd2lzZSBwb2ludGVyVXAgd291bGQgbmV2ZXIgYmUgY2FsbGVkIGlmIHRoZSBldmVudCBkaWRuJ3RcbiAgICAgICAgICAgIC8vIGhhcHBlbiBpbiB0aGUgb2JqZWN0IGl0IG9yaWdpbmF0ZWQgZnJvbSwgbGVhdmluZyBjb21wb25lbnRzIGluIGEgaW4tYmV0d2VlbiBzdGF0ZS5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgcmVsZWFzZSBpZiBwb2ludGVyLXVwIGRpZG4ndCBkbyBpdCBhbHJlYWR5XG4gICAgICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmRlbGV0ZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgICAgIGNhbmNlbFBvaW50ZXIoW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQW55IG90aGVyIHBvaW50ZXIgZ29lcyBoZXJlIC4uLlxuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvblBvaW50ZXJNaXNzZWQsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gcHJlcGFyZVJheShldmVudClcbiAgICAgIGludGVybmFsLmxhc3RFdmVudC5jdXJyZW50ID0gZXZlbnQ7XG5cbiAgICAgIC8vIEdldCBmcmVzaCBpbnRlcnNlY3RzXG4gICAgICBjb25zdCBpc1BvaW50ZXJNb3ZlID0gbmFtZSA9PT0gJ29uUG9pbnRlck1vdmUnO1xuICAgICAgY29uc3QgaXNDbGlja0V2ZW50ID0gbmFtZSA9PT0gJ29uQ2xpY2snIHx8IG5hbWUgPT09ICdvbkNvbnRleHRNZW51JyB8fCBuYW1lID09PSAnb25Eb3VibGVDbGljayc7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBpc1BvaW50ZXJNb3ZlID8gZmlsdGVyUG9pbnRlckV2ZW50cyA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGhpdHMgPSBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcik7XG4gICAgICBjb25zdCBkZWx0YSA9IGlzQ2xpY2tFdmVudCA/IGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSA6IDA7XG5cbiAgICAgIC8vIFNhdmUgaW5pdGlhbCBjb29yZGluYXRlcyBvbiBwb2ludGVyLWRvd25cbiAgICAgIGlmIChuYW1lID09PSAnb25Qb2ludGVyRG93bicpIHtcbiAgICAgICAgaW50ZXJuYWwuaW5pdGlhbENsaWNrID0gW2V2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFldO1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsSGl0cyA9IGhpdHMubWFwKGhpdCA9PiBoaXQuZXZlbnRPYmplY3QpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhIGNsaWNrIHlpZWxkcyBubyByZXN1bHRzLCBwYXNzIGl0IGJhY2sgdG8gdGhlIHVzZXIgYXMgYSBtaXNzXG4gICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdCBpbiBvcmRlciB0byBlc3RhYmxpc2ggdXNlci1sYW5kIHNpZGUtZWZmZWN0IGNsZWFuIHVwXG4gICAgICBpZiAoaXNDbGlja0V2ZW50ICYmICFoaXRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoZGVsdGEgPD0gMikge1xuICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uKTtcbiAgICAgICAgICBpZiAob25Qb2ludGVyTWlzc2VkKSBvblBvaW50ZXJNaXNzZWQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUYWtlIGNhcmUgb2YgdW5ob3ZlclxuICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIGNhbmNlbFBvaW50ZXIoaGl0cyk7XG4gICAgICBmdW5jdGlvbiBvbkludGVyc2VjdChkYXRhKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gZGF0YS5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBldmVudE9iamVjdC5fX3IzZjtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnM7XG5cbiAgICAgICAgLy8gQ2hlY2sgcHJlc2VuY2Ugb2YgaGFuZGxlcnNcbiAgICAgICAgaWYgKCEoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5ldmVudENvdW50KSkgcmV0dXJuO1xuXG4gICAgICAgIC8qXHJcbiAgICAgICAgTUFZQkUgVE9ETywgREVMRVRFIElGIE5PVDogXHJcbiAgICAgICAgICBDaGVjayBpZiB0aGUgb2JqZWN0IGlzIGNhcHR1cmVkLCBjYXB0dXJlZCBldmVudHMgc2hvdWxkIG5vdCBoYXZlIGludGVyc2VjdHMgcnVubmluZyBpbiBwYXJhbGxlbFxyXG4gICAgICAgICAgQnV0IHdvdWxkbid0IGl0IGJlIGJldHRlciB0byBqdXN0IHJlcGxhY2UgY2FwdHVyZWRNYXAgd2l0aCBhIHNpbmdsZSBlbnRyeT9cclxuICAgICAgICAgIEFsc28sIGFyZSB3ZSBPSyB3aXRoIHN0cmFpZ2h0IHVwIG1ha2luZyBwaWNraW5nIHVwIG11bHRpcGxlIG9iamVjdHMgaW1wb3NzaWJsZT9cclxuICAgICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHBvaW50ZXJJZCA9IChkYXRhIGFzIFRocmVlRXZlbnQ8UG9pbnRlckV2ZW50PikucG9pbnRlcklkICAgICAgICBcclxuICAgICAgICBpZiAocG9pbnRlcklkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGNhcHR1cmVkTWVzaFNldCA9IGludGVybmFsLmNhcHR1cmVkTWFwLmdldChwb2ludGVySWQpXHJcbiAgICAgICAgICBpZiAoY2FwdHVyZWRNZXNoU2V0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVkID0gY2FwdHVyZWRNZXNoU2V0LmdldChldmVudE9iamVjdClcclxuICAgICAgICAgICAgaWYgKGNhcHR1cmVkICYmIGNhcHR1cmVkLmxvY2FsU3RhdGUuc3RvcHBlZCkgcmV0dXJuXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIHtcbiAgICAgICAgICAvLyBNb3ZlIGV2ZW50IC4uLlxuICAgICAgICAgIGlmIChoYW5kbGVycy5vblBvaW50ZXJPdmVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlckVudGVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlck91dCB8fCBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSkge1xuICAgICAgICAgICAgLy8gV2hlbiBlbnRlciBvciBvdXQgaXMgcHJlc2VudCB0YWtlIGNhcmUgb2YgaG92ZXItc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZEl0ZW0gPSBpbnRlcm5hbC5ob3ZlcmVkLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoIWhvdmVyZWRJdGVtKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2Fzbid0IHByZXZpb3VzbHkgaG92ZXJlZCwgYm9vayBpdCBhbmQgY2FsbCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLnNldChpZCwgZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck92ZXIoZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlckVudGVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJFbnRlcihkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0uc3RvcHBlZCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhcyBwcmV2aW91c2x5IGhvdmVyZWQgYW5kIHN0b3BwZWQsIHdlIHNob3VsZG4ndCBhbGxvdyBvdGhlciBpdGVtcyB0byBwcm9jZWVkXG4gICAgICAgICAgICAgIGRhdGEuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhbGwgbW91c2UgbW92ZVxuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck1vdmUoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxsIG90aGVyIGV2ZW50cyAuLi5cbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIEZvcndhcmQgYWxsIGV2ZW50cyBiYWNrIHRvIHRoZWlyIHJlc3BlY3RpdmUgaGFuZGxlcnMgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGNsaWNrIGV2ZW50cyxcbiAgICAgICAgICAgIC8vIHdoaWNoIG11c3QgdXNlIHRoZSBpbml0aWFsIHRhcmdldFxuICAgICAgICAgICAgaWYgKCFpc0NsaWNrRXZlbnQgfHwgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgICAgLy8gTm93IGNhbGwgdGhlIGhhbmRsZXJcbiAgICAgICAgICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBvblBvaW50ZXJNaXNzZWQgb24gYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBwb2ludGVyIG92ZXIvb3V0IGhhbmRsZXJzLCBidXQgbm90IGNsaWNrIGFuZCB3ZXJlbid0IGhpdFxuICAgICAgICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiBpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG9iamVjdCA9PiAhaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMob2JqZWN0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlSW50ZXJzZWN0cyhoaXRzLCBldmVudCwgZGVsdGEsIG9uSW50ZXJzZWN0KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFuZGxlUG9pbnRlclxuICB9O1xufVxuXG4vLyBLZXlzIHRoYXQgc2hvdWxkbid0IGJlIGNvcGllZCBiZXR3ZWVuIFIzRiBzdG9yZXNcbmNvbnN0IHByaXZhdGVLZXlzID0gWydzZXQnLCAnZ2V0JywgJ3NldFNpemUnLCAnc2V0RnJhbWVsb29wJywgJ3NldERwcicsICdldmVudHMnLCAnaW52YWxpZGF0ZScsICdhZHZhbmNlJywgJ3NpemUnLCAndmlld3BvcnQnXTtcbmNvbnN0IGlzUmVuZGVyZXIgPSBkZWYgPT4gISEoZGVmICE9IG51bGwgJiYgZGVmLnJlbmRlcik7XG5jb25zdCBjb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBjcmVhdGVTdG9yZSA9IChpbnZhbGlkYXRlLCBhZHZhbmNlKSA9PiB7XG4gIGNvbnN0IHJvb3RTdGF0ZSA9IGNyZWF0ZSgoc2V0LCBnZXQpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgZGVmYXVsdFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgdGVtcFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSA9IGdldCgpLmNhbWVyYSwgdGFyZ2V0ID0gZGVmYXVsdFRhcmdldCwgc2l6ZSA9IGdldCgpLnNpemUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdG9wLFxuICAgICAgICBsZWZ0XG4gICAgICB9ID0gc2l6ZTtcbiAgICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMpIHRlbXBUYXJnZXQuY29weSh0YXJnZXQpO2Vsc2UgdGVtcFRhcmdldC5zZXQoLi4udGFyZ2V0KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gY2FtZXJhLmdldFdvcmxkUG9zaXRpb24ocG9zaXRpb24pLmRpc3RhbmNlVG8odGVtcFRhcmdldCk7XG4gICAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC8gY2FtZXJhLnpvb20sXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgZmFjdG9yOiAxLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm92ID0gY2FtZXJhLmZvdiAqIE1hdGguUEkgLyAxODA7IC8vIGNvbnZlcnQgdmVydGljYWwgZm92IHRvIHJhZGlhbnNcbiAgICAgICAgY29uc3QgaCA9IDIgKiBNYXRoLnRhbihmb3YgLyAyKSAqIGRpc3RhbmNlOyAvLyB2aXNpYmxlIGhlaWdodFxuICAgICAgICBjb25zdCB3ID0gaCAqICh3aWR0aCAvIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3Rvcjogd2lkdGggLyB3LFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcGVyZm9ybWFuY2VUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNldFBlcmZvcm1hbmNlQ3VycmVudCA9IGN1cnJlbnQgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgY3VycmVudFxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBwb2ludGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICBjb25zdCByb290U3RhdGUgPSB7XG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBNb2NrIG9iamVjdHMgdGhhdCBoYXZlIHRvIGJlIGNvbmZpZ3VyZWRcbiAgICAgIGdsOiBudWxsLFxuICAgICAgY2FtZXJhOiBudWxsLFxuICAgICAgcmF5Y2FzdGVyOiBudWxsLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIHByaW9yaXR5OiAxLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgeHI6IG51bGwsXG4gICAgICBzY2VuZTogbnVsbCxcbiAgICAgIGludmFsaWRhdGU6IChmcmFtZXMgPSAxKSA9PiBpbnZhbGlkYXRlKGdldCgpLCBmcmFtZXMpLFxuICAgICAgYWR2YW5jZTogKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cykgPT4gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMsIGdldCgpKSxcbiAgICAgIGxlZ2FjeTogZmFsc2UsXG4gICAgICBsaW5lYXI6IGZhbHNlLFxuICAgICAgZmxhdDogZmFsc2UsXG4gICAgICBjb250cm9sczogbnVsbCxcbiAgICAgIGNsb2NrOiBuZXcgVEhSRUUuQ2xvY2soKSxcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIGZyYW1lbG9vcDogJ2Fsd2F5cycsXG4gICAgICBvblBvaW50ZXJNaXNzZWQ6IHVuZGVmaW5lZCxcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIGN1cnJlbnQ6IDEsXG4gICAgICAgIG1pbjogMC41LFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIGRlYm91bmNlOiAyMDAsXG4gICAgICAgIHJlZ3Jlc3M6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXRcbiAgICAgICAgICBpZiAocGVyZm9ybWFuY2VUaW1lb3V0KSBjbGVhclRpbWVvdXQocGVyZm9ybWFuY2VUaW1lb3V0KTtcbiAgICAgICAgICAvLyBTZXQgbG93ZXIgYm91bmQgcGVyZm9ybWFuY2VcbiAgICAgICAgICBpZiAoc3RhdGUucGVyZm9ybWFuY2UuY3VycmVudCAhPT0gc3RhdGUucGVyZm9ybWFuY2UubWluKSBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoc3RhdGUucGVyZm9ybWFuY2UubWluKTtcbiAgICAgICAgICAvLyBHbyBiYWNrIHRvIHVwcGVyIGJvdW5kIHBlcmZvcm1hbmNlIGFmdGVyIGEgd2hpbGUgdW5sZXNzIHNvbWV0aGluZyByZWdyZXNzZXMgbWVhbndoaWxlXG4gICAgICAgICAgcGVyZm9ybWFuY2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoZ2V0KCkucGVyZm9ybWFuY2UubWF4KSwgc3RhdGUucGVyZm9ybWFuY2UuZGVib3VuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHVwZGF0ZVN0eWxlOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGluaXRpYWxEcHI6IDAsXG4gICAgICAgIGRwcjogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBhc3BlY3Q6IDAsXG4gICAgICAgIGRpc3RhbmNlOiAwLFxuICAgICAgICBmYWN0b3I6IDAsXG4gICAgICAgIGdldEN1cnJlbnRWaWV3cG9ydFxuICAgICAgfSxcbiAgICAgIHNldEV2ZW50czogZXZlbnRzID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KSksXG4gICAgICBzZXRTaXplOiAod2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUsIHRvcCwgbGVmdCkgPT4ge1xuICAgICAgICBjb25zdCBjYW1lcmEgPSBnZXQoKS5jYW1lcmE7XG4gICAgICAgIGNvbnN0IHNpemUgPSB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIHRvcDogdG9wIHx8IDAsXG4gICAgICAgICAgbGVmdDogbGVmdCB8fCAwLFxuICAgICAgICAgIHVwZGF0ZVN0eWxlXG4gICAgICAgIH07XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgLi4uZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSwgZGVmYXVsdFRhcmdldCwgc2l6ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBzZXREcHI6IGRwciA9PiBzZXQoc3RhdGUgPT4ge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IGNhbGN1bGF0ZURwcihkcHIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAgIGRwcjogcmVzb2x2ZWQsXG4gICAgICAgICAgICBpbml0aWFsRHByOiBzdGF0ZS52aWV3cG9ydC5pbml0aWFsRHByIHx8IHJlc29sdmVkXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBzZXRGcmFtZWxvb3A6IChmcmFtZWxvb3AgPSAnYWx3YXlzJykgPT4ge1xuICAgICAgICBjb25zdCBjbG9jayA9IGdldCgpLmNsb2NrO1xuXG4gICAgICAgIC8vIGlmIGZyYW1lbG9vcCA9PT0gXCJuZXZlclwiIGNsb2NrLmVsYXBzZWRUaW1lIGlzIHVwZGF0ZWQgdXNpbmcgYWR2YW5jZSh0aW1lc3RhbXApXG4gICAgICAgIGNsb2NrLnN0b3AoKTtcbiAgICAgICAgY2xvY2suZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICBpZiAoZnJhbWVsb29wICE9PSAnbmV2ZXInKSB7XG4gICAgICAgICAgY2xvY2suc3RhcnQoKTtcbiAgICAgICAgICBjbG9jay5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KCgpID0+ICh7XG4gICAgICAgICAgZnJhbWVsb29wXG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBwcmV2aW91c1Jvb3Q6IHVuZGVmaW5lZCxcbiAgICAgIGludGVybmFsOiB7XG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICBmcmFtZXM6IDAsXG4gICAgICAgIGxhc3RFdmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpLFxuICAgICAgICBpbnRlcmFjdGlvbjogW10sXG4gICAgICAgIGhvdmVyZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuICAgICAgICBpbml0aWFsQ2xpY2s6IFswLCAwXSxcbiAgICAgICAgaW5pdGlhbEhpdHM6IFtdLFxuICAgICAgICBjYXB0dXJlZE1hcDogbmV3IE1hcCgpLFxuICAgICAgICBzdWJzY3JpYmU6IChyZWYsIHByaW9yaXR5LCBzdG9yZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGludGVybmFsID0gZ2V0KCkuaW50ZXJuYWw7XG4gICAgICAgICAgLy8gSWYgdGhpcyBzdWJzY3JpcHRpb24gd2FzIGdpdmVuIGEgcHJpb3JpdHksIGl0IHRha2VzIHJlbmRlcmluZyBpbnRvIGl0cyBvd24gaGFuZHNcbiAgICAgICAgICAvLyBGb3IgdGhhdCByZWFzb24gd2Ugc3dpdGNoIG9mZiBhdXRvbWF0aWMgcmVuZGVyaW5nIGFuZCBpbmNyZWFzZSB0aGUgbWFudWFsIGZsYWdcbiAgICAgICAgICAvLyBBcyBsb25nIGFzIHRoaXMgZmxhZyBpcyBwb3NpdGl2ZSB0aGVyZSBjYW4gYmUgbm8gaW50ZXJuYWwgcmVuZGVyaW5nIGF0IGFsbFxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgcmVuZGVyIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICBpbnRlcm5hbC5wcmlvcml0eSA9IGludGVybmFsLnByaW9yaXR5ICsgKHByaW9yaXR5ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycy5wdXNoKHtcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgc3RvcmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBSZWdpc3RlciBzdWJzY3JpYmVyIGFuZCBzb3J0IGxheWVycyBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LCBtZWFuaW5nLFxuICAgICAgICAgIC8vIGhpZ2hlc3QgcHJpb3JpdHkgcmVuZGVycyBsYXN0IChvbiB0b3Agb2YgdGhlIG90aGVyIGZyYW1lcylcbiAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycyA9IGludGVybmFsLnN1YnNjcmliZXJzLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWwgPSBnZXQoKS5pbnRlcm5hbDtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbCAhPSBudWxsICYmIGludGVybmFsLnN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICAgIC8vIERlY3JlYXNlIG1hbnVhbCBmbGFnIGlmIHRoaXMgc3Vic2NyaXB0aW9uIGhhZCBhIHByaW9yaXR5XG4gICAgICAgICAgICAgIGludGVybmFsLnByaW9yaXR5ID0gaW50ZXJuYWwucHJpb3JpdHkgLSAocHJpb3JpdHkgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlciBmcm9tIGxpc3RcbiAgICAgICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMgPSBpbnRlcm5hbC5zdWJzY3JpYmVycy5maWx0ZXIocyA9PiBzLnJlZiAhPT0gcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcm9vdFN0YXRlO1xuICB9KTtcbiAgY29uc3Qgc3RhdGUgPSByb290U3RhdGUuZ2V0U3RhdGUoKTtcbiAgbGV0IG9sZFNpemUgPSBzdGF0ZS5zaXplO1xuICBsZXQgb2xkRHByID0gc3RhdGUudmlld3BvcnQuZHByO1xuICBsZXQgb2xkQ2FtZXJhID0gc3RhdGUuY2FtZXJhO1xuICByb290U3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjYW1lcmEsXG4gICAgICBzaXplLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBnbCxcbiAgICAgIHNldFxuICAgIH0gPSByb290U3RhdGUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIFJlc2l6ZSBjYW1lcmEgYW5kIHJlbmRlcmVyIG9uIGNoYW5nZXMgdG8gc2l6ZSBhbmQgcGl4ZWxyYXRpb1xuICAgIGlmIChzaXplLndpZHRoICE9PSBvbGRTaXplLndpZHRoIHx8IHNpemUuaGVpZ2h0ICE9PSBvbGRTaXplLmhlaWdodCB8fCB2aWV3cG9ydC5kcHIgIT09IG9sZERwcikge1xuICAgICAgdmFyIF9zaXplJHVwZGF0ZVN0eWxlO1xuICAgICAgb2xkU2l6ZSA9IHNpemU7XG4gICAgICBvbGREcHIgPSB2aWV3cG9ydC5kcHI7XG4gICAgICAvLyBVcGRhdGUgY2FtZXJhICYgcmVuZGVyZXJcbiAgICAgIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpO1xuICAgICAgZ2wuc2V0UGl4ZWxSYXRpbyh2aWV3cG9ydC5kcHIpO1xuICAgICAgY29uc3QgdXBkYXRlU3R5bGUgPSAoX3NpemUkdXBkYXRlU3R5bGUgPSBzaXplLnVwZGF0ZVN0eWxlKSAhPSBudWxsID8gX3NpemUkdXBkYXRlU3R5bGUgOiB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGdsLmRvbUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgIGdsLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHVwZGF0ZVN0eWxlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdmlld3BvcnQgb25jZSB0aGUgY2FtZXJhIGNoYW5nZXNcbiAgICBpZiAoY2FtZXJhICE9PSBvbGRDYW1lcmEpIHtcbiAgICAgIG9sZENhbWVyYSA9IGNhbWVyYTtcbiAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSlcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW52YWxpZGF0ZSBvbiBhbnkgY2hhbmdlXG4gIHJvb3RTdGF0ZS5zdWJzY3JpYmUoc3RhdGUgPT4gaW52YWxpZGF0ZShzdGF0ZSkpO1xuXG4gIC8vIFJldHVybiByb290IHN0YXRlXG4gIHJldHVybiByb290U3RhdGU7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBzdWJzKSB7XG4gIGNvbnN0IHN1YiA9IHtcbiAgICBjYWxsYmFja1xuICB9O1xuICBzdWJzLmFkZChzdWIpO1xuICByZXR1cm4gKCkgPT4gdm9pZCBzdWJzLmRlbGV0ZShzdWIpO1xufVxubGV0IGk7XG5sZXQgZ2xvYmFsRWZmZWN0cyA9IG5ldyBTZXQoKTtcbmxldCBnbG9iYWxBZnRlckVmZmVjdHMgPSBuZXcgU2V0KCk7XG5sZXQgZ2xvYmFsVGFpbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5cbi8qKlxyXG4gKiBBZGRzIGEgZ2xvYmFsIHJlbmRlciBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgZWFjaCBmcmFtZS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZEVmZmVjdFxyXG4gKi9cbmNvbnN0IGFkZEVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEVmZmVjdHMpO1xuXG4vKipcclxuICogQWRkcyBhIGdsb2JhbCBhZnRlci1yZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRBZnRlckVmZmVjdFxyXG4gKi9cbmNvbnN0IGFkZEFmdGVyRWZmZWN0ID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsQWZ0ZXJFZmZlY3RzKTtcblxuLyoqXHJcbiAqIEFkZHMgYSBnbG9iYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gcmVuZGVyaW5nIHN0b3BzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkVGFpbFxyXG4gKi9cbmNvbnN0IGFkZFRhaWwgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxUYWlsRWZmZWN0cyk7XG5mdW5jdGlvbiBydW4oZWZmZWN0cywgdGltZXN0YW1wKSB7XG4gIGlmICghZWZmZWN0cy5zaXplKSByZXR1cm47XG4gIGZvciAoY29uc3Qge1xuICAgIGNhbGxiYWNrXG4gIH0gb2YgZWZmZWN0cy52YWx1ZXMoKSkge1xuICAgIGNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoR2xvYmFsRWZmZWN0cyh0eXBlLCB0aW1lc3RhbXApIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICdhZnRlcic6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEFmdGVyRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICd0YWlsJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsVGFpbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gIH1cbn1cbmxldCBzdWJzY3JpYmVycztcbmxldCBzdWJzY3JpcHRpb247XG5mdW5jdGlvbiByZW5kZXIkMSh0aW1lc3RhbXAsIHN0YXRlLCBmcmFtZSkge1xuICAvLyBSdW4gbG9jYWwgZWZmZWN0c1xuICBsZXQgZGVsdGEgPSBzdGF0ZS5jbG9jay5nZXREZWx0YSgpO1xuICAvLyBJbiBmcmFtZWxvb3A9J25ldmVyJyBtb2RlLCBjbG9jayB0aW1lcyBhcmUgdXBkYXRlZCB1c2luZyB0aGUgcHJvdmlkZWQgdGltZXN0YW1wXG4gIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicgJiYgdHlwZW9mIHRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICBkZWx0YSA9IHRpbWVzdGFtcCAtIHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lO1xuICAgIHN0YXRlLmNsb2NrLm9sZFRpbWUgPSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZSA9IHRpbWVzdGFtcDtcbiAgfVxuICAvLyBDYWxsIHN1YnNjcmliZXJzICh1c2VGcmFtZSlcbiAgc3Vic2NyaWJlcnMgPSBzdGF0ZS5pbnRlcm5hbC5zdWJzY3JpYmVycztcbiAgZm9yIChpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlcnNbaV07XG4gICAgc3Vic2NyaXB0aW9uLnJlZi5jdXJyZW50KHN1YnNjcmlwdGlvbi5zdG9yZS5nZXRTdGF0ZSgpLCBkZWx0YSwgZnJhbWUpO1xuICB9XG4gIC8vIFJlbmRlciBjb250ZW50XG4gIGlmICghc3RhdGUuaW50ZXJuYWwucHJpb3JpdHkgJiYgc3RhdGUuZ2wucmVuZGVyKSBzdGF0ZS5nbC5yZW5kZXIoc3RhdGUuc2NlbmUsIHN0YXRlLmNhbWVyYSk7XG4gIC8vIERlY3JlYXNlIGZyYW1lIGNvdW50XG4gIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IE1hdGgubWF4KDAsIHN0YXRlLmludGVybmFsLmZyYW1lcyAtIDEpO1xuICByZXR1cm4gc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyA/IDEgOiBzdGF0ZS5pbnRlcm5hbC5mcmFtZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVMb29wKHJvb3RzKSB7XG4gIGxldCBydW5uaW5nID0gZmFsc2U7XG4gIGxldCB1c2VGcmFtZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgbGV0IHJlcGVhdDtcbiAgbGV0IGZyYW1lO1xuICBsZXQgc3RhdGU7XG4gIGZ1bmN0aW9uIGxvb3AodGltZXN0YW1wKSB7XG4gICAgZnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgcnVubmluZyA9IHRydWU7XG4gICAgcmVwZWF0ID0gMDtcblxuICAgIC8vIFJ1biBlZmZlY3RzXG4gICAgZmx1c2hHbG9iYWxFZmZlY3RzKCdiZWZvcmUnLCB0aW1lc3RhbXApO1xuXG4gICAgLy8gUmVuZGVyIGFsbCByb290c1xuICAgIHVzZUZyYW1lSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgZm9yIChjb25zdCByb290IG9mIHJvb3RzLnZhbHVlcygpKSB7XG4gICAgICB2YXIgX3N0YXRlJGdsJHhyO1xuICAgICAgc3RhdGUgPSByb290LnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAvLyBJZiB0aGUgZnJhbWVsb29wIGlzIGludmFsaWRhdGVkLCBkbyBub3QgcnVuIGFub3RoZXIgZnJhbWVcbiAgICAgIGlmIChzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgJiYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ2Fsd2F5cycgfHwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID4gMCkgJiYgISgoX3N0YXRlJGdsJHhyID0gc3RhdGUuZ2wueHIpICE9IG51bGwgJiYgX3N0YXRlJGdsJHhyLmlzUHJlc2VudGluZykpIHtcbiAgICAgICAgcmVwZWF0ICs9IHJlbmRlciQxKHRpbWVzdGFtcCwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB1c2VGcmFtZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8vIFJ1biBhZnRlci1lZmZlY3RzXG4gICAgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG5cbiAgICAvLyBTdG9wIHRoZSBsb29wIGlmIG5vdGhpbmcgaW52YWxpZGF0ZXMgaXRcbiAgICBpZiAocmVwZWF0ID09PSAwKSB7XG4gICAgICAvLyBUYWlsIGNhbGwgZWZmZWN0cywgdGhleSBhcmUgY2FsbGVkIHdoZW4gcmVuZGVyaW5nIHN0b3BzXG4gICAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ3RhaWwnLCB0aW1lc3RhbXApO1xuXG4gICAgICAvLyBGbGFnIGVuZCBvZiBvcGVyYXRpb25cbiAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGludmFsaWRhdGUoc3RhdGUsIGZyYW1lcyA9IDEpIHtcbiAgICB2YXIgX3N0YXRlJGdsJHhyMjtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm4gcm9vdHMuZm9yRWFjaChyb290ID0+IGludmFsaWRhdGUocm9vdC5zdG9yZS5nZXRTdGF0ZSgpLCBmcmFtZXMpKTtcbiAgICBpZiAoKF9zdGF0ZSRnbCR4cjIgPSBzdGF0ZS5nbC54cikgIT0gbnVsbCAmJiBfc3RhdGUkZ2wkeHIyLmlzUHJlc2VudGluZyB8fCAhc3RhdGUuaW50ZXJuYWwuYWN0aXZlIHx8IHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJykgcmV0dXJuO1xuICAgIGlmIChmcmFtZXMgPiAxKSB7XG4gICAgICAvLyBsZWdhY3kgc3VwcG9ydCBmb3IgcGVvcGxlIHVzaW5nIGZyYW1lcyBwYXJhbWV0ZXJzXG4gICAgICAvLyBJbmNyZWFzZSBmcmFtZXMsIGRvIG5vdCBnbyBoaWdoZXIgdGhhbiA2MFxuICAgICAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gTWF0aC5taW4oNjAsIHN0YXRlLmludGVybmFsLmZyYW1lcyArIGZyYW1lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh1c2VGcmFtZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy9jYWxsZWQgZnJvbSB3aXRoaW4gYSB1c2VGcmFtZSwgaXQgbWVhbnMgdGhlIHVzZXIgd2FudHMgYW4gYWRkaXRpb25hbCBmcmFtZVxuICAgICAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy90aGUgdXNlciBuZWVkIGEgbmV3IGZyYW1lLCBubyBuZWVkIHRvIGluY3JlbWVudCBmdXJ0aGVyIHRoYW4gMVxuICAgICAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSByZW5kZXItbG9vcCBpc24ndCBhY3RpdmUsIHN0YXJ0IGl0XG4gICAgaWYgKCFydW5uaW5nKSB7XG4gICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMgPSB0cnVlLCBzdGF0ZSwgZnJhbWUpIHtcbiAgICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZmx1c2hHbG9iYWxFZmZlY3RzKCdiZWZvcmUnLCB0aW1lc3RhbXApO1xuICAgIGlmICghc3RhdGUpIGZvciAoY29uc3Qgcm9vdCBvZiByb290cy52YWx1ZXMoKSkgcmVuZGVyJDEodGltZXN0YW1wLCByb290LnN0b3JlLmdldFN0YXRlKCkpO2Vsc2UgcmVuZGVyJDEodGltZXN0YW1wLCBzdGF0ZSwgZnJhbWUpO1xuICAgIGlmIChydW5HbG9iYWxFZmZlY3RzKSBmbHVzaEdsb2JhbEVmZmVjdHMoJ2FmdGVyJywgdGltZXN0YW1wKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxvb3AsXG4gICAgaW52YWxpZGF0ZSxcbiAgICBhZHZhbmNlXG4gIH07XG59XG5cbi8qKlxyXG4gKiBFeHBvc2VzIGFuIG9iamVjdCdzIHtAbGluayBMb2NhbFN0YXRlfS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI3VzZUluc3RhbmNlSGFuZGxlXHJcbiAqXHJcbiAqICoqTm90ZSoqOiB0aGlzIGlzIGFuIGVzY2FwZSBoYXRjaCB0byByZWFjdC1pbnRlcm5hbCBmaWVsZHMuIEV4cGVjdCB0aGlzIHRvIGNoYW5nZSBzaWduaWZpY2FudGx5IGJldHdlZW4gdmVyc2lvbnMuXHJcbiAqL1xuZnVuY3Rpb24gdXNlSW5zdGFuY2VIYW5kbGUocmVmKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKGluc3RhbmNlLmN1cnJlbnQgPSByZWYuY3VycmVudC5fX3IzZiksIFtyZWZdKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdXNlU3RvcmUoKSB7XG4gIGNvbnN0IHN0b3JlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgaWYgKCFzdG9yZSkgdGhyb3cgbmV3IEVycm9yKCdSM0Y6IEhvb2tzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSBDYW52YXMgY29tcG9uZW50IScpO1xuICByZXR1cm4gc3RvcmU7XG59XG5cbi8qKlxyXG4gKiBBY2Nlc3NlcyBSM0YncyBpbnRlcm5hbCBzdGF0ZSwgY29udGFpbmluZyByZW5kZXJlciwgY2FudmFzLCBzY2VuZSwgZXRjLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2V0aHJlZVxyXG4gKi9cbmZ1bmN0aW9uIHVzZVRocmVlKHNlbGVjdG9yID0gc3RhdGUgPT4gc3RhdGUsIGVxdWFsaXR5Rm4pIHtcbiAgcmV0dXJuIHVzZVN0b3JlKCkoc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xufVxuXG4vKipcclxuICogRXhlY3V0ZXMgYSBjYWxsYmFjayBiZWZvcmUgcmVuZGVyIGluIGEgc2hhcmVkIGZyYW1lIGxvb3AuXHJcbiAqIENhbiBvcmRlciBlZmZlY3RzIHdpdGggcmVuZGVyIHByaW9yaXR5IG9yIG1hbnVhbGx5IHJlbmRlciB3aXRoIGEgcG9zaXRpdmUgcHJpb3JpdHkuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZWZyYW1lXHJcbiAqL1xuZnVuY3Rpb24gdXNlRnJhbWUoY2FsbGJhY2ssIHJlbmRlclByaW9yaXR5ID0gMCkge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHN0b3JlLmdldFN0YXRlKCkuaW50ZXJuYWwuc3Vic2NyaWJlO1xuICAvLyBNZW1vaXplIHJlZlxuICBjb25zdCByZWYgPSB1c2VNdXRhYmxlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAvLyBTdWJzY3JpYmUgb24gbW91bnQsIHVuc3Vic2NyaWJlIG9uIHVubW91bnRcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBzdWJzY3JpYmUocmVmLCByZW5kZXJQcmlvcml0eSwgc3RvcmUpLCBbcmVuZGVyUHJpb3JpdHksIHN1YnNjcmliZSwgc3RvcmVdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGEgbm9kZSBncmFwaCBvZiBhbiBvYmplY3Qgd2l0aCBuYW1lZCBub2RlcyAmIG1hdGVyaWFscy5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZ3JhcGhcclxuICovXG5mdW5jdGlvbiB1c2VHcmFwaChvYmplY3QpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gYnVpbGRHcmFwaChvYmplY3QpLCBbb2JqZWN0XSk7XG59XG5jb25zdCBtZW1vaXplZExvYWRlcnMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChQcm90bywgLi4uaW5wdXQpIHtcbiAgICAvLyBDb25zdHJ1Y3QgbmV3IGxvYWRlciBhbmQgcnVuIGV4dGVuc2lvbnNcbiAgICBsZXQgbG9hZGVyID0gbWVtb2l6ZWRMb2FkZXJzLmdldChQcm90byk7XG4gICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgIGxvYWRlciA9IG5ldyBQcm90bygpO1xuICAgICAgbWVtb2l6ZWRMb2FkZXJzLnNldChQcm90bywgbG9hZGVyKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbnMpIGV4dGVuc2lvbnMobG9hZGVyKTtcbiAgICAvLyBHbyB0aHJvdWdoIHRoZSB1cmxzIGFuZCBsb2FkIHRoZW1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoaW5wdXQubWFwKGlucHV0ID0+IG5ldyBQcm9taXNlKChyZXMsIHJlamVjdCkgPT4gbG9hZGVyLmxvYWQoaW5wdXQsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEuc2NlbmUpIE9iamVjdC5hc3NpZ24oZGF0YSwgYnVpbGRHcmFwaChkYXRhLnNjZW5lKSk7XG4gICAgICByZXMoZGF0YSk7XG4gICAgfSwgb25Qcm9ncmVzcywgZXJyb3IgPT4gcmVqZWN0KG5ldyBFcnJvcihgQ291bGQgbm90IGxvYWQgJHtpbnB1dH06ICR7ZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2V9YCkpKSkpKTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBTeW5jaHJvbm91c2x5IGxvYWRzIGFuZCBjYWNoZXMgYXNzZXRzIHdpdGggYSB0aHJlZSBsb2FkZXIuXHJcbiAqXHJcbiAqIE5vdGU6IHRoaXMgaG9vaydzIGNhbGxlciBtdXN0IGJlIHdyYXBwZWQgd2l0aCBgUmVhY3QuU3VzcGVuc2VgXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZWxvYWRlclxyXG4gKi9cbmZ1bmN0aW9uIHVzZUxvYWRlcihQcm90bywgaW5wdXQsIGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgLy8gVXNlIHN1c3BlbnNlIHRvIGxvYWQgYXN5bmMgYXNzZXRzXG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgY29uc3QgcmVzdWx0cyA9IHN1c3BlbmQobG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpLCBbUHJvdG8sIC4uLmtleXNdLCB7XG4gICAgZXF1YWw6IGlzLmVxdVxuICB9KTtcbiAgLy8gUmV0dXJuIHRoZSBvYmplY3Qvc1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgPyByZXN1bHRzIDogcmVzdWx0c1swXTtcbn1cblxuLyoqXHJcbiAqIFByZWxvYWRzIGFuIGFzc2V0IGludG8gY2FjaGUgYXMgYSBzaWRlLWVmZmVjdC5cclxuICovXG51c2VMb2FkZXIucHJlbG9hZCA9IGZ1bmN0aW9uIChQcm90bywgaW5wdXQsIGV4dGVuc2lvbnMpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICByZXR1cm4gcHJlbG9hZChsb2FkaW5nRm4oZXh0ZW5zaW9ucyksIFtQcm90bywgLi4ua2V5c10pO1xufTtcblxuLyoqXHJcbiAqIFJlbW92ZXMgYSBsb2FkZWQgYXNzZXQgZnJvbSBjYWNoZS5cclxuICovXG51c2VMb2FkZXIuY2xlYXIgPSBmdW5jdGlvbiAoUHJvdG8sIGlucHV0KSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgcmV0dXJuIGNsZWFyKFtQcm90bywgLi4ua2V5c10pO1xufTtcblxuY29uc3Qgcm9vdHMgPSBuZXcgTWFwKCk7XG5jb25zdCB7XG4gIGludmFsaWRhdGUsXG4gIGFkdmFuY2Vcbn0gPSBjcmVhdGVMb29wKHJvb3RzKTtcbmNvbnN0IHtcbiAgcmVjb25jaWxlcixcbiAgYXBwbHlQcm9wc1xufSA9IGNyZWF0ZVJlbmRlcmVyKHJvb3RzLCBnZXRFdmVudFByaW9yaXR5KTtcbmNvbnN0IHNoYWxsb3dMb29zZSA9IHtcbiAgb2JqZWN0czogJ3NoYWxsb3cnLFxuICBzdHJpY3Q6IGZhbHNlXG59O1xuY29uc3QgY3JlYXRlUmVuZGVyZXJJbnN0YW5jZSA9IChnbCwgY2FudmFzKSA9PiB7XG4gIGNvbnN0IGN1c3RvbVJlbmRlcmVyID0gdHlwZW9mIGdsID09PSAnZnVuY3Rpb24nID8gZ2woY2FudmFzKSA6IGdsO1xuICBpZiAoaXNSZW5kZXJlcihjdXN0b21SZW5kZXJlcikpIHJldHVybiBjdXN0b21SZW5kZXJlcjtlbHNlIHJldHVybiBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgcG93ZXJQcmVmZXJlbmNlOiAnaGlnaC1wZXJmb3JtYW5jZScsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgYW50aWFsaWFzOiB0cnVlLFxuICAgIGFscGhhOiB0cnVlLFxuICAgIC4uLmdsXG4gIH0pO1xufTtcbmZ1bmN0aW9uIGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIGRlZmF1bHRTaXplKSB7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XG4gIGlmIChkZWZhdWx0U2l6ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHVwZGF0ZVN0eWxlID0gZGVmYXVsdFN0eWxlXG4gICAgfSA9IGRlZmF1bHRTaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICB1cGRhdGVTdHlsZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCAmJiBjYW52YXMucGFyZW50RWxlbWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdFxuICAgIH0gPSBjYW52YXMucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgdXBkYXRlU3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdXBkYXRlU3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2FudmFzKSB7XG4gIC8vIENoZWNrIGFnYWluc3QgbWlzdGFrZW4gdXNlIG9mIGNyZWF0ZVJvb3RcbiAgY29uc3QgcHJldlJvb3QgPSByb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgcHJldkZpYmVyID0gcHJldlJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZSb290LmZpYmVyO1xuICBjb25zdCBwcmV2U3RvcmUgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3Quc3RvcmU7XG4gIGlmIChwcmV2Um9vdCkgY29uc29sZS53YXJuKCdSM0YuY3JlYXRlUm9vdCBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSEnKTtcblxuICAvLyBSZXBvcnQgd2hlbiBhbiBlcnJvciB3YXMgZGV0ZWN0ZWQgaW4gYSBwcmV2aW91cyByZW5kZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIyNjFcbiAgY29uc3QgbG9nUmVjb3ZlcmFibGVFcnJvciA9IHR5cGVvZiByZXBvcnRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gIC8vIEluIG1vZGVybiBicm93c2VycywgcmVwb3J0RXJyb3Igd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCxcbiAgLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG4gIHJlcG9ydEVycm9yIDpcbiAgLy8gSW4gb2xkZXIgYnJvd3NlcnMgYW5kIHRlc3QgZW52aXJvbm1lbnRzLCBmYWxsYmFjayB0byBjb25zb2xlLmVycm9yLlxuICBjb25zb2xlLmVycm9yO1xuXG4gIC8vIENyZWF0ZSBzdG9yZVxuICBjb25zdCBzdG9yZSA9IHByZXZTdG9yZSB8fCBjcmVhdGVTdG9yZShpbnZhbGlkYXRlLCBhZHZhbmNlKTtcbiAgLy8gQ3JlYXRlIHJlbmRlcmVyXG4gIGNvbnN0IGZpYmVyID0gcHJldkZpYmVyIHx8IHJlY29uY2lsZXIuY3JlYXRlQ29udGFpbmVyKHN0b3JlLCBDb25jdXJyZW50Um9vdCwgbnVsbCwgZmFsc2UsIG51bGwsICcnLCBsb2dSZWNvdmVyYWJsZUVycm9yLCBudWxsKTtcbiAgLy8gTWFwIGl0XG4gIGlmICghcHJldlJvb3QpIHJvb3RzLnNldChjYW52YXMsIHtcbiAgICBmaWJlcixcbiAgICBzdG9yZVxuICB9KTtcblxuICAvLyBMb2NhbHNcbiAgbGV0IG9uQ3JlYXRlZDtcbiAgbGV0IGNvbmZpZ3VyZWQgPSBmYWxzZTtcbiAgbGV0IGxhc3RDYW1lcmE7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJlKHByb3BzID0ge30pIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGdsOiBnbENvbmZpZyxcbiAgICAgICAgc2l6ZTogcHJvcHNTaXplLFxuICAgICAgICBzY2VuZTogc2NlbmVPcHRpb25zLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIG9uQ3JlYXRlZDogb25DcmVhdGVkQ2FsbGJhY2ssXG4gICAgICAgIHNoYWRvd3MgPSBmYWxzZSxcbiAgICAgICAgbGluZWFyID0gZmFsc2UsXG4gICAgICAgIGZsYXQgPSBmYWxzZSxcbiAgICAgICAgbGVnYWN5ID0gZmFsc2UsXG4gICAgICAgIG9ydGhvZ3JhcGhpYyA9IGZhbHNlLFxuICAgICAgICBmcmFtZWxvb3AgPSAnYWx3YXlzJyxcbiAgICAgICAgZHByID0gWzEsIDJdLFxuICAgICAgICBwZXJmb3JtYW5jZSxcbiAgICAgICAgcmF5Y2FzdGVyOiByYXljYXN0T3B0aW9ucyxcbiAgICAgICAgY2FtZXJhOiBjYW1lcmFPcHRpb25zLFxuICAgICAgICBvblBvaW50ZXJNaXNzZWRcbiAgICAgIH0gPSBwcm9wcztcbiAgICAgIGxldCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIFNldCB1cCByZW5kZXJlciAob25lIHRpbWUgb25seSEpXG4gICAgICBsZXQgZ2wgPSBzdGF0ZS5nbDtcbiAgICAgIGlmICghc3RhdGUuZ2wpIHN0YXRlLnNldCh7XG4gICAgICAgIGdsOiBnbCA9IGNyZWF0ZVJlbmRlcmVySW5zdGFuY2UoZ2xDb25maWcsIGNhbnZhcylcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgdXAgcmF5Y2FzdGVyIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGxldCByYXljYXN0ZXIgPSBzdGF0ZS5yYXljYXN0ZXI7XG4gICAgICBpZiAoIXJheWNhc3Rlcikgc3RhdGUuc2V0KHtcbiAgICAgICAgcmF5Y2FzdGVyOiByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgcmF5Y2FzdGVyIG9wdGlvbnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9ID0gcmF5Y2FzdE9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIWlzLmVxdShvcHRpb25zLCByYXljYXN0ZXIsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpcy5lcXUocGFyYW1zLCByYXljYXN0ZXIucGFyYW1zLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKHJheWNhc3Rlciwge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAuLi5yYXljYXN0ZXIucGFyYW1zLFxuICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgY2FtZXJhLCBkb24ndCBvdmVyd3JpdGUgYW55IHVzZXItc2V0IHN0YXRlXG4gICAgICBpZiAoIXN0YXRlLmNhbWVyYSB8fCBzdGF0ZS5jYW1lcmEgPT09IGxhc3RDYW1lcmEgJiYgIWlzLmVxdShsYXN0Q2FtZXJhLCBjYW1lcmFPcHRpb25zLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIGxhc3RDYW1lcmEgPSBjYW1lcmFPcHRpb25zO1xuICAgICAgICBjb25zdCBpc0NhbWVyYSA9IGNhbWVyYU9wdGlvbnMgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmE7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGlzQ2FtZXJhID8gY2FtZXJhT3B0aW9ucyA6IG9ydGhvZ3JhcGhpYyA/IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoMCwgMCwgMCwgMCwgMC4xLCAxMDAwKSA6IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgMCwgMC4xLCAxMDAwKTtcbiAgICAgICAgaWYgKCFpc0NhbWVyYSkge1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gNTtcbiAgICAgICAgICBpZiAoY2FtZXJhT3B0aW9ucykge1xuICAgICAgICAgICAgYXBwbHlQcm9wcyhjYW1lcmEsIGNhbWVyYU9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgdXNlci1kZWZpbmVkIGZydXN0dW0gaWYgcG9zc2libGVcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzMxNjBcbiAgICAgICAgICAgIGlmICgnYXNwZWN0JyBpbiBjYW1lcmFPcHRpb25zIHx8ICdsZWZ0JyBpbiBjYW1lcmFPcHRpb25zIHx8ICdyaWdodCcgaW4gY2FtZXJhT3B0aW9ucyB8fCAnYm90dG9tJyBpbiBjYW1lcmFPcHRpb25zIHx8ICd0b3AnIGluIGNhbWVyYU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgY2FtZXJhLm1hbnVhbCA9IHRydWU7XG4gICAgICAgICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFsd2F5cyBsb29rIGF0IGNlbnRlciBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKCFzdGF0ZS5jYW1lcmEgJiYgIShjYW1lcmFPcHRpb25zICE9IG51bGwgJiYgY2FtZXJhT3B0aW9ucy5yb3RhdGlvbikpIGNhbWVyYS5sb29rQXQoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBjYW1lcmFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHJheWNhc3RlclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXhyL2lzc3Vlcy8zMDBcbiAgICAgICAgcmF5Y2FzdGVyLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIHNjZW5lIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUuc2NlbmUpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBpZiAoc2NlbmVPcHRpb25zIGluc3RhbmNlb2YgVEhSRUUuU2NlbmUpIHtcbiAgICAgICAgICBzY2VuZSA9IHNjZW5lT3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgICAgIGlmIChzY2VuZU9wdGlvbnMpIGFwcGx5UHJvcHMoc2NlbmUsIHNjZW5lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBzY2VuZTogcHJlcGFyZShzY2VuZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBYUiAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnhyKSB7XG4gICAgICAgIHZhciBfZ2wkeHI7XG4gICAgICAgIC8vIEhhbmRsZSBmcmFtZSBiZWhhdmlvciBpbiBXZWJYUlxuICAgICAgICBjb25zdCBoYW5kbGVYUkZyYW1lID0gKHRpbWVzdGFtcCwgZnJhbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJykgcmV0dXJuO1xuICAgICAgICAgIGFkdmFuY2UodGltZXN0YW1wLCB0cnVlLCBzdGF0ZSwgZnJhbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvZ2dsZSByZW5kZXIgc3dpdGNoaW5nIG9uIHNlc3Npb25cbiAgICAgICAgY29uc3QgaGFuZGxlU2Vzc2lvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuZW5hYmxlZCA9IHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZztcbiAgICAgICAgICBzdGF0ZS5nbC54ci5zZXRBbmltYXRpb25Mb29wKHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZyA/IGhhbmRsZVhSRnJhbWUgOiBudWxsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmdsLnhyLmlzUHJlc2VudGluZykgaW52YWxpZGF0ZShzdGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV2ViWFIgc2Vzc2lvbiBtYW5hZ2VyXG4gICAgICAgIGNvbnN0IHhyID0ge1xuICAgICAgICAgIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIFdlYlhSIHNlc3Npb24gZXZlbnRzXG4gICAgICAgIGlmICh0eXBlb2YgKChfZ2wkeHIgPSBnbC54cikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbCR4ci5hZGRFdmVudExpc3RlbmVyKSA9PT0gJ2Z1bmN0aW9uJykgeHIuY29ubmVjdCgpO1xuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIHhyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgc2hhZG93bWFwXG4gICAgICBpZiAoZ2wuc2hhZG93TWFwKSB7XG4gICAgICAgIGNvbnN0IG9sZEVuYWJsZWQgPSBnbC5zaGFkb3dNYXAuZW5hYmxlZDtcbiAgICAgICAgY29uc3Qgb2xkVHlwZSA9IGdsLnNoYWRvd01hcC50eXBlO1xuICAgICAgICBnbC5zaGFkb3dNYXAuZW5hYmxlZCA9ICEhc2hhZG93cztcbiAgICAgICAgaWYgKGlzLmJvbyhzaGFkb3dzKSkge1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5zdHIoc2hhZG93cykpIHtcbiAgICAgICAgICB2YXIgX3R5cGVzJHNoYWRvd3M7XG4gICAgICAgICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgICAgICBiYXNpYzogVEhSRUUuQmFzaWNTaGFkb3dNYXAsXG4gICAgICAgICAgICBwZXJjZW50YWdlOiBUSFJFRS5QQ0ZTaGFkb3dNYXAsXG4gICAgICAgICAgICBzb2Z0OiBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwLFxuICAgICAgICAgICAgdmFyaWFuY2U6IFRIUkVFLlZTTVNoYWRvd01hcFxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2wuc2hhZG93TWFwLnR5cGUgPSAoX3R5cGVzJHNoYWRvd3MgPSB0eXBlc1tzaGFkb3dzXSkgIT0gbnVsbCA/IF90eXBlcyRzaGFkb3dzIDogVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5vYmooc2hhZG93cykpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGdsLnNoYWRvd01hcCwgc2hhZG93cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZEVuYWJsZWQgIT09IGdsLnNoYWRvd01hcC5lbmFibGVkIHx8IG9sZFR5cGUgIT09IGdsLnNoYWRvd01hcC50eXBlKSBnbC5zaGFkb3dNYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTYWZlbHkgc2V0IGNvbG9yIG1hbmFnZW1lbnQgaWYgYXZhaWxhYmxlLlxuICAgICAgLy8gQXZvaWQgYWNjZXNzaW5nIFRIUkVFLkNvbG9yTWFuYWdlbWVudCB0byBwbGF5IG5pY2Ugd2l0aCBvbGRlciB2ZXJzaW9uc1xuICAgICAgY29uc3QgQ29sb3JNYW5hZ2VtZW50ID0gZ2V0Q29sb3JNYW5hZ2VtZW50KCk7XG4gICAgICBpZiAoQ29sb3JNYW5hZ2VtZW50KSB7XG4gICAgICAgIGlmICgnZW5hYmxlZCcgaW4gQ29sb3JNYW5hZ2VtZW50KSBDb2xvck1hbmFnZW1lbnQuZW5hYmxlZCA9ICFsZWdhY3k7ZWxzZSBpZiAoJ2xlZ2FjeU1vZGUnIGluIENvbG9yTWFuYWdlbWVudCkgQ29sb3JNYW5hZ2VtZW50LmxlZ2FjeU1vZGUgPSBsZWdhY3k7XG4gICAgICB9XG4gICAgICBpZiAoIWNvbmZpZ3VyZWQpIHtcbiAgICAgICAgLy8gU2V0IGNvbG9yIHNwYWNlIGFuZCB0b25lbWFwcGluZyBwcmVmZXJlbmNlcywgb25jZVxuICAgICAgICBjb25zdCBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XG4gICAgICAgIGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG4gICAgICAgIGFwcGx5UHJvcHMoZ2wsIHtcbiAgICAgICAgICBvdXRwdXRFbmNvZGluZzogbGluZWFyID8gTGluZWFyRW5jb2RpbmcgOiBzUkdCRW5jb2RpbmcsXG4gICAgICAgICAgdG9uZU1hcHBpbmc6IGZsYXQgPyBUSFJFRS5Ob1RvbmVNYXBwaW5nIDogVEhSRUUuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgY29sb3IgbWFuYWdlbWVudCBzdGF0ZVxuICAgICAgaWYgKHN0YXRlLmxlZ2FjeSAhPT0gbGVnYWN5KSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgbGVnYWN5XG4gICAgICB9KSk7XG4gICAgICBpZiAoc3RhdGUubGluZWFyICE9PSBsaW5lYXIpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBsaW5lYXJcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdGF0ZS5mbGF0ICE9PSBmbGF0KSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgZmxhdFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBTZXQgZ2wgcHJvcHNcbiAgICAgIGlmIChnbENvbmZpZyAmJiAhaXMuZnVuKGdsQ29uZmlnKSAmJiAhaXNSZW5kZXJlcihnbENvbmZpZykgJiYgIWlzLmVxdShnbENvbmZpZywgZ2wsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMoZ2wsIGdsQ29uZmlnKTtcbiAgICAgIC8vIFN0b3JlIGV2ZW50cyBpbnRlcm5hbGx5XG4gICAgICBpZiAoZXZlbnRzICYmICFzdGF0ZS5ldmVudHMuaGFuZGxlcnMpIHN0YXRlLnNldCh7XG4gICAgICAgIGV2ZW50czogZXZlbnRzKHN0b3JlKVxuICAgICAgfSk7XG4gICAgICAvLyBDaGVjayBzaXplLCBhbGxvdyBpdCB0byB0YWtlIG9uIGNvbnRhaW5lciBib3VuZHMgaW5pdGlhbGx5XG4gICAgICBjb25zdCBzaXplID0gY29tcHV0ZUluaXRpYWxTaXplKGNhbnZhcywgcHJvcHNTaXplKTtcbiAgICAgIGlmICghaXMuZXF1KHNpemUsIHN0YXRlLnNpemUsIHNoYWxsb3dMb29zZSkpIHtcbiAgICAgICAgc3RhdGUuc2V0U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgc2l6ZS51cGRhdGVTdHlsZSwgc2l6ZS50b3AsIHNpemUubGVmdCk7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBwaXhlbHJhdGlvXG4gICAgICBpZiAoZHByICYmIHN0YXRlLnZpZXdwb3J0LmRwciAhPT0gY2FsY3VsYXRlRHByKGRwcikpIHN0YXRlLnNldERwcihkcHIpO1xuICAgICAgLy8gQ2hlY2sgZnJhbWVsb29wXG4gICAgICBpZiAoc3RhdGUuZnJhbWVsb29wICE9PSBmcmFtZWxvb3ApIHN0YXRlLnNldEZyYW1lbG9vcChmcmFtZWxvb3ApO1xuICAgICAgLy8gQ2hlY2sgcG9pbnRlciBtaXNzZWRcbiAgICAgIGlmICghc3RhdGUub25Qb2ludGVyTWlzc2VkKSBzdGF0ZS5zZXQoe1xuICAgICAgICBvblBvaW50ZXJNaXNzZWRcbiAgICAgIH0pO1xuICAgICAgLy8gQ2hlY2sgcGVyZm9ybWFuY2VcbiAgICAgIGlmIChwZXJmb3JtYW5jZSAmJiAhaXMuZXF1KHBlcmZvcm1hbmNlLCBzdGF0ZS5wZXJmb3JtYW5jZSwgc2hhbGxvd0xvb3NlKSkgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgICAgLi4uc3RhdGUucGVyZm9ybWFuY2UsXG4gICAgICAgICAgLi4ucGVyZm9ybWFuY2VcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICAvLyBTZXQgbG9jYWxzXG4gICAgICBvbkNyZWF0ZWQgPSBvbkNyZWF0ZWRDYWxsYmFjaztcbiAgICAgIGNvbmZpZ3VyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW5kZXIoY2hpbGRyZW4pIHtcbiAgICAgIC8vIFRoZSByb290IGhhcyB0byBiZSBjb25maWd1cmVkIGJlZm9yZSBpdCBjYW4gYmUgcmVuZGVyZWRcbiAgICAgIGlmICghY29uZmlndXJlZCkgdGhpcy5jb25maWd1cmUoKTtcbiAgICAgIHJlY29uY2lsZXIudXBkYXRlQ29udGFpbmVyKCAvKiNfX1BVUkVfXyovanN4KFByb3ZpZGVyLCB7XG4gICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZCxcbiAgICAgICAgcm9vdEVsZW1lbnQ6IGNhbnZhc1xuICAgICAgfSksIGZpYmVyLCBudWxsLCAoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH0sXG4gICAgdW5tb3VudCgpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiByZW5kZXIoY2hpbGRyZW4sIGNhbnZhcywgY29uZmlnKSB7XG4gIGNvbnNvbGUud2FybignUjNGLnJlbmRlciBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGluIFJlYWN0IDE4LiBVc2UgY3JlYXRlUm9vdCBpbnN0ZWFkIScpO1xuICBjb25zdCByb290ID0gY3JlYXRlUm9vdChjYW52YXMpO1xuICByb290LmNvbmZpZ3VyZShjb25maWcpO1xuICByZXR1cm4gcm9vdC5yZW5kZXIoY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gUHJvdmlkZXIoe1xuICBzdG9yZSxcbiAgY2hpbGRyZW4sXG4gIG9uQ3JlYXRlZCxcbiAgcm9vdEVsZW1lbnRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIC8vIEZsYWcgdGhlIGNhbnZhcyBhY3RpdmUsIHJlbmRlcmluZyB3aWxsIG5vdyBiZWdpblxuICAgIHN0YXRlLnNldChzdGF0ZSA9PiAoe1xuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgLi4uc3RhdGUuaW50ZXJuYWwsXG4gICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pKTtcbiAgICAvLyBOb3RpZml5IHRoYXQgaW5pdCBpcyBjb21wbGV0ZWQsIHRoZSBzY2VuZSBncmFwaCBleGlzdHMsIGJ1dCBub3RoaW5nIGhhcyB5ZXQgcmVuZGVyZWRcbiAgICBpZiAob25DcmVhdGVkKSBvbkNyZWF0ZWQoc3RhdGUpO1xuICAgIC8vIENvbm5lY3QgZXZlbnRzIHRvIHRoZSB0YXJnZXRzIHBhcmVudCwgdGhpcyBpcyBkb25lIHRvIGVuc3VyZSBldmVudHMgYXJlIHJlZ2lzdGVyZWQgb25cbiAgICAvLyBhIHNoYXJlZCB0YXJnZXQsIGFuZCBub3Qgb24gdGhlIGNhbnZhcyBpdHNlbGZcbiAgICBpZiAoIXN0b3JlLmdldFN0YXRlKCkuZXZlbnRzLmNvbm5lY3RlZCkgc3RhdGUuZXZlbnRzLmNvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb25uZWN0KHJvb3RFbGVtZW50KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdG9yZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcywgY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vdCA9IHJvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBmaWJlciA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZmliZXI7XG4gIGlmIChmaWJlcikge1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSkgc3RhdGUuaW50ZXJuYWwuYWN0aXZlID0gZmFsc2U7XG4gICAgcmVjb25jaWxlci51cGRhdGVDb250YWluZXIobnVsbCwgZmliZXIsIG51bGwsICgpID0+IHtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9zdGF0ZSRnbCwgX3N0YXRlJGdsJHJlbmRlckxpc3RzLCBfc3RhdGUkZ2wyLCBfc3RhdGUkZ2wzO1xuICAgICAgICAgICAgc3RhdGUuZXZlbnRzLmRpc2Nvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsID0gc3RhdGUuZ2wpID09IG51bGwgPyB2b2lkIDAgOiAoX3N0YXRlJGdsJHJlbmRlckxpc3RzID0gX3N0YXRlJGdsLnJlbmRlckxpc3RzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsJHJlbmRlckxpc3RzLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbCRyZW5kZXJMaXN0cy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsMiA9IHN0YXRlLmdsKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsMi5mb3JjZUNvbnRleHRMb3NzID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wyLmZvcmNlQ29udGV4dExvc3MoKTtcbiAgICAgICAgICAgIGlmICgoX3N0YXRlJGdsMyA9IHN0YXRlLmdsKSAhPSBudWxsICYmIF9zdGF0ZSRnbDMueHIpIHN0YXRlLnhyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGRpc3Bvc2Uoc3RhdGUpO1xuICAgICAgICAgICAgcm9vdHMuZGVsZXRlKGNhbnZhcyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGNhbnZhcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogLi4uICovXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lciwgc3RhdGUpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goUG9ydGFsLCB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9LCBjb250YWluZXIudXVpZCk7XG59XG5mdW5jdGlvbiBQb3J0YWwoe1xuICBzdGF0ZSA9IHt9LFxuICBjaGlsZHJlbixcbiAgY29udGFpbmVyXG59KSB7XG4gIC8qKiBUaGlzIGhhcyB0byBiZSBhIGNvbXBvbmVudCBiZWNhdXNlIGl0IHdvdWxkIG5vdCBiZSBhYmxlIHRvIGNhbGwgdXNlVGhyZWUvdXNlU3RvcmUgb3RoZXJ3aXNlIHNpbmNlXHJcbiAgICogIGlmIHRoaXMgaXMgb3VyIGVudmlyb25tZW50LCB0aGVuIHdlIGFyZSBub3QgaW4gcjNmJ3MgcmVuZGVyZXIgYnV0IGluIHJlYWN0LWRvbSwgaXQgd291bGQgdHJpZ2dlclxyXG4gICAqICB0aGUgXCJSM0YgaG9va3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlIENhbnZhcyBjb21wb25lbnQhXCIgd2FybmluZzpcclxuICAgKiAgPENhbnZhcz5cclxuICAgKiAgICB7Y3JlYXRlUG9ydGFsKC4uLil9ICovXG4gIGNvbnN0IHtcbiAgICBldmVudHMsXG4gICAgc2l6ZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcHJldmlvdXNSb290ID0gdXNlU3RvcmUoKTtcbiAgY29uc3QgW3JheWNhc3Rlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUUuUmF5Y2FzdGVyKCkpO1xuICBjb25zdCBbcG9pbnRlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMigpKTtcbiAgY29uc3QgaW5qZWN0ID0gUmVhY3QudXNlQ2FsbGJhY2soKHJvb3RTdGF0ZSwgaW5qZWN0U3RhdGUpID0+IHtcbiAgICBjb25zdCBpbnRlcnNlY3QgPSB7XG4gICAgICAuLi5yb290U3RhdGVcbiAgICB9OyAvLyBhbGwgcHJldiBzdGF0ZSBwcm9wc1xuXG4gICAgLy8gT25seSB0aGUgZmllbGRzIG9mIFwicm9vdFN0YXRlXCIgdGhhdCBkbyBub3QgZGlmZmVyIGZyb20gaW5qZWN0U3RhdGVcbiAgICAvLyBTb21lIHByb3BzIHNob3VsZCBiZSBvZmYtbGltaXRzXG4gICAgLy8gT3RoZXJ3aXNlIGZpbHRlciBvdXQgdGhlIHByb3BzIHRoYXQgYXJlIGRpZmZlcmVudCBhbmQgbGV0IHRoZSBpbmplY3QgbGF5ZXIgdGFrZSBwcmVjZWRlbmNlXG4gICAgT2JqZWN0LmtleXMocm9vdFN0YXRlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAvLyBTb21lIHByb3BzIHNob3VsZCBiZSBvZmYtbGltaXRzXG4gICAgICBwcml2YXRlS2V5cy5pbmNsdWRlcyhrZXkpIHx8XG4gICAgICAvLyBPdGhlcndpc2UgZmlsdGVyIG91dCB0aGUgcHJvcHMgdGhhdCBhcmUgZGlmZmVyZW50IGFuZCBsZXQgdGhlIGluamVjdCBsYXllciB0YWtlIHByZWNlZGVuY2VcbiAgICAgIC8vIFVubGVzcyB0aGUgaW5qZWN0IGxheWVyIHByb3BzIGlzIHVuZGVmaW5lZCwgdGhlbiB3ZSBrZWVwIHRoZSByb290IGxheWVyXG4gICAgICByb290U3RhdGVba2V5XSAhPT0gaW5qZWN0U3RhdGVba2V5XSAmJiBpbmplY3RTdGF0ZVtrZXldKSB7XG4gICAgICAgIGRlbGV0ZSBpbnRlcnNlY3Rba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgdmlld3BvcnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGluamVjdFN0YXRlICYmIHNpemUpIHtcbiAgICAgIGNvbnN0IGNhbWVyYSA9IGluamVjdFN0YXRlLmNhbWVyYTtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3ZlcnJpZGUgdmlld3BvcnQsIGlmIHByZXNlbnRcbiAgICAgIHZpZXdwb3J0ID0gcm9vdFN0YXRlLnZpZXdwb3J0LmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEsIG5ldyBUSFJFRS5WZWN0b3IzKCksIHNpemUpO1xuICAgICAgLy8gVXBkYXRlIHRoZSBwb3J0YWwgY2FtZXJhLCBpZiBpdCBkaWZmZXJzIGZyb20gdGhlIHByZXZpb3VzIGxheWVyXG4gICAgICBpZiAoY2FtZXJhICE9PSByb290U3RhdGUuY2FtZXJhKSB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoZSBpbnRlcnNlY3QgY29uc2lzdHMgb2YgdGhlIHByZXZpb3VzIHJvb3Qgc3RhdGVcbiAgICAgIC4uLmludGVyc2VjdCxcbiAgICAgIC8vIFBvcnRhbHMgaGF2ZSB0aGVpciBvd24gc2NlbmUsIHdoaWNoIGZvcm1zIHRoZSByb290LCBhIHJheWNhc3RlciBhbmQgYSBwb2ludGVyXG4gICAgICBzY2VuZTogY29udGFpbmVyLFxuICAgICAgcmF5Y2FzdGVyLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgLy8gVGhlaXIgcHJldmlvdXMgcm9vdCBpcyB0aGUgbGF5ZXIgYmVmb3JlIGl0XG4gICAgICBwcmV2aW91c1Jvb3QsXG4gICAgICAvLyBFdmVudHMsIHNpemUgYW5kIHZpZXdwb3J0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBpbmplY3QgbGF5ZXJcbiAgICAgIGV2ZW50czoge1xuICAgICAgICAuLi5yb290U3RhdGUuZXZlbnRzLFxuICAgICAgICAuLi4oaW5qZWN0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGluamVjdFN0YXRlLmV2ZW50cyksXG4gICAgICAgIC4uLmV2ZW50c1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLnNpemUsXG4gICAgICAgIC4uLnNpemVcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICAuLi5yb290U3RhdGUudmlld3BvcnQsXG4gICAgICAgIC4uLnZpZXdwb3J0XG4gICAgICB9LFxuICAgICAgLi4ucmVzdFxuICAgIH07XG4gIH0sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW3N0YXRlXSk7XG4gIGNvbnN0IFt1c2VQb3J0YWxTdG9yZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgLy8gQ3JlYXRlIGEgbWlycm9yZWQgc3RvcmUsIGJhc2VkIG9uIHRoZSBwcmV2aW91cyByb290IHdpdGggYSBmZXcgb3ZlcnJpZGVzIC4uLlxuICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBzdG9yZSA9IGNyZWF0ZSgoc2V0LCBnZXQpID0+ICh7XG4gICAgICAuLi5wcmV2aW91c1N0YXRlLFxuICAgICAgc2NlbmU6IGNvbnRhaW5lcixcbiAgICAgIHJheWNhc3RlcixcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIHByZXZpb3VzUm9vdCxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICAuLi5wcmV2aW91c1N0YXRlLmV2ZW50cyxcbiAgICAgICAgLi4uZXZlbnRzXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICAuLi5wcmV2aW91c1N0YXRlLnNpemUsXG4gICAgICAgIC4uLnNpemVcbiAgICAgIH0sXG4gICAgICAuLi5yZXN0LFxuICAgICAgLy8gU2V0IGFuZCBnZXQgcmVmZXIgdG8gdGhpcyByb290LXN0YXRlXG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBMYXllcnMgYXJlIGFsbG93ZWQgdG8gb3ZlcnJpZGUgZXZlbnRzXG4gICAgICBzZXRFdmVudHM6IGV2ZW50cyA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgfSkpO1xuICAgIHJldHVybiBzdG9yZTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU3Vic2NyaWJlIHRvIHByZXZpb3VzIHJvb3Qtc3RhdGUgYW5kIGNvcHkgY2hhbmdlcyBvdmVyIHRvIHRoZSBtaXJyb3JlZCBwb3J0YWwtc3RhdGVcbiAgICBjb25zdCB1bnN1YiA9IHByZXZpb3VzUm9vdC5zdWJzY3JpYmUocHJldiA9PiB1c2VQb3J0YWxTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiBpbmplY3QocHJldiwgc3RhdGUpKSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVuc3ViKCk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtpbmplY3RdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB1c2VQb3J0YWxTdG9yZS5zZXRTdGF0ZShpbmplY3RTdGF0ZSA9PiBpbmplY3QocHJldmlvdXNSb290LmdldFN0YXRlKCksIGluamVjdFN0YXRlKSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbaW5qZWN0XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVzZVBvcnRhbFN0b3JlLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiByZWNvbmNpbGVyLmNyZWF0ZVBvcnRhbCggLyojX19QVVJFX18qL2pzeChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogdXNlUG9ydGFsU3RvcmUsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KSwgdXNlUG9ydGFsU3RvcmUsIG51bGwpXG4gIH0pO1xufVxucmVjb25jaWxlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICBidW5kbGVUeXBlOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gMCA6IDEsXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdAcmVhY3QtdGhyZWUvZmliZXInLFxuICB2ZXJzaW9uOiBSZWFjdC52ZXJzaW9uXG59KTtcbmNvbnN0IGFjdCA9IFJlYWN0LnVuc3RhYmxlX2FjdDtcblxuZXhwb3J0IHsgdXNlVGhyZWUgYXMgQSwgQmxvY2sgYXMgQiwgdXNlRnJhbWUgYXMgQywgdXNlR3JhcGggYXMgRCwgRXJyb3JCb3VuZGFyeSBhcyBFLCB1c2VMb2FkZXIgYXMgRiwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBhcyBhLCBjcmVhdGVSb290IGFzIGIsIGNyZWF0ZUV2ZW50cyBhcyBjLCB1bm1vdW50Q29tcG9uZW50QXROb2RlIGFzIGQsIGV4dGVuZCBhcyBlLCBjb250ZXh0IGFzIGYsIGNyZWF0ZVBvcnRhbCBhcyBnLCByZWNvbmNpbGVyIGFzIGgsIGlzUmVmIGFzIGksIGFwcGx5UHJvcHMgYXMgaiwgZGlzcG9zZSBhcyBrLCBpbnZhbGlkYXRlIGFzIGwsIGFkdmFuY2UgYXMgbSwgYWRkRWZmZWN0IGFzIG4sIGFkZEFmdGVyRWZmZWN0IGFzIG8sIGFkZFRhaWwgYXMgcCwgZmx1c2hHbG9iYWxFZmZlY3RzIGFzIHEsIHJlbmRlciBhcyByLCBnZXRSb290U3RhdGUgYXMgcywgdGhyZWVUeXBlcyBhcyB0LCB1c2VNdXRhYmxlQ2FsbGJhY2sgYXMgdSwgYWN0IGFzIHYsIGJ1aWxkR3JhcGggYXMgdywgcm9vdHMgYXMgeCwgdXNlSW5zdGFuY2VIYW5kbGUgYXMgeSwgdXNlU3RvcmUgYXMgeiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/index-99983b2d.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   act: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   addEffect: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   addTail: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   advance: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   applyProps: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   context: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   createEvents: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createPortal: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createRoot: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   dispose: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   events: () => (/* binding */ createPointerEvents),\n/* harmony export */   extend: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   getRootState: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   invalidate: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   reconciler: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   render: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   useGraph: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   useLoader: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useStore: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   useThree: () => (/* reexport safe */ _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)\n/* harmony export */ });\n/* harmony import */ var _index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-99983b2d.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-99983b2d.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/web.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst DOM_EVENTS = {\n  onClick: ['click', false],\n  onContextMenu: ['contextmenu', false],\n  onDoubleClick: ['dblclick', false],\n  onWheel: ['wheel', true],\n  onPointerDown: ['pointerdown', true],\n  onPointerUp: ['pointerup', true],\n  onPointerLeave: ['pointerleave', true],\n  onPointerMove: ['pointermove', true],\n  onPointerCancel: ['pointercancel', true],\n  onLostPointerCapture: ['lostpointercapture', true]\n};\n\n/** Default R3F event manager for web */\nfunction createPointerEvents(store) {\n  const {\n    handlePointer\n  } = (0,_index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(store);\n  return {\n    priority: 1,\n    enabled: true,\n    compute(event, state, previous) {\n      // https://github.com/pmndrs/react-three-fiber/pull/782\n      // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n      state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    },\n    connected: undefined,\n    handlers: Object.keys(DOM_EVENTS).reduce((acc, key) => ({\n      ...acc,\n      [key]: handlePointer(key)\n    }), {}),\n    update: () => {\n      var _internal$lastEvent;\n      const {\n        events,\n        internal\n      } = store.getState();\n      if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n    },\n    connect: target => {\n      var _events$handlers;\n      const {\n        set,\n        events\n      } = store.getState();\n      events.disconnect == null ? void 0 : events.disconnect();\n      set(state => ({\n        events: {\n          ...state.events,\n          connected: target\n        }\n      }));\n      Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event]) => {\n        const [eventName, passive] = DOM_EVENTS[name];\n        target.addEventListener(eventName, event, {\n          passive\n        });\n      });\n    },\n    disconnect: () => {\n      const {\n        set,\n        events\n      } = store.getState();\n      if (events.connected) {\n        var _events$handlers2;\n        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event]) => {\n          if (events && events.connected instanceof HTMLElement) {\n            const [eventName] = DOM_EVENTS[name];\n            events.connected.removeEventListener(eventName, event);\n          }\n        });\n        set(state => ({\n          events: {\n            ...state.events,\n            connected: undefined\n          }\n        }));\n      }\n    }\n  };\n}\n\nconst CanvasImpl = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function Canvas({\n  children,\n  fallback,\n  resize,\n  style,\n  gl,\n  events = createPointerEvents,\n  eventSource,\n  eventPrefix,\n  shadows,\n  linear,\n  flat,\n  legacy,\n  orthographic,\n  frameloop,\n  dpr,\n  performance,\n  raycaster,\n  camera,\n  scene,\n  onPointerMissed,\n  onCreated,\n  ...props\n}, forwardedRef) {\n  // Create a known catalogue of Threejs-native elements\n  // This will include the entire THREE namespace by default, users can extend\n  // their own elements by using the createRoot API instead\n  react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (0,_index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__), []);\n  const Bridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_7__.useContextBridge)();\n  const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n    scroll: true,\n    debounce: {\n      scroll: 50,\n      resize: 0\n    },\n    ...resize\n  });\n  const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const divRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(forwardedRef, () => canvasRef.current);\n  const handlePointerMissed = (0,_index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(onPointerMissed);\n  const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n  const [error, setError] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n\n  // Suspend this component if block is a promise (2nd run)\n  if (block) throw block;\n  // Throw exception outwards if anything within canvas throws\n  if (error) throw error;\n  const root = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  (0,_index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(() => {\n    const canvas = canvasRef.current;\n    if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n      if (!root.current) root.current = (0,_index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(canvas);\n      root.current.configure({\n        gl,\n        events,\n        shadows,\n        linear,\n        flat,\n        legacy,\n        orthographic,\n        frameloop,\n        dpr,\n        performance,\n        raycaster,\n        camera,\n        scene,\n        size: containerRect,\n        // Pass mutable reference to onPointerMissed so it's free to update\n        onPointerMissed: (...args) => handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n        onCreated: state => {\n          // Connect to event source\n          state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n          // Set up compute function\n          if (eventPrefix) {\n            state.setEvents({\n              compute: (event, state) => {\n                const x = event[eventPrefix + 'X'];\n                const y = event[eventPrefix + 'Y'];\n                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                state.raycaster.setFromCamera(state.pointer, state.camera);\n              }\n            });\n          }\n          // Call onCreated callback\n          onCreated == null ? void 0 : onCreated(state);\n        }\n      });\n      root.current.render( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Bridge, {\n        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n          set: setError,\n          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n            fallback: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n              set: setBlock\n            }),\n            children: children\n          })\n        })\n      }));\n    }\n  });\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) return () => (0,_index_99983b2d_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n  }, []);\n\n  // When the event source is not this div, we need to set pointer-events to none\n  // Or else the canvas will block events from reaching the event source\n  const pointerEvents = eventSource ? 'none' : 'auto';\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n    ref: divRef,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      pointerEvents,\n      ...style\n    },\n    ...props,\n    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n      ref: containerRef,\n      style: {\n        width: '100%',\n        height: '100%'\n      },\n      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"canvas\", {\n        ref: canvasRef,\n        style: {\n          display: 'block'\n        },\n        children: fallback\n      })\n    })\n  });\n});\n\n/**\r\n * A DOM canvas which accepts threejs elements as children.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\r\n */\nconst Canvas = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function CanvasWrapper(props, ref) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(its_fine__WEBPACK_IMPORTED_MODULE_7__.FiberProvider, {\n    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CanvasImpl, {\n      ...props,\n      ref: ref\n    })\n  });\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTROO0FBQ3lSO0FBQ3RkO0FBQ0E7QUFDWTtBQUNnQjtBQUNuQjtBQUNKO0FBQ25CO0FBQ1M7QUFDUDtBQUNJOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUseURBQVk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssS0FBSztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyw2Q0FBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRSwwQ0FBYSxPQUFPLHlEQUFNLENBQUMsa0NBQUs7QUFDbEMsaUJBQWlCLDBEQUFnQjtBQUNqQyx3Q0FBd0MsNkRBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsb0JBQW9CLHlDQUFZO0FBQ2hDLGlCQUFpQix5Q0FBWTtBQUM3QixFQUFFLHNEQUF5QjtBQUMzQiw4QkFBOEIseURBQWtCO0FBQ2hELDRCQUE0QiwyQ0FBYztBQUMxQyw0QkFBNEIsMkNBQWM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5Q0FBWTtBQUMzQixFQUFFLHlEQUF5QjtBQUMzQjtBQUNBO0FBQ0Esd0NBQXdDLHlEQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLHlEQUFLO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3Q0FBd0Msc0RBQUc7QUFDM0MsK0JBQStCLHNEQUFHLENBQUMscURBQWE7QUFDaEQ7QUFDQSxpQ0FBaUMsc0RBQUcsQ0FBQywyQ0FBYztBQUNuRCxtQ0FBbUMsc0RBQUcsQ0FBQyxxREFBSztBQUM1QztBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQSw2QkFBNkIseURBQXNCO0FBQ25ELEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsc0RBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLHNEQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkNBQWdCO0FBQzVDLHNCQUFzQixzREFBRyxDQUFDLG1EQUFhO0FBQ3ZDLDJCQUEyQixzREFBRztBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVnRCIsInNvdXJjZXMiOlsid2VicGFjazovL2phd2FyYS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvZGlzdC9yZWFjdC10aHJlZS1maWJlci5lc20uanM/MmQxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjIGFzIGNyZWF0ZUV2ZW50cywgZSBhcyBleHRlbmQsIHUgYXMgdXNlTXV0YWJsZUNhbGxiYWNrLCBhIGFzIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIGIgYXMgY3JlYXRlUm9vdCwgaSBhcyBpc1JlZiwgRSBhcyBFcnJvckJvdW5kYXJ5LCBCIGFzIEJsb2NrLCBkIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUgfSBmcm9tICcuL2luZGV4LTk5OTgzYjJkLmVzbS5qcyc7XG5leHBvcnQgeyB0IGFzIFJlYWN0VGhyZWVGaWJlciwgeCBhcyBfcm9vdHMsIHYgYXMgYWN0LCBvIGFzIGFkZEFmdGVyRWZmZWN0LCBuIGFzIGFkZEVmZmVjdCwgcCBhcyBhZGRUYWlsLCBtIGFzIGFkdmFuY2UsIGogYXMgYXBwbHlQcm9wcywgdyBhcyBidWlsZEdyYXBoLCBmIGFzIGNvbnRleHQsIGMgYXMgY3JlYXRlRXZlbnRzLCBnIGFzIGNyZWF0ZVBvcnRhbCwgYiBhcyBjcmVhdGVSb290LCBrIGFzIGRpc3Bvc2UsIGUgYXMgZXh0ZW5kLCBxIGFzIGZsdXNoR2xvYmFsRWZmZWN0cywgcyBhcyBnZXRSb290U3RhdGUsIGwgYXMgaW52YWxpZGF0ZSwgaCBhcyByZWNvbmNpbGVyLCByIGFzIHJlbmRlciwgZCBhcyB1bm1vdW50Q29tcG9uZW50QXROb2RlLCBDIGFzIHVzZUZyYW1lLCBEIGFzIHVzZUdyYXBoLCB5IGFzIHVzZUluc3RhbmNlSGFuZGxlLCBGIGFzIHVzZUxvYWRlciwgeiBhcyB1c2VTdG9yZSwgQSBhcyB1c2VUaHJlZSB9IGZyb20gJy4vaW5kZXgtOTk5ODNiMmQuZXNtLmpzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB1c2VNZWFzdXJlIGZyb20gJ3JlYWN0LXVzZS1tZWFzdXJlJztcbmltcG9ydCB7IEZpYmVyUHJvdmlkZXIsIHVzZUNvbnRleHRCcmlkZ2UgfSBmcm9tICdpdHMtZmluZSc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgJ3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzJztcbmltcG9ydCAnenVzdGFuZCc7XG5pbXBvcnQgJ3JlYWN0LXJlY29uY2lsZXInO1xuaW1wb3J0ICdzY2hlZHVsZXInO1xuaW1wb3J0ICdzdXNwZW5kLXJlYWN0JztcblxuY29uc3QgRE9NX0VWRU5UUyA9IHtcbiAgb25DbGljazogWydjbGljaycsIGZhbHNlXSxcbiAgb25Db250ZXh0TWVudTogWydjb250ZXh0bWVudScsIGZhbHNlXSxcbiAgb25Eb3VibGVDbGljazogWydkYmxjbGljaycsIGZhbHNlXSxcbiAgb25XaGVlbDogWyd3aGVlbCcsIHRydWVdLFxuICBvblBvaW50ZXJEb3duOiBbJ3BvaW50ZXJkb3duJywgdHJ1ZV0sXG4gIG9uUG9pbnRlclVwOiBbJ3BvaW50ZXJ1cCcsIHRydWVdLFxuICBvblBvaW50ZXJMZWF2ZTogWydwb2ludGVybGVhdmUnLCB0cnVlXSxcbiAgb25Qb2ludGVyTW92ZTogWydwb2ludGVybW92ZScsIHRydWVdLFxuICBvblBvaW50ZXJDYW5jZWw6IFsncG9pbnRlcmNhbmNlbCcsIHRydWVdLFxuICBvbkxvc3RQb2ludGVyQ2FwdHVyZTogWydsb3N0cG9pbnRlcmNhcHR1cmUnLCB0cnVlXVxufTtcblxuLyoqIERlZmF1bHQgUjNGIGV2ZW50IG1hbmFnZXIgZm9yIHdlYiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9pbnRlckV2ZW50cyhzdG9yZSkge1xuICBjb25zdCB7XG4gICAgaGFuZGxlUG9pbnRlclxuICB9ID0gY3JlYXRlRXZlbnRzKHN0b3JlKTtcbiAgcmV0dXJuIHtcbiAgICBwcmlvcml0eTogMSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGNvbXB1dGUoZXZlbnQsIHN0YXRlLCBwcmV2aW91cykge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzc4MlxuICAgICAgLy8gRXZlbnRzIHRyaWdnZXIgb3V0c2lkZSBvZiBjYW52YXMgd2hlbiBtb3ZlZCwgdXNlIG9mZnNldFgvWSBieSBkZWZhdWx0IGFuZCBhbGxvdyBvdmVycmlkZXNcbiAgICAgIHN0YXRlLnBvaW50ZXIuc2V0KGV2ZW50Lm9mZnNldFggLyBzdGF0ZS5zaXplLndpZHRoICogMiAtIDEsIC0oZXZlbnQub2Zmc2V0WSAvIHN0YXRlLnNpemUuaGVpZ2h0KSAqIDIgKyAxKTtcbiAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgfSxcbiAgICBjb25uZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICBoYW5kbGVyczogT2JqZWN0LmtleXMoRE9NX0VWRU5UUykucmVkdWNlKChhY2MsIGtleSkgPT4gKHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIFtrZXldOiBoYW5kbGVQb2ludGVyKGtleSlcbiAgICB9KSwge30pLFxuICAgIHVwZGF0ZTogKCkgPT4ge1xuICAgICAgdmFyIF9pbnRlcm5hbCRsYXN0RXZlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKChfaW50ZXJuYWwkbGFzdEV2ZW50ID0gaW50ZXJuYWwubGFzdEV2ZW50KSAhPSBudWxsICYmIF9pbnRlcm5hbCRsYXN0RXZlbnQuY3VycmVudCAmJiBldmVudHMuaGFuZGxlcnMpIGV2ZW50cy5oYW5kbGVycy5vblBvaW50ZXJNb3ZlKGludGVybmFsLmxhc3RFdmVudC5jdXJyZW50KTtcbiAgICB9LFxuICAgIGNvbm5lY3Q6IHRhcmdldCA9PiB7XG4gICAgICB2YXIgX2V2ZW50cyRoYW5kbGVycztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2V0LFxuICAgICAgICBldmVudHNcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgZXZlbnRzLmRpc2Nvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50cy5kaXNjb25uZWN0KCk7XG4gICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIGNvbm5lY3RlZDogdGFyZ2V0XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKChfZXZlbnRzJGhhbmRsZXJzID0gZXZlbnRzLmhhbmRsZXJzKSAhPSBudWxsID8gX2V2ZW50cyRoYW5kbGVycyA6IFtdKS5mb3JFYWNoKChbbmFtZSwgZXZlbnRdKSA9PiB7XG4gICAgICAgIGNvbnN0IFtldmVudE5hbWUsIHBhc3NpdmVdID0gRE9NX0VWRU5UU1tuYW1lXTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudCwge1xuICAgICAgICAgIHBhc3NpdmVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3Q6ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2V0LFxuICAgICAgICBldmVudHNcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKGV2ZW50cy5jb25uZWN0ZWQpIHtcbiAgICAgICAgdmFyIF9ldmVudHMkaGFuZGxlcnMyO1xuICAgICAgICBPYmplY3QuZW50cmllcygoX2V2ZW50cyRoYW5kbGVyczIgPSBldmVudHMuaGFuZGxlcnMpICE9IG51bGwgPyBfZXZlbnRzJGhhbmRsZXJzMiA6IFtdKS5mb3JFYWNoKChbbmFtZSwgZXZlbnRdKSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50cyAmJiBldmVudHMuY29ubmVjdGVkIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IFtldmVudE5hbWVdID0gRE9NX0VWRU5UU1tuYW1lXTtcbiAgICAgICAgICAgIGV2ZW50cy5jb25uZWN0ZWQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAgIGNvbm5lY3RlZDogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBDYW52YXNJbXBsID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ2FudmFzKHtcbiAgY2hpbGRyZW4sXG4gIGZhbGxiYWNrLFxuICByZXNpemUsXG4gIHN0eWxlLFxuICBnbCxcbiAgZXZlbnRzID0gY3JlYXRlUG9pbnRlckV2ZW50cyxcbiAgZXZlbnRTb3VyY2UsXG4gIGV2ZW50UHJlZml4LFxuICBzaGFkb3dzLFxuICBsaW5lYXIsXG4gIGZsYXQsXG4gIGxlZ2FjeSxcbiAgb3J0aG9ncmFwaGljLFxuICBmcmFtZWxvb3AsXG4gIGRwcixcbiAgcGVyZm9ybWFuY2UsXG4gIHJheWNhc3RlcixcbiAgY2FtZXJhLFxuICBzY2VuZSxcbiAgb25Qb2ludGVyTWlzc2VkLFxuICBvbkNyZWF0ZWQsXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkZWRSZWYpIHtcbiAgLy8gQ3JlYXRlIGEga25vd24gY2F0YWxvZ3VlIG9mIFRocmVlanMtbmF0aXZlIGVsZW1lbnRzXG4gIC8vIFRoaXMgd2lsbCBpbmNsdWRlIHRoZSBlbnRpcmUgVEhSRUUgbmFtZXNwYWNlIGJ5IGRlZmF1bHQsIHVzZXJzIGNhbiBleHRlbmRcbiAgLy8gdGhlaXIgb3duIGVsZW1lbnRzIGJ5IHVzaW5nIHRoZSBjcmVhdGVSb290IEFQSSBpbnN0ZWFkXG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4gZXh0ZW5kKFRIUkVFKSwgW10pO1xuICBjb25zdCBCcmlkZ2UgPSB1c2VDb250ZXh0QnJpZGdlKCk7XG4gIGNvbnN0IFtjb250YWluZXJSZWYsIGNvbnRhaW5lclJlY3RdID0gdXNlTWVhc3VyZSh7XG4gICAgc2Nyb2xsOiB0cnVlLFxuICAgIGRlYm91bmNlOiB7XG4gICAgICBzY3JvbGw6IDUwLFxuICAgICAgcmVzaXplOiAwXG4gICAgfSxcbiAgICAuLi5yZXNpemVcbiAgfSk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZGl2UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRlZFJlZiwgKCkgPT4gY2FudmFzUmVmLmN1cnJlbnQpO1xuICBjb25zdCBoYW5kbGVQb2ludGVyTWlzc2VkID0gdXNlTXV0YWJsZUNhbGxiYWNrKG9uUG9pbnRlck1pc3NlZCk7XG4gIGNvbnN0IFtibG9jaywgc2V0QmxvY2tdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBTdXNwZW5kIHRoaXMgY29tcG9uZW50IGlmIGJsb2NrIGlzIGEgcHJvbWlzZSAoMm5kIHJ1bilcbiAgaWYgKGJsb2NrKSB0aHJvdyBibG9jaztcbiAgLy8gVGhyb3cgZXhjZXB0aW9uIG91dHdhcmRzIGlmIGFueXRoaW5nIHdpdGhpbiBjYW52YXMgdGhyb3dzXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gIGNvbnN0IHJvb3QgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmIChjb250YWluZXJSZWN0LndpZHRoID4gMCAmJiBjb250YWluZXJSZWN0LmhlaWdodCA+IDAgJiYgY2FudmFzKSB7XG4gICAgICBpZiAoIXJvb3QuY3VycmVudCkgcm9vdC5jdXJyZW50ID0gY3JlYXRlUm9vdChjYW52YXMpO1xuICAgICAgcm9vdC5jdXJyZW50LmNvbmZpZ3VyZSh7XG4gICAgICAgIGdsLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIHNoYWRvd3MsXG4gICAgICAgIGxpbmVhcixcbiAgICAgICAgZmxhdCxcbiAgICAgICAgbGVnYWN5LFxuICAgICAgICBvcnRob2dyYXBoaWMsXG4gICAgICAgIGZyYW1lbG9vcCxcbiAgICAgICAgZHByLFxuICAgICAgICBwZXJmb3JtYW5jZSxcbiAgICAgICAgcmF5Y2FzdGVyLFxuICAgICAgICBjYW1lcmEsXG4gICAgICAgIHNjZW5lLFxuICAgICAgICBzaXplOiBjb250YWluZXJSZWN0LFxuICAgICAgICAvLyBQYXNzIG11dGFibGUgcmVmZXJlbmNlIHRvIG9uUG9pbnRlck1pc3NlZCBzbyBpdCdzIGZyZWUgdG8gdXBkYXRlXG4gICAgICAgIG9uUG9pbnRlck1pc3NlZDogKC4uLmFyZ3MpID0+IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUG9pbnRlck1pc3NlZC5jdXJyZW50KC4uLmFyZ3MpLFxuICAgICAgICBvbkNyZWF0ZWQ6IHN0YXRlID0+IHtcbiAgICAgICAgICAvLyBDb25uZWN0IHRvIGV2ZW50IHNvdXJjZVxuICAgICAgICAgIHN0YXRlLmV2ZW50cy5jb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29ubmVjdChldmVudFNvdXJjZSA/IGlzUmVmKGV2ZW50U291cmNlKSA/IGV2ZW50U291cmNlLmN1cnJlbnQgOiBldmVudFNvdXJjZSA6IGRpdlJlZi5jdXJyZW50KTtcbiAgICAgICAgICAvLyBTZXQgdXAgY29tcHV0ZSBmdW5jdGlvblxuICAgICAgICAgIGlmIChldmVudFByZWZpeCkge1xuICAgICAgICAgICAgc3RhdGUuc2V0RXZlbnRzKHtcbiAgICAgICAgICAgICAgY29tcHV0ZTogKGV2ZW50LCBzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBldmVudFtldmVudFByZWZpeCArICdYJ107XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IGV2ZW50W2V2ZW50UHJlZml4ICsgJ1knXTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wb2ludGVyLnNldCh4IC8gc3RhdGUuc2l6ZS53aWR0aCAqIDIgLSAxLCAtKHkgLyBzdGF0ZS5zaXplLmhlaWdodCkgKiAyICsgMSk7XG4gICAgICAgICAgICAgICAgc3RhdGUucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoc3RhdGUucG9pbnRlciwgc3RhdGUuY2FtZXJhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhbGwgb25DcmVhdGVkIGNhbGxiYWNrXG4gICAgICAgICAgb25DcmVhdGVkID09IG51bGwgPyB2b2lkIDAgOiBvbkNyZWF0ZWQoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJvb3QuY3VycmVudC5yZW5kZXIoIC8qI19fUFVSRV9fKi9qc3goQnJpZGdlLCB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KEVycm9yQm91bmRhcnksIHtcbiAgICAgICAgICBzZXQ6IHNldEVycm9yLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KFJlYWN0LlN1c3BlbnNlLCB7XG4gICAgICAgICAgICBmYWxsYmFjazogLyojX19QVVJFX18qL2pzeChCbG9jaywge1xuICAgICAgICAgICAgICBzZXQ6IHNldEJsb2NrXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY2FudmFzKSByZXR1cm4gKCkgPT4gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMpO1xuICB9LCBbXSk7XG5cbiAgLy8gV2hlbiB0aGUgZXZlbnQgc291cmNlIGlzIG5vdCB0aGlzIGRpdiwgd2UgbmVlZCB0byBzZXQgcG9pbnRlci1ldmVudHMgdG8gbm9uZVxuICAvLyBPciBlbHNlIHRoZSBjYW52YXMgd2lsbCBibG9jayBldmVudHMgZnJvbSByZWFjaGluZyB0aGUgZXZlbnQgc291cmNlXG4gIGNvbnN0IHBvaW50ZXJFdmVudHMgPSBldmVudFNvdXJjZSA/ICdub25lJyA6ICdhdXRvJztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgIHJlZjogZGl2UmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIHBvaW50ZXJFdmVudHMsXG4gICAgICAuLi5zdHlsZVxuICAgIH0sXG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgICBzdHlsZToge1xuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KFwiY2FudmFzXCIsIHtcbiAgICAgICAgcmVmOiBjYW52YXNSZWYsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZmFsbGJhY2tcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59KTtcblxuLyoqXHJcbiAqIEEgRE9NIGNhbnZhcyB3aGljaCBhY2NlcHRzIHRocmVlanMgZWxlbWVudHMgYXMgY2hpbGRyZW4uXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2NhbnZhc1xyXG4gKi9cbmNvbnN0IENhbnZhcyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhbnZhc1dyYXBwZXIocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChGaWJlclByb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goQ2FudmFzSW1wbCwge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICByZWY6IHJlZlxuICAgIH0pXG4gIH0pO1xufSk7XG5cbmV4cG9ydCB7IENhbnZhcywgY3JlYXRlUG9pbnRlckV2ZW50cyBhcyBldmVudHMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction createStore(createState) {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (nextState !== state) {\n      const previousState = state;\n      state = replace ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is) => {\n    console.warn(\"[DEPRECATED] Please use `subscribeWithSelector` middleware\");\n    let currentSlice = selector(state);\n    function listenerToAdd() {\n      const nextSlice = selector(state);\n      if (!equalityFn(currentSlice, nextSlice)) {\n        const previousSlice = currentSlice;\n        listener(currentSlice = nextSlice, previousSlice);\n      }\n    }\n    listeners.add(listenerToAdd);\n    return () => listeners.delete(listenerToAdd);\n  };\n  const subscribe = (listener, selector, equalityFn) => {\n    if (selector || equalityFn) {\n      return subscribeWithSelector(listener, selector, equalityFn);\n    }\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => listeners.clear();\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n}\n\nconst isSSR = typeof window === \"undefined\" || !window.navigator || /ServerSideRendering|^Deno\\//.test(window.navigator.userAgent);\nconst useIsomorphicLayoutEffect = isSSR ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\nfunction create(createState) {\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useStore = (selector = api.getState, equalityFn = Object.is) => {\n    const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((c) => c + 1, 0);\n    const state = api.getState();\n    const stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    const selectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selector);\n    const equalityFnRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(equalityFn);\n    const erroredRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const currentSliceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (currentSliceRef.current === void 0) {\n      currentSliceRef.current = selector(state);\n    }\n    let newStateSlice;\n    let hasNewStateSlice = false;\n    if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {\n      newStateSlice = selector(state);\n      hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);\n    }\n    useIsomorphicLayoutEffect(() => {\n      if (hasNewStateSlice) {\n        currentSliceRef.current = newStateSlice;\n      }\n      stateRef.current = state;\n      selectorRef.current = selector;\n      equalityFnRef.current = equalityFn;\n      erroredRef.current = false;\n    });\n    const stateBeforeSubscriptionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    useIsomorphicLayoutEffect(() => {\n      const listener = () => {\n        try {\n          const nextState = api.getState();\n          const nextStateSlice = selectorRef.current(nextState);\n          if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {\n            stateRef.current = nextState;\n            currentSliceRef.current = nextStateSlice;\n            forceUpdate();\n          }\n        } catch (error) {\n          erroredRef.current = true;\n          forceUpdate();\n        }\n      };\n      const unsubscribe = api.subscribe(listener);\n      if (api.getState() !== stateBeforeSubscriptionRef.current) {\n        listener();\n      }\n      return unsubscribe;\n    }, []);\n    const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(sliceToReturn);\n    return sliceToReturn;\n  };\n  Object.assign(useStore, api);\n  useStore[Symbol.iterator] = function() {\n    console.warn(\"[useStore, api] = create() is deprecated and will be removed in v4\");\n    const items = [useStore, api];\n    return {\n      next() {\n        const done = items.length <= 0;\n        return { value: items.shift(), done };\n      }\n    };\n  };\n  return useStore;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0Y7O0FBRXRGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyw0Q0FBUyxHQUFHLGtEQUFlO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpREFBVTtBQUN0QztBQUNBLHFCQUFxQiw2Q0FBTTtBQUMzQix3QkFBd0IsNkNBQU07QUFDOUIsMEJBQTBCLDZDQUFNO0FBQ2hDLHVCQUF1Qiw2Q0FBTTtBQUM3Qiw0QkFBNEIsNkNBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1Q0FBdUMsNkNBQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSSxvREFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qYXdhcmEvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9pbmRleC5qcz8zNzY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZHVjZXIsIHVzZVJlZiwgdXNlRGVidWdWYWx1ZSwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKSB7XG4gIGxldCBzdGF0ZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgc2V0U3RhdGUgPSAocGFydGlhbCwgcmVwbGFjZSkgPT4ge1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSBcImZ1bmN0aW9uXCIgPyBwYXJ0aWFsKHN0YXRlKSA6IHBhcnRpYWw7XG4gICAgaWYgKG5leHRTdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcbiAgICAgIHN0YXRlID0gcmVwbGFjZSA/IG5leHRTdGF0ZSA6IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihzdGF0ZSwgcHJldmlvdXNTdGF0ZSkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiBzdGF0ZTtcbiAgY29uc3Qgc3Vic2NyaWJlV2l0aFNlbGVjdG9yID0gKGxpc3RlbmVyLCBzZWxlY3RvciA9IGdldFN0YXRlLCBlcXVhbGl0eUZuID0gT2JqZWN0LmlzKSA9PiB7XG4gICAgY29uc29sZS53YXJuKFwiW0RFUFJFQ0FURURdIFBsZWFzZSB1c2UgYHN1YnNjcmliZVdpdGhTZWxlY3RvcmAgbWlkZGxld2FyZVwiKTtcbiAgICBsZXQgY3VycmVudFNsaWNlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgIGZ1bmN0aW9uIGxpc3RlbmVyVG9BZGQoKSB7XG4gICAgICBjb25zdCBuZXh0U2xpY2UgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICBpZiAoIWVxdWFsaXR5Rm4oY3VycmVudFNsaWNlLCBuZXh0U2xpY2UpKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU2xpY2UgPSBjdXJyZW50U2xpY2U7XG4gICAgICAgIGxpc3RlbmVyKGN1cnJlbnRTbGljZSA9IG5leHRTbGljZSwgcHJldmlvdXNTbGljZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXJUb0FkZCk7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXJUb0FkZCk7XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZSA9IChsaXN0ZW5lciwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pID0+IHtcbiAgICBpZiAoc2VsZWN0b3IgfHwgZXF1YWxpdHlGbikge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZVdpdGhTZWxlY3RvcihsaXN0ZW5lciwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH07XG4gIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgY29uc3QgYXBpID0geyBzZXRTdGF0ZSwgZ2V0U3RhdGUsIHN1YnNjcmliZSwgZGVzdHJveSB9O1xuICBzdGF0ZSA9IGNyZWF0ZVN0YXRlKHNldFN0YXRlLCBnZXRTdGF0ZSwgYXBpKTtcbiAgcmV0dXJuIGFwaTtcbn1cblxuY29uc3QgaXNTU1IgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICF3aW5kb3cubmF2aWdhdG9yIHx8IC9TZXJ2ZXJTaWRlUmVuZGVyaW5nfF5EZW5vXFwvLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBpc1NTUiA/IHVzZUVmZmVjdCA6IHVzZUxheW91dEVmZmVjdDtcbmZ1bmN0aW9uIGNyZWF0ZShjcmVhdGVTdGF0ZSkge1xuICBjb25zdCBhcGkgPSB0eXBlb2YgY3JlYXRlU3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKSA6IGNyZWF0ZVN0YXRlO1xuICBjb25zdCB1c2VTdG9yZSA9IChzZWxlY3RvciA9IGFwaS5nZXRTdGF0ZSwgZXF1YWxpdHlGbiA9IE9iamVjdC5pcykgPT4ge1xuICAgIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVJlZHVjZXIoKGMpID0+IGMgKyAxLCAwKTtcbiAgICBjb25zdCBzdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN0YXRlUmVmID0gdXNlUmVmKHN0YXRlKTtcbiAgICBjb25zdCBzZWxlY3RvclJlZiA9IHVzZVJlZihzZWxlY3Rvcik7XG4gICAgY29uc3QgZXF1YWxpdHlGblJlZiA9IHVzZVJlZihlcXVhbGl0eUZuKTtcbiAgICBjb25zdCBlcnJvcmVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBjdXJyZW50U2xpY2VSZWYgPSB1c2VSZWYoKTtcbiAgICBpZiAoY3VycmVudFNsaWNlUmVmLmN1cnJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgY3VycmVudFNsaWNlUmVmLmN1cnJlbnQgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgfVxuICAgIGxldCBuZXdTdGF0ZVNsaWNlO1xuICAgIGxldCBoYXNOZXdTdGF0ZVNsaWNlID0gZmFsc2U7XG4gICAgaWYgKHN0YXRlUmVmLmN1cnJlbnQgIT09IHN0YXRlIHx8IHNlbGVjdG9yUmVmLmN1cnJlbnQgIT09IHNlbGVjdG9yIHx8IGVxdWFsaXR5Rm5SZWYuY3VycmVudCAhPT0gZXF1YWxpdHlGbiB8fCBlcnJvcmVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIG5ld1N0YXRlU2xpY2UgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICBoYXNOZXdTdGF0ZVNsaWNlID0gIWVxdWFsaXR5Rm4oY3VycmVudFNsaWNlUmVmLmN1cnJlbnQsIG5ld1N0YXRlU2xpY2UpO1xuICAgIH1cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChoYXNOZXdTdGF0ZVNsaWNlKSB7XG4gICAgICAgIGN1cnJlbnRTbGljZVJlZi5jdXJyZW50ID0gbmV3U3RhdGVTbGljZTtcbiAgICAgIH1cbiAgICAgIHN0YXRlUmVmLmN1cnJlbnQgPSBzdGF0ZTtcbiAgICAgIHNlbGVjdG9yUmVmLmN1cnJlbnQgPSBzZWxlY3RvcjtcbiAgICAgIGVxdWFsaXR5Rm5SZWYuY3VycmVudCA9IGVxdWFsaXR5Rm47XG4gICAgICBlcnJvcmVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBjb25zdCBzdGF0ZUJlZm9yZVN1YnNjcmlwdGlvblJlZiA9IHVzZVJlZihzdGF0ZSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBjb25zdCBuZXh0U3RhdGVTbGljZSA9IHNlbGVjdG9yUmVmLmN1cnJlbnQobmV4dFN0YXRlKTtcbiAgICAgICAgICBpZiAoIWVxdWFsaXR5Rm5SZWYuY3VycmVudChjdXJyZW50U2xpY2VSZWYuY3VycmVudCwgbmV4dFN0YXRlU2xpY2UpKSB7XG4gICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50ID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgY3VycmVudFNsaWNlUmVmLmN1cnJlbnQgPSBuZXh0U3RhdGVTbGljZTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGVycm9yZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gYXBpLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgICBpZiAoYXBpLmdldFN0YXRlKCkgIT09IHN0YXRlQmVmb3JlU3Vic2NyaXB0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgc2xpY2VUb1JldHVybiA9IGhhc05ld1N0YXRlU2xpY2UgPyBuZXdTdGF0ZVNsaWNlIDogY3VycmVudFNsaWNlUmVmLmN1cnJlbnQ7XG4gICAgdXNlRGVidWdWYWx1ZShzbGljZVRvUmV0dXJuKTtcbiAgICByZXR1cm4gc2xpY2VUb1JldHVybjtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTdG9yZSwgYXBpKTtcbiAgdXNlU3RvcmVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUud2FybihcIlt1c2VTdG9yZSwgYXBpXSA9IGNyZWF0ZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2NFwiKTtcbiAgICBjb25zdCBpdGVtcyA9IFt1c2VTdG9yZSwgYXBpXTtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgZG9uZSA9IGl0ZW1zLmxlbmd0aCA8PSAwO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbXMuc2hpZnQoKSwgZG9uZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB1c2VTdG9yZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/rapier/dist/react-three-rapier.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/rapier/dist/react-three-rapier.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnyCollider: () => (/* binding */ AnyCollider),\n/* harmony export */   BallCollider: () => (/* binding */ BallCollider),\n/* harmony export */   CapsuleCollider: () => (/* binding */ CapsuleCollider),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.CoefficientCombineRule),\n/* harmony export */   ConeCollider: () => (/* binding */ ConeCollider),\n/* harmony export */   ConvexHullCollider: () => (/* binding */ ConvexHullCollider),\n/* harmony export */   CuboidCollider: () => (/* binding */ CuboidCollider),\n/* harmony export */   CylinderCollider: () => (/* binding */ CylinderCollider),\n/* harmony export */   HeightfieldCollider: () => (/* binding */ HeightfieldCollider),\n/* harmony export */   InstancedRigidBodies: () => (/* binding */ InstancedRigidBodies),\n/* harmony export */   MeshCollider: () => (/* binding */ MeshCollider),\n/* harmony export */   Physics: () => (/* binding */ Physics),\n/* harmony export */   RapierCollider: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Collider),\n/* harmony export */   RapierRigidBody: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.RigidBody),\n/* harmony export */   RigidBody: () => (/* binding */ RigidBody),\n/* harmony export */   RoundConeCollider: () => (/* binding */ RoundConeCollider),\n/* harmony export */   RoundCuboidCollider: () => (/* binding */ RoundCuboidCollider),\n/* harmony export */   RoundCylinderCollider: () => (/* binding */ RoundCylinderCollider),\n/* harmony export */   TrimeshCollider: () => (/* binding */ TrimeshCollider),\n/* harmony export */   euler: () => (/* binding */ euler),\n/* harmony export */   interactionGroups: () => (/* binding */ interactionGroups),\n/* harmony export */   quat: () => (/* binding */ quat),\n/* harmony export */   useAfterPhysicsStep: () => (/* binding */ useAfterPhysicsStep),\n/* harmony export */   useBeforePhysicsStep: () => (/* binding */ useBeforePhysicsStep),\n/* harmony export */   useFixedJoint: () => (/* binding */ useFixedJoint),\n/* harmony export */   useImpulseJoint: () => (/* binding */ useImpulseJoint),\n/* harmony export */   usePrismaticJoint: () => (/* binding */ usePrismaticJoint),\n/* harmony export */   useRapier: () => (/* binding */ useRapier),\n/* harmony export */   useRevoluteJoint: () => (/* binding */ useRevoluteJoint),\n/* harmony export */   useRopeJoint: () => (/* binding */ useRopeJoint),\n/* harmony export */   useSphericalJoint: () => (/* binding */ useSphericalJoint),\n/* harmony export */   useSpringJoint: () => (/* binding */ useSpringJoint),\n/* harmony export */   vec3: () => (/* binding */ vec3)\n/* harmony export */ });\n/* harmony import */ var _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dimforge/rapier3d-compat */ \"(ssr)/./node_modules/@dimforge/rapier3d-compat/rapier.es.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-99983b2d.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/rapier/node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n\n\n\n\n\n\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst _quaternion = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\nnew three__WEBPACK_IMPORTED_MODULE_2__.Euler();\nconst _vector3 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nnew three__WEBPACK_IMPORTED_MODULE_2__.Object3D();\nconst _matrix4 = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\nconst _position = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nconst _rotation = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\nconst _scale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Vector3(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Vector3(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Vector3(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Quaternion(v[0], v[1], v[2], v[3]);\n  } else {\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Quaternion(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n\n  if (v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n\n  if (v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Vector3 || v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Euler) {\n    return [v.x, v.y, v.z];\n  }\n\n  if (Array.isArray(v)) {\n    return v;\n  }\n\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n\n  return ref.current.value;\n}\n\nconst useRaf = callback => {\n  const cb = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(callback);\n  const raf = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n  const lastFrame = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    cb.current = callback;\n  }, [callback]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\n\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.C)((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\n\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\n\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\n\nvar FrameStepper$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FrameStepper);\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice(); // Heightfield uses a vector\n\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  } // Trimesh and convex scale the vertices\n\n\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  } // Prepfill with some extra\n\n\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale); // @ts-ignore\n\n  const desc = _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\n\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setDensity(options.density);\n    return;\n  }\n\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setMass(options.mass);\n    return;\n  }\n\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\n\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n\n  if (state) {\n    var _state$worldParent;\n\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n\n    _matrix4.copy(state.object.matrixWorld);\n\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n\n    _matrix4.decompose(_position, _rotation, _scale);\n\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider, // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    }); // handle mass separately, because the assignments\n    // are exclusive.\n\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\n\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\n\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n\n      const rotationEuler = new three__WEBPACK_IMPORTED_MODULE_2__.Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n\n      childColliderProps.push(colliderProps);\n    }\n  };\n\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3())\n        };\n      }\n\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n\n        const clonedGeometry = geometry.index ? geometry.clone() : (0,three_stdlib__WEBPACK_IMPORTED_MODULE_4__.mergeVertices)(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n        };\n      }\n\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n        };\n      }\n  }\n\n  return {\n    args: [],\n    offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const collider = getCollider();\n\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.COLLISION_EVENTS | _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n\n  return rest;\n};\n\nconst useMutableCallback = fn => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(fn);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n}; // External hooks\n\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\n\n\nconst useRapier = () => {\n  const rapier = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\n\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\n\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n}; // Internal hooks\n\n/**\n * @internal\n */\n\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const object = ref.current;\n\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\n\nconst Debug = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.C)(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    mesh.geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(buffers.vertices, 3));\n    mesh.geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(buffers.colors, 4));\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"group\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n\n      return Reflect.get(instance, prop);\n    },\n\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n\n      return Reflect.set(instance, prop, value);\n    }\n\n  };\n  const proxy = new Proxy({}, handler);\n\n  const reset = () => {\n    instance = undefined;\n  };\n\n  const set = newInstance => {\n    instance = newInstance;\n  };\n  /**\n   * Return the proxy and a reset function\n   */\n\n\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\n\nconst rapierContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\n\nconst importRapier = async () => {\n  let r = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @dimforge/rapier3d-compat */ \"(ssr)/./node_modules/@dimforge/rapier3d-compat/rapier.es.js\"));\n  await r.init();\n  return r;\n};\n\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    erp = 0.8\n  } = props;\n  const rapier = (0,suspend_react__WEBPACK_IMPORTED_MODULE_5__.suspend)(importRapier, [\"@react-thee/rapier\", importRapier]);\n  const {\n    invalidate\n  } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.A)();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []); // Update mutable props\n\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.allowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.predictionDistance = predictionDistance;\n    worldProxy.integrationParameters.erp = erp;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, erp]);\n  const getSourceFromColliderHandle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(handle => {\n    var _collider$parent;\n\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(dt => {\n    const world = worldProxy;\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n\n    const timeStepVariable = timeStep === \"vary\";\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = three__WEBPACK_IMPORTED_MODULE_2__.MathUtils.clamp(dt, 0, 0.5);\n\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue); // Trigger afterStep callbacks\n\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep; // Update meshes\n\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n\n        state.isSleeping = rigidBody.isSleeping();\n      }\n\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      } // New states\n\n\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale); // Apply previous tick position\n\n\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      } // Get new position\n\n\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n          /* Collider events */\n\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      } // Sensor Intersections\n\n\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2()); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Debug, null), children);\n};\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\n * Initiate an instance and return a safe getter\n */\n\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  const getInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n\n    return ref.current;\n  }, dependencyList);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n\n    const destroy = () => destroyFn(instance);\n\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\n\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n};\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\n\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion(x, y, z, w);\n};\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\n\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Euler(x, y, z);\n};\n\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(defaultValue); // Update the forwarded ref when the inner ref changes\n\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n\n    return forwardedRef;\n  }\n\n  return innerRef;\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef) => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(forwardedRef);\n  const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // We spread the props out here to make sure that the ref is updated when the props change.\n\n  const immutablePropArray = immutableColliderOptions.flatMap(key => Array.isArray(props[key]) ? [...props[key]] : props[key]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n\n    if (typeof forwardedRef == \"function\") {\n      forwardedRef(collider);\n    }\n\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n}));\n\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc(type); // Apply immutable options\n\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n\n  const state = states.get(rigidBody.handle);\n\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useRigidBodyContext = () => (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RigidBodyContext);\n\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef) => {\n  const {\n    children,\n    type,\n    position,\n    rotation,\n    scale,\n    quaternion,\n    transformState\n  } = props,\n        objectProps = _objectWithoutProperties(props, _excluded$1);\n\n  const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const rigidBodyRef = useForwardedRef(forwardedRef);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions); // Provide a way to eagerly create rigidbody\n\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(rigidBody);\n    }\n\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray); // Only provide a object state after the ref has been set\n\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n}));\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nconst _excluded = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef) => {\n  const rigidBodiesRef = useForwardedRef(forwardedRef, []);\n  const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const instanceWrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n\n  const {\n    // instanced props\n    children,\n    instances,\n    colliderNodes = [],\n    // wrapper object props\n    position,\n    rotation,\n    quaternion,\n    scale\n  } = props,\n        rigidBodyProps = _objectWithoutProperties(props, _excluded);\n\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n\n    return undefined;\n  };\n\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const instancedMesh = getInstancedMesh();\n\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []); // Update the RigidBodyStates whenever the instances change\n\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n\n    return state;\n  };\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => rigidBodiesRef.current[index] = body,\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, colliderNodes.map((node, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n}));\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\n\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\n\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\n\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\n\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\n\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL3JhcGllci9kaXN0L3JlYWN0LXRocmVlLXJhcGllci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvSjtBQUN2QjtBQUNyRTtBQUNnRjtBQUNwQjtBQUM1RTtBQUNLOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLDZDQUFVO0FBQ2xDLElBQUksd0NBQUs7QUFDVCxxQkFBcUIsMENBQU87QUFDNUIsSUFBSSwyQ0FBUTtBQUNaLHFCQUFxQiwwQ0FBTztBQUM1QixzQkFBc0IsMENBQU87QUFDN0Isc0JBQXNCLDZDQUFVO0FBQ2hDLG1CQUFtQiwwQ0FBTzs7QUFFMUI7QUFDQTtBQUNBLGFBQWEsMENBQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxlQUFlLDhEQUFTO0FBQ3hCLElBQUk7QUFDSixlQUFlLDhEQUFTO0FBQ3hCLElBQUk7QUFDSjtBQUNBLGVBQWUsOERBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFZO0FBQzNCLElBQUk7QUFDSixlQUFlLGlFQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFB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QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQkFBK0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRXllIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamF3YXJhLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9yYXBpZXIvZGlzdC9yZWFjdC10aHJlZS1yYXBpZXIuZXNtLmpzP2MyZjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMyBhcyBWZWN0b3IzJDEsIFF1YXRlcm5pb24gYXMgUXVhdGVybmlvbiQxLCBBY3RpdmVFdmVudHMsIENvbGxpZGVyRGVzYywgRXZlbnRRdWV1ZSwgUmlnaWRCb2R5RGVzYyB9IGZyb20gJ0BkaW1mb3JnZS9yYXBpZXIzZC1jb21wYXQnO1xuZXhwb3J0IHsgQ29lZmZpY2llbnRDb21iaW5lUnVsZSwgQ29sbGlkZXIgYXMgUmFwaWVyQ29sbGlkZXIsIFJpZ2lkQm9keSBhcyBSYXBpZXJSaWdpZEJvZHkgfSBmcm9tICdAZGltZm9yZ2UvcmFwaWVyM2QtY29tcGF0JztcbmltcG9ydCB7IHVzZUZyYW1lLCB1c2VUaHJlZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VFZmZlY3QsIG1lbW8sIHVzZU1lbW8sIHVzZUNvbnRleHQsIHVzZVN0YXRlLCBjcmVhdGVDb250ZXh0LCB1c2VDYWxsYmFjaywgZm9yd2FyZFJlZiwgRnJhZ21lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uLCBFdWxlciwgVmVjdG9yMywgT2JqZWN0M0QsIE1hdHJpeDQsIEJ1ZmZlckF0dHJpYnV0ZSwgTWF0aFV0aWxzLCBEeW5hbWljRHJhd1VzYWdlIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgc3VzcGVuZCB9IGZyb20gJ3N1c3BlbmQtcmVhY3QnO1xuaW1wb3J0IHsgbWVyZ2VWZXJ0aWNlcyB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmNvbnN0IF9xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbm5ldyBFdWxlcigpO1xuY29uc3QgX3ZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xubmV3IE9iamVjdDNEKCk7XG5jb25zdCBfbWF0cml4NCA9IG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3JvdGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF9zY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IHZlY3RvckFycmF5VG9WZWN0b3IzID0gYXJyID0+IHtcbiAgY29uc3QgW3gsIHksIHpdID0gYXJyO1xuICByZXR1cm4gbmV3IFZlY3RvcjMoeCwgeSwgeik7XG59O1xuY29uc3QgcmFwaWVyUXVhdGVybmlvblRvUXVhdGVybmlvbiA9ICh7XG4gIHgsXG4gIHksXG4gIHosXG4gIHdcbn0pID0+IF9xdWF0ZXJuaW9uLnNldCh4LCB5LCB6LCB3KTtcbmNvbnN0IHZlY3RvcjNUb1JhcGllclZlY3RvciA9IHYgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyQxKHZbMF0sIHZbMV0sIHZbMl0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzJDEodiwgdiwgdik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGhyZWVWZWN0b3IzID0gdjtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMkMSh0aHJlZVZlY3RvcjMueCwgdGhyZWVWZWN0b3IzLnksIHRocmVlVmVjdG9yMy56KTtcbiAgfVxufTtcbmNvbnN0IHF1YXRlcm5pb25Ub1JhcGllclF1YXRlcm5pb24gPSB2ID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24kMSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24kMSh2LngsIHYueSwgdi56LCB2LncpO1xuICB9XG59O1xuY29uc3QgcmlnaWRCb2R5VHlwZU1hcCA9IHtcbiAgZml4ZWQ6IDEsXG4gIGR5bmFtaWM6IDAsXG4gIGtpbmVtYXRpY1Bvc2l0aW9uOiAyLFxuICBraW5lbWF0aWNWZWxvY2l0eTogM1xufTtcbmNvbnN0IHJpZ2lkQm9keVR5cGVGcm9tU3RyaW5nID0gdHlwZSA9PiByaWdpZEJvZHlUeXBlTWFwW3R5cGVdO1xuY29uc3Qgc2NhbGVWZXJ0aWNlcyA9ICh2ZXJ0aWNlcywgc2NhbGUpID0+IHtcbiAgY29uc3Qgc2NhbGVkVmVydHMgPSBBcnJheS5mcm9tKHZlcnRpY2VzKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aCAvIDM7IGkrKykge1xuICAgIHNjYWxlZFZlcnRzW2kgKiAzXSAqPSBzY2FsZS54O1xuICAgIHNjYWxlZFZlcnRzW2kgKiAzICsgMV0gKj0gc2NhbGUueTtcbiAgICBzY2FsZWRWZXJ0c1tpICogMyArIDJdICo9IHNjYWxlLno7XG4gIH1cblxuICByZXR1cm4gc2NhbGVkVmVydHM7XG59O1xuY29uc3QgdmVjdG9yVG9UdXBsZSA9IHYgPT4ge1xuICBpZiAoIXYpIHJldHVybiBbMF07XG5cbiAgaWYgKHYgaW5zdGFuY2VvZiBRdWF0ZXJuaW9uKSB7XG4gICAgcmV0dXJuIFt2LngsIHYueSwgdi56LCB2LnddO1xuICB9XG5cbiAgaWYgKHYgaW5zdGFuY2VvZiBWZWN0b3IzIHx8IHYgaW5zdGFuY2VvZiBFdWxlcikge1xuICAgIHJldHVybiBbdi54LCB2LnksIHYuel07XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHJldHVybiB2O1xuICB9XG5cbiAgcmV0dXJuIFt2XTtcbn07XG5mdW5jdGlvbiB1c2VDb25zdChpbml0aWFsVmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKCk7XG5cbiAgaWYgKHJlZi5jdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICByZWYuY3VycmVudCA9IHtcbiAgICAgIHZhbHVlOiB0eXBlb2YgaW5pdGlhbFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBpbml0aWFsVmFsdWUoKSA6IGluaXRpYWxWYWx1ZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcmVmLmN1cnJlbnQudmFsdWU7XG59XG5cbmNvbnN0IHVzZVJhZiA9IGNhbGxiYWNrID0+IHtcbiAgY29uc3QgY2IgPSB1c2VSZWYoY2FsbGJhY2spO1xuICBjb25zdCByYWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IGxhc3RGcmFtZSA9IHVzZVJlZigwKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYi5jdXJyZW50ID0gY2FsbGJhY2s7XG4gIH0sIFtjYWxsYmFja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxvb3AgPSAoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gbm93IC0gbGFzdEZyYW1lLmN1cnJlbnQ7XG4gICAgICByYWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgIGNiLmN1cnJlbnQoZGVsdGEgLyAxMDAwKTtcbiAgICAgIGxhc3RGcmFtZS5jdXJyZW50ID0gbm93O1xuICAgIH07XG5cbiAgICByYWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmLmN1cnJlbnQpO1xuICB9LCBbXSk7XG59O1xuXG5jb25zdCBVc2VGcmFtZVN0ZXBwZXIgPSAoe1xuICBvblN0ZXAsXG4gIHVwZGF0ZVByaW9yaXR5XG59KSA9PiB7XG4gIHVzZUZyYW1lKChfLCBkdCkgPT4ge1xuICAgIG9uU3RlcChkdCk7XG4gIH0sIHVwZGF0ZVByaW9yaXR5KTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBSYWZTdGVwcGVyID0gKHtcbiAgb25TdGVwXG59KSA9PiB7XG4gIHVzZVJhZihkdCA9PiB7XG4gICAgb25TdGVwKGR0KTtcbiAgfSk7XG4gIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgRnJhbWVTdGVwcGVyID0gKHtcbiAgb25TdGVwLFxuICB0eXBlLFxuICB1cGRhdGVQcmlvcml0eVxufSkgPT4ge1xuICByZXR1cm4gdHlwZSA9PT0gXCJpbmRlcGVuZGVudFwiID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmFmU3RlcHBlciwge1xuICAgIG9uU3RlcDogb25TdGVwXG4gIH0pIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVXNlRnJhbWVTdGVwcGVyLCB7XG4gICAgb25TdGVwOiBvblN0ZXAsXG4gICAgdXBkYXRlUHJpb3JpdHk6IHVwZGF0ZVByaW9yaXR5XG4gIH0pO1xufTtcblxudmFyIEZyYW1lU3RlcHBlciQxID0gLyojX19QVVJFX18qL21lbW8oRnJhbWVTdGVwcGVyKTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmNvbnN0IF9leGNsdWRlZCQyID0gW1wibWFzc1wiLCBcImxpbmVhckRhbXBpbmdcIiwgXCJhbmd1bGFyRGFtcGluZ1wiLCBcInR5cGVcIiwgXCJvbkNvbGxpc2lvbkVudGVyXCIsIFwib25Db2xsaXNpb25FeGl0XCIsIFwib25JbnRlcnNlY3Rpb25FbnRlclwiLCBcIm9uSW50ZXJzZWN0aW9uRXhpdFwiLCBcIm9uQ29udGFjdEZvcmNlXCIsIFwiY2hpbGRyZW5cIiwgXCJjYW5TbGVlcFwiLCBcImNjZFwiLCBcImdyYXZpdHlTY2FsZVwiXTtcbmNvbnN0IHNjYWxlQ29sbGlkZXJBcmdzID0gKHNoYXBlLCBhcmdzLCBzY2FsZSkgPT4ge1xuICBjb25zdCBuZXdBcmdzID0gYXJncy5zbGljZSgpOyAvLyBIZWlnaHRmaWVsZCB1c2VzIGEgdmVjdG9yXG5cbiAgaWYgKHNoYXBlID09PSBcImhlaWdodGZpZWxkXCIpIHtcbiAgICBjb25zdCBzID0gbmV3QXJnc1szXTtcbiAgICBzLnggKj0gc2NhbGUueDtcbiAgICBzLnggKj0gc2NhbGUueTtcbiAgICBzLnggKj0gc2NhbGUuejtcbiAgICByZXR1cm4gbmV3QXJncztcbiAgfSAvLyBUcmltZXNoIGFuZCBjb252ZXggc2NhbGUgdGhlIHZlcnRpY2VzXG5cblxuICBpZiAoc2hhcGUgPT09IFwidHJpbWVzaFwiIHx8IHNoYXBlID09PSBcImNvbnZleEh1bGxcIikge1xuICAgIG5ld0FyZ3NbMF0gPSBzY2FsZVZlcnRpY2VzKG5ld0FyZ3NbMF0sIHNjYWxlKTtcbiAgICByZXR1cm4gbmV3QXJncztcbiAgfSAvLyBQcmVwZmlsbCB3aXRoIHNvbWUgZXh0cmFcblxuXG4gIGNvbnN0IHNjYWxlQXJyYXkgPSBbc2NhbGUueCwgc2NhbGUueSwgc2NhbGUueiwgc2NhbGUueCwgc2NhbGUueF07XG4gIHJldHVybiBuZXdBcmdzLm1hcCgoYXJnLCBpbmRleCkgPT4gc2NhbGVBcnJheVtpbmRleF0gKiBhcmcpO1xufTtcbmNvbnN0IGNyZWF0ZUNvbGxpZGVyRnJvbU9wdGlvbnMgPSAob3B0aW9ucywgd29ybGQsIHNjYWxlLCBnZXRSaWdpZEJvZHkpID0+IHtcbiAgY29uc3Qgc2NhbGVkQXJncyA9IHNjYWxlQ29sbGlkZXJBcmdzKG9wdGlvbnMuc2hhcGUsIG9wdGlvbnMuYXJncywgc2NhbGUpOyAvLyBAdHMtaWdub3JlXG5cbiAgY29uc3QgZGVzYyA9IENvbGxpZGVyRGVzY1tvcHRpb25zLnNoYXBlXSguLi5zY2FsZWRBcmdzKTtcbiAgcmV0dXJuIHdvcmxkLmNyZWF0ZUNvbGxpZGVyKGRlc2MsIGdldFJpZ2lkQm9keSA9PT0gbnVsbCB8fCBnZXRSaWdpZEJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldFJpZ2lkQm9keSgpKTtcbn07XG5jb25zdCBpbW11dGFibGVDb2xsaWRlck9wdGlvbnMgPSBbXCJzaGFwZVwiLCBcImFyZ3NcIl07XG5jb25zdCBtYXNzUHJvcGVydGllc0NvbmZsaWN0RXJyb3IgPSBcIlBsZWFzZSBwaWNrIE9OTFkgT05FIG9mIHRoZSBgZGVuc2l0eWAsIGBtYXNzYCBhbmQgYG1hc3NQcm9wZXJ0aWVzYCBvcHRpb25zLlwiO1xuXG5jb25zdCBzZXRDb2xsaWRlck1hc3NPcHRpb25zID0gKGNvbGxpZGVyLCBvcHRpb25zKSA9PiB7XG4gIGlmIChvcHRpb25zLmRlbnNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLm1hc3MgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1hc3NQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtYXNzUHJvcGVydGllc0NvbmZsaWN0RXJyb3IpO1xuICAgIH1cblxuICAgIGNvbGxpZGVyLnNldERlbnNpdHkob3B0aW9ucy5kZW5zaXR5KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob3B0aW9ucy5tYXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5tYXNzUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWFzc1Byb3BlcnRpZXNDb25mbGljdEVycm9yKTtcbiAgICB9XG5cbiAgICBjb2xsaWRlci5zZXRNYXNzKG9wdGlvbnMubWFzcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMubWFzc1Byb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbGxpZGVyLnNldE1hc3NQcm9wZXJ0aWVzKG9wdGlvbnMubWFzc1Byb3BlcnRpZXMubWFzcywgb3B0aW9ucy5tYXNzUHJvcGVydGllcy5jZW50ZXJPZk1hc3MsIG9wdGlvbnMubWFzc1Byb3BlcnRpZXMucHJpbmNpcGFsQW5ndWxhckluZXJ0aWEsIG9wdGlvbnMubWFzc1Byb3BlcnRpZXMuYW5ndWxhckluZXJ0aWFMb2NhbEZyYW1lKTtcbiAgfVxufTtcblxuY29uc3QgbXV0YWJsZUNvbGxpZGVyT3B0aW9ucyA9IHtcbiAgc2Vuc29yOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0U2Vuc29yKHZhbHVlKTtcbiAgfSxcbiAgY29sbGlzaW9uR3JvdXBzOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0Q29sbGlzaW9uR3JvdXBzKHZhbHVlKTtcbiAgfSxcbiAgc29sdmVyR3JvdXBzOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0U29sdmVyR3JvdXBzKHZhbHVlKTtcbiAgfSxcbiAgZnJpY3Rpb246IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRGcmljdGlvbih2YWx1ZSk7XG4gIH0sXG4gIGZyaWN0aW9uQ29tYmluZVJ1bGU6IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRGcmljdGlvbkNvbWJpbmVSdWxlKHZhbHVlKTtcbiAgfSxcbiAgcmVzdGl0dXRpb246IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRSZXN0aXR1dGlvbih2YWx1ZSk7XG4gIH0sXG4gIHJlc3RpdHV0aW9uQ29tYmluZVJ1bGU6IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRSZXN0aXR1dGlvbkNvbWJpbmVSdWxlKHZhbHVlKTtcbiAgfSxcbiAgLy8gVG8gbWFrZSBzdXJlIHRoZSBvcHRpb25zIGFsbCBtdXRhYmxlIG9wdGlvbnMgYXJlIGxpc3RlZFxuICBxdWF0ZXJuaW9uOiAoKSA9PiB7fSxcbiAgcG9zaXRpb246ICgpID0+IHt9LFxuICByb3RhdGlvbjogKCkgPT4ge30sXG4gIHNjYWxlOiAoKSA9PiB7fVxufTtcbmNvbnN0IG11dGFibGVDb2xsaWRlck9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhtdXRhYmxlQ29sbGlkZXJPcHRpb25zKTtcbmNvbnN0IHNldENvbGxpZGVyT3B0aW9ucyA9IChjb2xsaWRlciwgb3B0aW9ucywgc3RhdGVzKSA9PiB7XG4gIGNvbnN0IHN0YXRlID0gc3RhdGVzLmdldChjb2xsaWRlci5oYW5kbGUpO1xuXG4gIGlmIChzdGF0ZSkge1xuICAgIHZhciBfc3RhdGUkd29ybGRQYXJlbnQ7XG5cbiAgICAvLyBVcGRhdGUgY29sbGlkZXIgcG9zaXRpb24gYmFzZWQgb24gdGhlIG9iamVjdCdzIHBvc2l0aW9uXG4gICAgY29uc3QgcGFyZW50V29ybGRTY2FsZSA9IHN0YXRlLm9iamVjdC5wYXJlbnQuZ2V0V29ybGRTY2FsZShfdmVjdG9yMyk7XG4gICAgY29uc3QgcGFyZW50SW52ZXJ0ZWRXb3JsZE1hdHJpeCA9IChfc3RhdGUkd29ybGRQYXJlbnQgPSBzdGF0ZS53b3JsZFBhcmVudCkgPT09IG51bGwgfHwgX3N0YXRlJHdvcmxkUGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkd29ybGRQYXJlbnQubWF0cml4V29ybGQuY2xvbmUoKS5pbnZlcnQoKTtcbiAgICBzdGF0ZS5vYmplY3QudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXG4gICAgX21hdHJpeDQuY29weShzdGF0ZS5vYmplY3QubWF0cml4V29ybGQpO1xuXG4gICAgaWYgKHBhcmVudEludmVydGVkV29ybGRNYXRyaXgpIHtcbiAgICAgIF9tYXRyaXg0LnByZW11bHRpcGx5KHBhcmVudEludmVydGVkV29ybGRNYXRyaXgpO1xuICAgIH1cblxuICAgIF9tYXRyaXg0LmRlY29tcG9zZShfcG9zaXRpb24sIF9yb3RhdGlvbiwgX3NjYWxlKTtcblxuICAgIGlmIChjb2xsaWRlci5wYXJlbnQoKSkge1xuICAgICAgY29sbGlkZXIuc2V0VHJhbnNsYXRpb25XcnRQYXJlbnQoe1xuICAgICAgICB4OiBfcG9zaXRpb24ueCAqIHBhcmVudFdvcmxkU2NhbGUueCxcbiAgICAgICAgeTogX3Bvc2l0aW9uLnkgKiBwYXJlbnRXb3JsZFNjYWxlLnksXG4gICAgICAgIHo6IF9wb3NpdGlvbi56ICogcGFyZW50V29ybGRTY2FsZS56XG4gICAgICB9KTtcbiAgICAgIGNvbGxpZGVyLnNldFJvdGF0aW9uV3J0UGFyZW50KF9yb3RhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbGxpZGVyLnNldFRyYW5zbGF0aW9uKHtcbiAgICAgICAgeDogX3Bvc2l0aW9uLnggKiBwYXJlbnRXb3JsZFNjYWxlLngsXG4gICAgICAgIHk6IF9wb3NpdGlvbi55ICogcGFyZW50V29ybGRTY2FsZS55LFxuICAgICAgICB6OiBfcG9zaXRpb24ueiAqIHBhcmVudFdvcmxkU2NhbGUuelxuICAgICAgfSk7XG4gICAgICBjb2xsaWRlci5zZXRSb3RhdGlvbihfcm90YXRpb24pO1xuICAgIH1cblxuICAgIG11dGFibGVDb2xsaWRlck9wdGlvbktleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgbXV0YWJsZUNvbGxpZGVyT3B0aW9uc1trZXldKGNvbGxpZGVyLCAvLyBAdHMtaWdub3JlIE9wdGlvbiBkb2VzIG5vdCB3YW50IHRvIGZpdCBpbnRvIHRoZSBmdW5jdGlvbiwgYnV0IGl0IHdpbGxcbiAgICAgICAgb3B0aW9uLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gaGFuZGxlIG1hc3Mgc2VwYXJhdGVseSwgYmVjYXVzZSB0aGUgYXNzaWdubWVudHNcbiAgICAvLyBhcmUgZXhjbHVzaXZlLlxuXG4gICAgc2V0Q29sbGlkZXJNYXNzT3B0aW9ucyhjb2xsaWRlciwgb3B0aW9ucyk7XG4gIH1cbn07XG5jb25zdCB1c2VVcGRhdGVDb2xsaWRlck9wdGlvbnMgPSAoZ2V0Q29sbGlkZXIsIHByb3BzLCBzdGF0ZXMpID0+IHtcbiAgLy8gVE9ETzogSW1wcm92ZSB0aGlzLCBzcGxpdCBlYWNoIHByb3AgaW50byBpdHMgb3duIGVmZmVjdFxuICBjb25zdCBtdXRhYmxlUHJvcHNBc0ZsYXRBcnJheSA9IHVzZU1lbW8oKCkgPT4gbXV0YWJsZUNvbGxpZGVyT3B0aW9uS2V5cy5mbGF0TWFwKGtleSA9PiB7XG4gICAgcmV0dXJuIHZlY3RvclRvVHVwbGUocHJvcHNba2V5XSk7XG4gIH0pLCBbcHJvcHNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb2xsaWRlciA9IGdldENvbGxpZGVyKCk7XG4gICAgc2V0Q29sbGlkZXJPcHRpb25zKGNvbGxpZGVyLCBwcm9wcywgc3RhdGVzKTtcbiAgfSwgWy4uLm11dGFibGVQcm9wc0FzRmxhdEFycmF5LCBnZXRDb2xsaWRlcl0pO1xufTtcblxuY29uc3QgaXNDaGlsZE9mTWVzaENvbGxpZGVyID0gY2hpbGQgPT4ge1xuICBsZXQgZmxhZyA9IGZhbHNlO1xuICBjaGlsZC50cmF2ZXJzZUFuY2VzdG9ycyhhID0+IHtcbiAgICBpZiAoYS51c2VyRGF0YS5yM1JhcGllclR5cGUgPT09IFwiTWVzaENvbGxpZGVyXCIpIGZsYWcgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIGZsYWc7XG59O1xuXG5jb25zdCBjcmVhdGVDb2xsaWRlclN0YXRlID0gKGNvbGxpZGVyLCBvYmplY3QsIHJpZ2lkQm9keU9iamVjdCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbGxpZGVyLFxuICAgIHdvcmxkUGFyZW50OiByaWdpZEJvZHlPYmplY3QgfHwgdW5kZWZpbmVkLFxuICAgIG9iamVjdFxuICB9O1xufTtcbmNvbnN0IGF1dG9Db2xsaWRlck1hcCA9IHtcbiAgY3Vib2lkOiBcImN1Ym9pZFwiLFxuICBiYWxsOiBcImJhbGxcIixcbiAgaHVsbDogXCJjb252ZXhIdWxsXCIsXG4gIHRyaW1lc2g6IFwidHJpbWVzaFwiXG59O1xuY29uc3QgY3JlYXRlQ29sbGlkZXJQcm9wc0Zyb21DaGlsZHJlbiA9ICh7XG4gIG9iamVjdCxcbiAgaWdub3JlTWVzaENvbGxpZGVyczogX2lnbm9yZU1lc2hDb2xsaWRlcnMgPSB0cnVlLFxuICBvcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGNoaWxkQ29sbGlkZXJQcm9wcyA9IFtdO1xuICBvYmplY3QudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICBjb25zdCBpbnZlcnRlZFBhcmVudE1hdHJpeFdvcmxkID0gb2JqZWN0Lm1hdHJpeFdvcmxkLmNsb25lKCkuaW52ZXJ0KCk7XG5cbiAgY29uc3QgY29sbGlkZXJGcm9tQ2hpbGQgPSBjaGlsZCA9PiB7XG4gICAgaWYgKFwiaXNNZXNoXCIgaW4gY2hpbGQpIHtcbiAgICAgIGlmIChfaWdub3JlTWVzaENvbGxpZGVycyAmJiBpc0NoaWxkT2ZNZXNoQ29sbGlkZXIoY2hpbGQpKSByZXR1cm47XG4gICAgICBjb25zdCB3b3JsZFNjYWxlID0gY2hpbGQuZ2V0V29ybGRTY2FsZShfc2NhbGUpO1xuICAgICAgY29uc3Qgc2hhcGUgPSBhdXRvQ29sbGlkZXJNYXBbb3B0aW9ucy5jb2xsaWRlcnMgfHwgXCJjdWJvaWRcIl07XG4gICAgICBjaGlsZC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cbiAgICAgIF9tYXRyaXg0LmNvcHkoY2hpbGQubWF0cml4V29ybGQpLnByZW11bHRpcGx5KGludmVydGVkUGFyZW50TWF0cml4V29ybGQpLmRlY29tcG9zZShfcG9zaXRpb24sIF9yb3RhdGlvbiwgX3NjYWxlKTtcblxuICAgICAgY29uc3Qgcm90YXRpb25FdWxlciA9IG5ldyBFdWxlcigpLnNldEZyb21RdWF0ZXJuaW9uKF9yb3RhdGlvbiwgXCJYWVpcIik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGdlb21ldHJ5XG4gICAgICB9ID0gY2hpbGQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IGdldENvbGxpZGVyQXJnc0Zyb21HZW9tZXRyeShnZW9tZXRyeSwgb3B0aW9ucy5jb2xsaWRlcnMgfHwgXCJjdWJvaWRcIik7XG5cbiAgICAgIGNvbnN0IGNvbGxpZGVyUHJvcHMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY2xlYW5SaWdpZEJvZHlQcm9wc0ZvckNvbGxpZGVyKG9wdGlvbnMpKSwge30sIHtcbiAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICByb3RhdGlvbjogW3JvdGF0aW9uRXVsZXIueCwgcm90YXRpb25FdWxlci55LCByb3RhdGlvbkV1bGVyLnpdLFxuICAgICAgICBwb3NpdGlvbjogW19wb3NpdGlvbi54ICsgb2Zmc2V0LnggKiB3b3JsZFNjYWxlLngsIF9wb3NpdGlvbi55ICsgb2Zmc2V0LnkgKiB3b3JsZFNjYWxlLnksIF9wb3NpdGlvbi56ICsgb2Zmc2V0LnogKiB3b3JsZFNjYWxlLnpdLFxuICAgICAgICBzY2FsZTogW3dvcmxkU2NhbGUueCwgd29ybGRTY2FsZS55LCB3b3JsZFNjYWxlLnpdXG4gICAgICB9KTtcblxuICAgICAgY2hpbGRDb2xsaWRlclByb3BzLnB1c2goY29sbGlkZXJQcm9wcyk7XG4gICAgfVxuICB9O1xuXG4gIGlmIChvcHRpb25zLmluY2x1ZGVJbnZpc2libGUpIHtcbiAgICBvYmplY3QudHJhdmVyc2UoY29sbGlkZXJGcm9tQ2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdC50cmF2ZXJzZVZpc2libGUoY29sbGlkZXJGcm9tQ2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkQ29sbGlkZXJQcm9wcztcbn07XG5jb25zdCBnZXRDb2xsaWRlckFyZ3NGcm9tR2VvbWV0cnkgPSAoZ2VvbWV0cnksIGNvbGxpZGVycykgPT4ge1xuICBzd2l0Y2ggKGNvbGxpZGVycykge1xuICAgIGNhc2UgXCJjdWJvaWRcIjpcbiAgICAgIHtcbiAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBib3VuZGluZ0JveFxuICAgICAgICB9ID0gZ2VvbWV0cnk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBib3VuZGluZ0JveC5nZXRTaXplKG5ldyBWZWN0b3IzKCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3M6IFtzaXplLnggLyAyLCBzaXplLnkgLyAyLCBzaXplLnogLyAyXSxcbiAgICAgICAgICBvZmZzZXQ6IGJvdW5kaW5nQm94LmdldENlbnRlcihuZXcgVmVjdG9yMygpKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSBcImJhbGxcIjpcbiAgICAgIHtcbiAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBib3VuZGluZ1NwaGVyZVxuICAgICAgICB9ID0gZ2VvbWV0cnk7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGJvdW5kaW5nU3BoZXJlLnJhZGl1cztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmdzOiBbcmFkaXVzXSxcbiAgICAgICAgICBvZmZzZXQ6IGJvdW5kaW5nU3BoZXJlLmNlbnRlclxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSBcInRyaW1lc2hcIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9jbG9uZWRHZW9tZXRyeSRpbmRleDtcblxuICAgICAgICBjb25zdCBjbG9uZWRHZW9tZXRyeSA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuY2xvbmUoKSA6IG1lcmdlVmVydGljZXMoZ2VvbWV0cnkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3M6IFtjbG9uZWRHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5LCAoX2Nsb25lZEdlb21ldHJ5JGluZGV4ID0gY2xvbmVkR2VvbWV0cnkuaW5kZXgpID09PSBudWxsIHx8IF9jbG9uZWRHZW9tZXRyeSRpbmRleCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Nsb25lZEdlb21ldHJ5JGluZGV4LmFycmF5XSxcbiAgICAgICAgICBvZmZzZXQ6IG5ldyBWZWN0b3IzKClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGNhc2UgXCJodWxsXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGcgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3M6IFtnLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXldLFxuICAgICAgICAgIG9mZnNldDogbmV3IFZlY3RvcjMoKVxuICAgICAgICB9O1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhcmdzOiBbXSxcbiAgICBvZmZzZXQ6IG5ldyBWZWN0b3IzKClcbiAgfTtcbn07XG5jb25zdCBnZXRBY3RpdmVDb2xsaXNpb25FdmVudHNGcm9tUHJvcHMgPSBwcm9wcyA9PiB7XG4gIHJldHVybiB7XG4gICAgY29sbGlzaW9uOiAhIShwcm9wcyAhPT0gbnVsbCAmJiBwcm9wcyAhPT0gdm9pZCAwICYmIHByb3BzLm9uQ29sbGlzaW9uRW50ZXIgfHwgcHJvcHMgIT09IG51bGwgJiYgcHJvcHMgIT09IHZvaWQgMCAmJiBwcm9wcy5vbkNvbGxpc2lvbkV4aXQgfHwgcHJvcHMgIT09IG51bGwgJiYgcHJvcHMgIT09IHZvaWQgMCAmJiBwcm9wcy5vbkludGVyc2VjdGlvbkVudGVyIHx8IHByb3BzICE9PSBudWxsICYmIHByb3BzICE9PSB2b2lkIDAgJiYgcHJvcHMub25JbnRlcnNlY3Rpb25FeGl0KSxcbiAgICBjb250YWN0Rm9yY2U6ICEhKHByb3BzICE9PSBudWxsICYmIHByb3BzICE9PSB2b2lkIDAgJiYgcHJvcHMub25Db250YWN0Rm9yY2UpXG4gIH07XG59O1xuY29uc3QgdXNlQ29sbGlkZXJFdmVudHMgPSAoZ2V0Q29sbGlkZXIsIHByb3BzLCBldmVudHMsXG4vKipcbiAqIFRoZSBSaWdpZEJvZHkgY2FuIHBhc3MgZG93biBhY3RpdmUgZXZlbnRzIHRvIHRoZSBjb2xsaWRlciB3aXRob3V0IGF0dGFjaGluZyB0aGUgZXZlbnQgbGlzdG5lcnNcbiAqL1xuYWN0aXZlRXZlbnRzID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIG9uQ29sbGlzaW9uRW50ZXIsXG4gICAgb25Db2xsaXNpb25FeGl0LFxuICAgIG9uSW50ZXJzZWN0aW9uRW50ZXIsXG4gICAgb25JbnRlcnNlY3Rpb25FeGl0LFxuICAgIG9uQ29udGFjdEZvcmNlXG4gIH0gPSBwcm9wcztcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb2xsaWRlciA9IGdldENvbGxpZGVyKCk7XG5cbiAgICBpZiAoY29sbGlkZXIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29sbGlzaW9uOiBjb2xsaXNpb25FdmVudHNBY3RpdmUsXG4gICAgICAgIGNvbnRhY3RGb3JjZTogY29udGFjdEZvcmNlRXZlbnRzQWN0aXZlXG4gICAgICB9ID0gZ2V0QWN0aXZlQ29sbGlzaW9uRXZlbnRzRnJvbVByb3BzKHByb3BzKTtcbiAgICAgIGNvbnN0IGhhc0NvbGxpc2lvbkV2ZW50ID0gY29sbGlzaW9uRXZlbnRzQWN0aXZlIHx8IGFjdGl2ZUV2ZW50cy5jb2xsaXNpb247XG4gICAgICBjb25zdCBoYXNDb250YWN0Rm9yY2VFdmVudCA9IGNvbnRhY3RGb3JjZUV2ZW50c0FjdGl2ZSB8fCBhY3RpdmVFdmVudHMuY29udGFjdEZvcmNlO1xuXG4gICAgICBpZiAoaGFzQ29sbGlzaW9uRXZlbnQgJiYgaGFzQ29udGFjdEZvcmNlRXZlbnQpIHtcbiAgICAgICAgY29sbGlkZXIuc2V0QWN0aXZlRXZlbnRzKEFjdGl2ZUV2ZW50cy5DT0xMSVNJT05fRVZFTlRTIHwgQWN0aXZlRXZlbnRzLkNPTlRBQ1RfRk9SQ0VfRVZFTlRTKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ29sbGlzaW9uRXZlbnQpIHtcbiAgICAgICAgY29sbGlkZXIuc2V0QWN0aXZlRXZlbnRzKEFjdGl2ZUV2ZW50cy5DT0xMSVNJT05fRVZFTlRTKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ29udGFjdEZvcmNlRXZlbnQpIHtcbiAgICAgICAgY29sbGlkZXIuc2V0QWN0aXZlRXZlbnRzKEFjdGl2ZUV2ZW50cy5DT05UQUNUX0ZPUkNFX0VWRU5UUyk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cy5zZXQoY29sbGlkZXIuaGFuZGxlLCB7XG4gICAgICAgIG9uQ29sbGlzaW9uRW50ZXIsXG4gICAgICAgIG9uQ29sbGlzaW9uRXhpdCxcbiAgICAgICAgb25JbnRlcnNlY3Rpb25FbnRlcixcbiAgICAgICAgb25JbnRlcnNlY3Rpb25FeGl0LFxuICAgICAgICBvbkNvbnRhY3RGb3JjZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChjb2xsaWRlcikge1xuICAgICAgICBldmVudHMuZGVsZXRlKGNvbGxpZGVyLmhhbmRsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW29uQ29sbGlzaW9uRW50ZXIsIG9uQ29sbGlzaW9uRXhpdCwgb25JbnRlcnNlY3Rpb25FbnRlciwgb25JbnRlcnNlY3Rpb25FeGl0LCBvbkNvbnRhY3RGb3JjZSwgYWN0aXZlRXZlbnRzXSk7XG59O1xuY29uc3QgY2xlYW5SaWdpZEJvZHlQcm9wc0ZvckNvbGxpZGVyID0gKHByb3BzID0ge30pID0+IHtcbiAgY29uc3QgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkJDIpO1xuXG4gIHJldHVybiByZXN0O1xufTtcblxuY29uc3QgdXNlTXV0YWJsZUNhbGxiYWNrID0gZm4gPT4ge1xuICBjb25zdCByZWYgPSB1c2VSZWYoZm4pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gZm47XG4gIH0sIFtmbl0pO1xuICByZXR1cm4gcmVmO1xufTsgLy8gRXh0ZXJuYWwgaG9va3NcblxuLyoqXG4gKiBFeHBvc2VzIHRoZSBSYXBpZXIgY29udGV4dCwgYW5kIHdvcmxkXG4gKiBAY2F0ZWdvcnkgSG9va3NcbiAqL1xuXG5cbmNvbnN0IHVzZVJhcGllciA9ICgpID0+IHtcbiAgY29uc3QgcmFwaWVyID0gdXNlQ29udGV4dChyYXBpZXJDb250ZXh0KTtcbiAgaWYgKCFyYXBpZXIpIHRocm93IG5ldyBFcnJvcihcInJlYWN0LXRocmVlLXJhcGllcjogdXNlUmFwaWVyIG11c3QgYmUgdXNlZCB3aXRoaW4gPFBoeXNpY3MgLz4hXCIpO1xuICByZXR1cm4gcmFwaWVyO1xufTtcbi8qKlxuICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGJlZm9yZSB0aGUgcGh5c2ljcyBzdGVwXG4gKiBAY2F0ZWdvcnkgSG9va3NcbiAqL1xuXG5jb25zdCB1c2VCZWZvcmVQaHlzaWNzU3RlcCA9IGNhbGxiYWNrID0+IHtcbiAgY29uc3Qge1xuICAgIGJlZm9yZVN0ZXBDYWxsYmFja3NcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCByZWYgPSB1c2VNdXRhYmxlQ2FsbGJhY2soY2FsbGJhY2spO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGJlZm9yZVN0ZXBDYWxsYmFja3MuYWRkKHJlZik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGJlZm9yZVN0ZXBDYWxsYmFja3MuZGVsZXRlKHJlZik7XG4gICAgfTtcbiAgfSwgW10pO1xufTtcbi8qKlxuICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSBwaHlzaWNzIHN0ZXBcbiAqIEBjYXRlZ29yeSBIb29rc1xuICovXG5cbmNvbnN0IHVzZUFmdGVyUGh5c2ljc1N0ZXAgPSBjYWxsYmFjayA9PiB7XG4gIGNvbnN0IHtcbiAgICBhZnRlclN0ZXBDYWxsYmFja3NcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCByZWYgPSB1c2VNdXRhYmxlQ2FsbGJhY2soY2FsbGJhY2spO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFmdGVyU3RlcENhbGxiYWNrcy5hZGQocmVmKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYWZ0ZXJTdGVwQ2FsbGJhY2tzLmRlbGV0ZShyZWYpO1xuICAgIH07XG4gIH0sIFtdKTtcbn07IC8vIEludGVybmFsIGhvb2tzXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuY29uc3QgdXNlQ2hpbGRDb2xsaWRlclByb3BzID0gKHJlZiwgb3B0aW9ucywgaWdub3JlTWVzaENvbGxpZGVycyA9IHRydWUpID0+IHtcbiAgY29uc3QgW2NvbGxpZGVyUHJvcHMsIHNldENvbGxpZGVyUHJvcHNdID0gdXNlU3RhdGUoW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG9iamVjdCA9IHJlZi5jdXJyZW50O1xuXG4gICAgaWYgKG9iamVjdCAmJiBvcHRpb25zLmNvbGxpZGVycyAhPT0gZmFsc2UpIHtcbiAgICAgIHNldENvbGxpZGVyUHJvcHMoY3JlYXRlQ29sbGlkZXJQcm9wc0Zyb21DaGlsZHJlbih7XG4gICAgICAgIG9iamVjdDogcmVmLmN1cnJlbnQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGlnbm9yZU1lc2hDb2xsaWRlcnNcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFtvcHRpb25zLmNvbGxpZGVyc10pO1xuICByZXR1cm4gY29sbGlkZXJQcm9wcztcbn07XG5cbmNvbnN0IERlYnVnID0gLyojX19QVVJFX18qL21lbW8oKCkgPT4ge1xuICBjb25zdCB7XG4gICAgd29ybGRcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZUZyYW1lKCgpID0+IHtcbiAgICBjb25zdCBtZXNoID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFtZXNoKSByZXR1cm47XG4gICAgY29uc3QgYnVmZmVycyA9IHdvcmxkLmRlYnVnUmVuZGVyKCk7XG4gICAgbWVzaC5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLCBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlcnMudmVydGljZXMsIDMpKTtcbiAgICBtZXNoLmdlb21ldHJ5LnNldEF0dHJpYnV0ZShcImNvbG9yXCIsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYnVmZmVycy5jb2xvcnMsIDQpKTtcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVNlZ21lbnRzXCIsIHtcbiAgICByZWY6IHJlZixcbiAgICBmcnVzdHVtQ3VsbGVkOiBmYWxzZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVCYXNpY01hdGVyaWFsXCIsIHtcbiAgICBjb2xvcjogMHhmZmZmZmYsXG4gICAgdmVydGV4Q29sb3JzOiB0cnVlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckdlb21ldHJ5XCIsIG51bGwpKSk7XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcHJveHkgdGhhdCB3aWxsIGNyZWF0ZSBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gY2xhc3NcbiAqIHdoZW4gYSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZCwgYW5kIG5vdCBiZWZvcmUuXG4gKlxuICogQHJldHVybnMgQSBwcm94eSBhbmQgYSByZXNldCBmdW5jdGlvbiwgc28gdGhhdCB0aGUgaW5zdGFuY2UgY2FuIGNyZWF0ZWQgYWdhaW5cbiAqL1xuY29uc3QgY3JlYXRlU2luZ2xldG9uUHJveHkgPSBjcmVhdGVJbnN0YW5jZSA9PiB7XG4gIGxldCBpbnN0YW5jZTtcbiAgY29uc3QgaGFuZGxlciA9IHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGluc3RhbmNlLCBwcm9wKTtcbiAgICB9LFxuXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQoaW5zdGFuY2UsIHByb3AsIHZhbHVlKTtcbiAgICB9XG5cbiAgfTtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoe30sIGhhbmRsZXIpO1xuXG4gIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgIGluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIGNvbnN0IHNldCA9IG5ld0luc3RhbmNlID0+IHtcbiAgICBpbnN0YW5jZSA9IG5ld0luc3RhbmNlO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJuIHRoZSBwcm94eSBhbmQgYSByZXNldCBmdW5jdGlvblxuICAgKi9cblxuXG4gIHJldHVybiB7XG4gICAgcHJveHksXG4gICAgcmVzZXQsXG4gICAgc2V0XG4gIH07XG59O1xuXG5jb25zdCByYXBpZXJDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcblxuY29uc3QgZ2V0Q29sbGlzaW9uUGF5bG9hZEZyb21Tb3VyY2UgPSAodGFyZ2V0LCBvdGhlcikgPT4ge1xuICB2YXIgX3RhcmdldCRjb2xsaWRlciRzdGF0LCBfdGFyZ2V0JHJpZ2lkQm9keSRzdGEsIF9vdGhlciRjb2xsaWRlciRzdGF0ZSwgX290aGVyJHJpZ2lkQm9keSRzdGF0LCBfb3RoZXIkY29sbGlkZXIkc3RhdGUyLCBfb3RoZXIkcmlnaWRCb2R5JHN0YXQyO1xuXG4gIHJldHVybiB7XG4gICAgdGFyZ2V0OiB7XG4gICAgICByaWdpZEJvZHk6IHRhcmdldC5yaWdpZEJvZHkub2JqZWN0LFxuICAgICAgY29sbGlkZXI6IHRhcmdldC5jb2xsaWRlci5vYmplY3QsXG4gICAgICBjb2xsaWRlck9iamVjdDogKF90YXJnZXQkY29sbGlkZXIkc3RhdCA9IHRhcmdldC5jb2xsaWRlci5zdGF0ZSkgPT09IG51bGwgfHwgX3RhcmdldCRjb2xsaWRlciRzdGF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGFyZ2V0JGNvbGxpZGVyJHN0YXQub2JqZWN0LFxuICAgICAgcmlnaWRCb2R5T2JqZWN0OiAoX3RhcmdldCRyaWdpZEJvZHkkc3RhID0gdGFyZ2V0LnJpZ2lkQm9keS5zdGF0ZSkgPT09IG51bGwgfHwgX3RhcmdldCRyaWdpZEJvZHkkc3RhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGFyZ2V0JHJpZ2lkQm9keSRzdGEub2JqZWN0XG4gICAgfSxcbiAgICBvdGhlcjoge1xuICAgICAgcmlnaWRCb2R5OiBvdGhlci5yaWdpZEJvZHkub2JqZWN0LFxuICAgICAgY29sbGlkZXI6IG90aGVyLmNvbGxpZGVyLm9iamVjdCxcbiAgICAgIGNvbGxpZGVyT2JqZWN0OiAoX290aGVyJGNvbGxpZGVyJHN0YXRlID0gb3RoZXIuY29sbGlkZXIuc3RhdGUpID09PSBudWxsIHx8IF9vdGhlciRjb2xsaWRlciRzdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX290aGVyJGNvbGxpZGVyJHN0YXRlLm9iamVjdCxcbiAgICAgIHJpZ2lkQm9keU9iamVjdDogKF9vdGhlciRyaWdpZEJvZHkkc3RhdCA9IG90aGVyLnJpZ2lkQm9keS5zdGF0ZSkgPT09IG51bGwgfHwgX290aGVyJHJpZ2lkQm9keSRzdGF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3RoZXIkcmlnaWRCb2R5JHN0YXQub2JqZWN0XG4gICAgfSxcbiAgICByaWdpZEJvZHk6IG90aGVyLnJpZ2lkQm9keS5vYmplY3QsXG4gICAgY29sbGlkZXI6IG90aGVyLmNvbGxpZGVyLm9iamVjdCxcbiAgICBjb2xsaWRlck9iamVjdDogKF9vdGhlciRjb2xsaWRlciRzdGF0ZTIgPSBvdGhlci5jb2xsaWRlci5zdGF0ZSkgPT09IG51bGwgfHwgX290aGVyJGNvbGxpZGVyJHN0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX290aGVyJGNvbGxpZGVyJHN0YXRlMi5vYmplY3QsXG4gICAgcmlnaWRCb2R5T2JqZWN0OiAoX290aGVyJHJpZ2lkQm9keSRzdGF0MiA9IG90aGVyLnJpZ2lkQm9keS5zdGF0ZSkgPT09IG51bGwgfHwgX290aGVyJHJpZ2lkQm9keSRzdGF0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX290aGVyJHJpZ2lkQm9keSRzdGF0Mi5vYmplY3RcbiAgfTtcbn07XG5cbmNvbnN0IGltcG9ydFJhcGllciA9IGFzeW5jICgpID0+IHtcbiAgbGV0IHIgPSBhd2FpdCBpbXBvcnQoJ0BkaW1mb3JnZS9yYXBpZXIzZC1jb21wYXQnKTtcbiAgYXdhaXQgci5pbml0KCk7XG4gIHJldHVybiByO1xufTtcblxuLyoqXG4gKiBUaGUgbWFpbiBwaHlzaWNzIGNvbXBvbmVudCB1c2VkIHRvIGNyZWF0ZSBhIHBoeXNpY3Mgd29ybGQuXG4gKiBAY2F0ZWdvcnkgQ29tcG9uZW50c1xuICovXG5jb25zdCBQaHlzaWNzID0gcHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgY29sbGlkZXJzID0gXCJjdWJvaWRcIixcbiAgICBjaGlsZHJlbixcbiAgICB0aW1lU3RlcCA9IDEgLyA2MCxcbiAgICBwYXVzZWQgPSBmYWxzZSxcbiAgICBpbnRlcnBvbGF0ZSA9IHRydWUsXG4gICAgdXBkYXRlUHJpb3JpdHksXG4gICAgdXBkYXRlTG9vcCA9IFwiZm9sbG93XCIsXG4gICAgZGVidWcgPSBmYWxzZSxcbiAgICBncmF2aXR5ID0gWzAsIC05LjgxLCAwXSxcbiAgICBhbGxvd2VkTGluZWFyRXJyb3IgPSAwLjAwMSxcbiAgICBwcmVkaWN0aW9uRGlzdGFuY2UgPSAwLjAwMixcbiAgICBudW1Tb2x2ZXJJdGVyYXRpb25zID0gNCxcbiAgICBudW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zID0gNCxcbiAgICBudW1JbnRlcm5hbFBnc0l0ZXJhdGlvbnMgPSAxLFxuICAgIG1pbklzbGFuZFNpemUgPSAxMjgsXG4gICAgbWF4Q2NkU3Vic3RlcHMgPSAxLFxuICAgIGVycCA9IDAuOFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJhcGllciA9IHN1c3BlbmQoaW1wb3J0UmFwaWVyLCBbXCJAcmVhY3QtdGhlZS9yYXBpZXJcIiwgaW1wb3J0UmFwaWVyXSk7XG4gIGNvbnN0IHtcbiAgICBpbnZhbGlkYXRlXG4gIH0gPSB1c2VUaHJlZSgpO1xuICBjb25zdCByaWdpZEJvZHlTdGF0ZXMgPSB1c2VDb25zdCgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCBjb2xsaWRlclN0YXRlcyA9IHVzZUNvbnN0KCgpID0+IG5ldyBNYXAoKSk7XG4gIGNvbnN0IHJpZ2lkQm9keUV2ZW50cyA9IHVzZUNvbnN0KCgpID0+IG5ldyBNYXAoKSk7XG4gIGNvbnN0IGNvbGxpZGVyRXZlbnRzID0gdXNlQ29uc3QoKCkgPT4gbmV3IE1hcCgpKTtcbiAgY29uc3QgZXZlbnRRdWV1ZSA9IHVzZUNvbnN0KCgpID0+IG5ldyBFdmVudFF1ZXVlKGZhbHNlKSk7XG4gIGNvbnN0IGJlZm9yZVN0ZXBDYWxsYmFja3MgPSB1c2VDb25zdCgoKSA9PiBuZXcgU2V0KCkpO1xuICBjb25zdCBhZnRlclN0ZXBDYWxsYmFja3MgPSB1c2VDb25zdCgoKSA9PiBuZXcgU2V0KCkpO1xuICAvKipcbiAgICogSW5pdGlhdGUgdGhlIHdvcmxkXG4gICAqIFRoaXMgY3JlYXRlcyBhIHNpbmdsZXRvbiBwcm94eSwgc28gdGhhdCB0aGUgd29ybGQgaXMgb25seSBjcmVhdGVkIHdoZW5cbiAgICogc29tZXRoaW5nIHdpdGhpbiBpdCBpcyBhY2Nlc3NlZC5cbiAgICovXG5cbiAgY29uc3Qge1xuICAgIHByb3h5OiB3b3JsZFByb3h5LFxuICAgIHJlc2V0OiByZXNldFdvcmxkUHJveHksXG4gICAgc2V0OiBzZXRXb3JsZFByb3h5XG4gIH0gPSB1c2VDb25zdCgoKSA9PiBjcmVhdGVTaW5nbGV0b25Qcm94eSgoKSA9PiBuZXcgcmFwaWVyLldvcmxkKHZlY3RvckFycmF5VG9WZWN0b3IzKGdyYXZpdHkpKSkpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3b3JsZFByb3h5LmZyZWUoKTtcbiAgICAgIHJlc2V0V29ybGRQcm94eSgpO1xuICAgIH07XG4gIH0sIFtdKTsgLy8gVXBkYXRlIG11dGFibGUgcHJvcHNcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdvcmxkUHJveHkuZ3Jhdml0eSA9IHZlY3RvcjNUb1JhcGllclZlY3RvcihncmF2aXR5KTtcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5udW1Tb2x2ZXJJdGVyYXRpb25zID0gbnVtU29sdmVySXRlcmF0aW9ucztcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5udW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zID0gbnVtQWRkaXRpb25hbEZyaWN0aW9uSXRlcmF0aW9ucztcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5udW1JbnRlcm5hbFBnc0l0ZXJhdGlvbnMgPSBudW1JbnRlcm5hbFBnc0l0ZXJhdGlvbnM7XG4gICAgd29ybGRQcm94eS5pbnRlZ3JhdGlvblBhcmFtZXRlcnMuYWxsb3dlZExpbmVhckVycm9yID0gYWxsb3dlZExpbmVhckVycm9yO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLm1pbklzbGFuZFNpemUgPSBtaW5Jc2xhbmRTaXplO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLm1heENjZFN1YnN0ZXBzID0gbWF4Q2NkU3Vic3RlcHM7XG4gICAgd29ybGRQcm94eS5pbnRlZ3JhdGlvblBhcmFtZXRlcnMucHJlZGljdGlvbkRpc3RhbmNlID0gcHJlZGljdGlvbkRpc3RhbmNlO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLmVycCA9IGVycDtcbiAgfSwgW3dvcmxkUHJveHksIC4uLmdyYXZpdHksIG51bVNvbHZlckl0ZXJhdGlvbnMsIG51bUFkZGl0aW9uYWxGcmljdGlvbkl0ZXJhdGlvbnMsIG51bUludGVybmFsUGdzSXRlcmF0aW9ucywgYWxsb3dlZExpbmVhckVycm9yLCBtaW5Jc2xhbmRTaXplLCBtYXhDY2RTdWJzdGVwcywgcHJlZGljdGlvbkRpc3RhbmNlLCBlcnBdKTtcbiAgY29uc3QgZ2V0U291cmNlRnJvbUNvbGxpZGVySGFuZGxlID0gdXNlQ2FsbGJhY2soaGFuZGxlID0+IHtcbiAgICB2YXIgX2NvbGxpZGVyJHBhcmVudDtcblxuICAgIGNvbnN0IGNvbGxpZGVyID0gd29ybGRQcm94eS5nZXRDb2xsaWRlcihoYW5kbGUpO1xuICAgIGNvbnN0IGNvbEV2ZW50cyA9IGNvbGxpZGVyRXZlbnRzLmdldChoYW5kbGUpO1xuICAgIGNvbnN0IGNvbGxpZGVyU3RhdGUgPSBjb2xsaWRlclN0YXRlcy5nZXQoaGFuZGxlKTtcbiAgICBjb25zdCByaWdpZEJvZHlIYW5kbGUgPSBjb2xsaWRlciA9PT0gbnVsbCB8fCBjb2xsaWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9jb2xsaWRlciRwYXJlbnQgPSBjb2xsaWRlci5wYXJlbnQoKSkgPT09IG51bGwgfHwgX2NvbGxpZGVyJHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbGxpZGVyJHBhcmVudC5oYW5kbGU7XG4gICAgY29uc3QgcmlnaWRCb2R5ID0gcmlnaWRCb2R5SGFuZGxlICE9PSB1bmRlZmluZWQgPyB3b3JsZFByb3h5LmdldFJpZ2lkQm9keShyaWdpZEJvZHlIYW5kbGUpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJiRXZlbnRzID0gcmlnaWRCb2R5ICYmIHJpZ2lkQm9keUhhbmRsZSAhPT0gdW5kZWZpbmVkID8gcmlnaWRCb2R5RXZlbnRzLmdldChyaWdpZEJvZHlIYW5kbGUpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJpZ2lkQm9keVN0YXRlID0gcmlnaWRCb2R5SGFuZGxlICE9PSB1bmRlZmluZWQgPyByaWdpZEJvZHlTdGF0ZXMuZ2V0KHJpZ2lkQm9keUhhbmRsZSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc291cmNlID0ge1xuICAgICAgY29sbGlkZXI6IHtcbiAgICAgICAgb2JqZWN0OiBjb2xsaWRlcixcbiAgICAgICAgZXZlbnRzOiBjb2xFdmVudHMsXG4gICAgICAgIHN0YXRlOiBjb2xsaWRlclN0YXRlXG4gICAgICB9LFxuICAgICAgcmlnaWRCb2R5OiB7XG4gICAgICAgIG9iamVjdDogcmlnaWRCb2R5LFxuICAgICAgICBldmVudHM6IHJiRXZlbnRzLFxuICAgICAgICBzdGF0ZTogcmlnaWRCb2R5U3RhdGVcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0sIFtdKTtcbiAgY29uc3QgW3N0ZXBwaW5nU3RhdGVdID0gdXNlU3RhdGUoe1xuICAgIHByZXZpb3VzU3RhdGU6IHt9LFxuICAgIGFjY3VtdWxhdG9yOiAwXG4gIH0pO1xuICBjb25zdCBzdGVwID0gdXNlQ2FsbGJhY2soZHQgPT4ge1xuICAgIGNvbnN0IHdvcmxkID0gd29ybGRQcm94eTtcbiAgICAvKiBDaGVjayBpZiB0aGUgdGltZXN0ZXAgaXMgc3VwcG9zZWQgdG8gYmUgdmFyaWFibGUuIFdlJ2xsIGRvIHRoaXMgaGVyZVxuICAgICAgb25jZSBzbyB3ZSBkb24ndCBoYXZlIHRvIHN0cmluZy1jaGVjayBldmVyeSBmcmFtZS4gKi9cblxuICAgIGNvbnN0IHRpbWVTdGVwVmFyaWFibGUgPSB0aW1lU3RlcCA9PT0gXCJ2YXJ5XCI7XG4gICAgLyoqXG4gICAgICogRml4ZWQgdGltZVN0ZXAgc2ltdWxhdGlvbiBwcm9ncmVzc2lvblxuICAgICAqIEBzZWUgaHR0cHM6Ly9nYWZmZXJvbmdhbWVzLmNvbS9wb3N0L2ZpeF95b3VyX3RpbWVzdGVwL1xuICAgICAqL1xuXG4gICAgY29uc3QgY2xhbXBlZERlbHRhID0gTWF0aFV0aWxzLmNsYW1wKGR0LCAwLCAwLjUpO1xuXG4gICAgY29uc3Qgc3RlcFdvcmxkID0gZGVsdGEgPT4ge1xuICAgICAgLy8gVHJpZ2dlciBiZWZvcmVTdGVwIGNhbGxiYWNrc1xuICAgICAgYmVmb3JlU3RlcENhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgY2FsbGJhY2suY3VycmVudCh3b3JsZCk7XG4gICAgICB9KTtcbiAgICAgIHdvcmxkLnRpbWVzdGVwID0gZGVsdGE7XG4gICAgICB3b3JsZC5zdGVwKGV2ZW50UXVldWUpOyAvLyBUcmlnZ2VyIGFmdGVyU3RlcCBjYWxsYmFja3NcblxuICAgICAgYWZ0ZXJTdGVwQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICBjYWxsYmFjay5jdXJyZW50KHdvcmxkKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAodGltZVN0ZXBWYXJpYWJsZSkge1xuICAgICAgc3RlcFdvcmxkKGNsYW1wZWREZWx0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvbid0IHN0ZXAgdGltZSBmb3J3YXJkcyBpZiBwYXVzZWRcbiAgICAgIC8vIEluY3JlYXNlIGFjY3VtdWxhdG9yXG4gICAgICBzdGVwcGluZ1N0YXRlLmFjY3VtdWxhdG9yICs9IGNsYW1wZWREZWx0YTtcblxuICAgICAgd2hpbGUgKHN0ZXBwaW5nU3RhdGUuYWNjdW11bGF0b3IgPj0gdGltZVN0ZXApIHtcbiAgICAgICAgLy8gU2V0IHVwIHByZXZpb3VzIHN0YXRlXG4gICAgICAgIC8vIG5lZWRlZCBmb3IgYWNjdXJhdGUgaW50ZXJwb2xhdGlvbnMgaWYgdGhlIHdvcmxkIHN0ZXBzIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICAgIHN0ZXBwaW5nU3RhdGUucHJldmlvdXNTdGF0ZSA9IHt9O1xuICAgICAgICAgIHdvcmxkLmZvckVhY2hSaWdpZEJvZHkoYm9keSA9PiB7XG4gICAgICAgICAgICBzdGVwcGluZ1N0YXRlLnByZXZpb3VzU3RhdGVbYm9keS5oYW5kbGVdID0ge1xuICAgICAgICAgICAgICBwb3NpdGlvbjogYm9keS50cmFuc2xhdGlvbigpLFxuICAgICAgICAgICAgICByb3RhdGlvbjogYm9keS5yb3RhdGlvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RlcFdvcmxkKHRpbWVTdGVwKTtcbiAgICAgICAgc3RlcHBpbmdTdGF0ZS5hY2N1bXVsYXRvciAtPSB0aW1lU3RlcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcnBvbGF0aW9uQWxwaGEgPSB0aW1lU3RlcFZhcmlhYmxlIHx8ICFpbnRlcnBvbGF0ZSB8fCBwYXVzZWQgPyAxIDogc3RlcHBpbmdTdGF0ZS5hY2N1bXVsYXRvciAvIHRpbWVTdGVwOyAvLyBVcGRhdGUgbWVzaGVzXG5cbiAgICByaWdpZEJvZHlTdGF0ZXMuZm9yRWFjaCgoc3RhdGUsIGhhbmRsZSkgPT4ge1xuICAgICAgY29uc3QgcmlnaWRCb2R5ID0gd29ybGQuZ2V0UmlnaWRCb2R5KGhhbmRsZSk7XG4gICAgICBjb25zdCBldmVudHMgPSByaWdpZEJvZHlFdmVudHMuZ2V0KGhhbmRsZSk7XG5cbiAgICAgIGlmIChldmVudHMgIT09IG51bGwgJiYgZXZlbnRzICE9PSB2b2lkIDAgJiYgZXZlbnRzLm9uU2xlZXAgfHwgZXZlbnRzICE9PSBudWxsICYmIGV2ZW50cyAhPT0gdm9pZCAwICYmIGV2ZW50cy5vbldha2UpIHtcbiAgICAgICAgaWYgKHJpZ2lkQm9keS5pc1NsZWVwaW5nKCkgJiYgIXN0YXRlLmlzU2xlZXBpbmcpIHtcbiAgICAgICAgICB2YXIgX2V2ZW50cyRvblNsZWVwO1xuXG4gICAgICAgICAgZXZlbnRzID09PSBudWxsIHx8IGV2ZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ldmVudHMkb25TbGVlcCA9IGV2ZW50cy5vblNsZWVwKSA9PT0gbnVsbCB8fCBfZXZlbnRzJG9uU2xlZXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldmVudHMkb25TbGVlcC5jYWxsKGV2ZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJpZ2lkQm9keS5pc1NsZWVwaW5nKCkgJiYgc3RhdGUuaXNTbGVlcGluZykge1xuICAgICAgICAgIHZhciBfZXZlbnRzJG9uV2FrZTtcblxuICAgICAgICAgIGV2ZW50cyA9PT0gbnVsbCB8fCBldmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZXZlbnRzJG9uV2FrZSA9IGV2ZW50cy5vbldha2UpID09PSBudWxsIHx8IF9ldmVudHMkb25XYWtlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXZlbnRzJG9uV2FrZS5jYWxsKGV2ZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5pc1NsZWVwaW5nID0gcmlnaWRCb2R5LmlzU2xlZXBpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyaWdpZEJvZHkgfHwgcmlnaWRCb2R5LmlzU2xlZXBpbmcoKSAmJiAhKFwiaXNJbnN0YW5jZWRNZXNoXCIgaW4gc3RhdGUub2JqZWN0KSB8fCAhc3RhdGUuc2V0TWF0cml4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gTmV3IHN0YXRlc1xuXG5cbiAgICAgIGxldCB0ID0gcmlnaWRCb2R5LnRyYW5zbGF0aW9uKCk7XG4gICAgICBsZXQgciA9IHJpZ2lkQm9keS5yb3RhdGlvbigpO1xuICAgICAgbGV0IHByZXZpb3VzU3RhdGUgPSBzdGVwcGluZ1N0YXRlLnByZXZpb3VzU3RhdGVbaGFuZGxlXTtcblxuICAgICAgaWYgKHByZXZpb3VzU3RhdGUpIHtcbiAgICAgICAgLy8gR2V0IHByZXZpb3VzIHNpbXVsYXRlZCB3b3JsZCBwb3NpdGlvblxuICAgICAgICBfbWF0cml4NC5jb21wb3NlKHByZXZpb3VzU3RhdGUucG9zaXRpb24sIHJhcGllclF1YXRlcm5pb25Ub1F1YXRlcm5pb24ocHJldmlvdXNTdGF0ZS5yb3RhdGlvbiksIHN0YXRlLnNjYWxlKS5wcmVtdWx0aXBseShzdGF0ZS5pbnZlcnRlZFdvcmxkTWF0cml4KS5kZWNvbXBvc2UoX3Bvc2l0aW9uLCBfcm90YXRpb24sIF9zY2FsZSk7IC8vIEFwcGx5IHByZXZpb3VzIHRpY2sgcG9zaXRpb25cblxuXG4gICAgICAgIGlmIChzdGF0ZS5tZXNoVHlwZSA9PSBcIm1lc2hcIikge1xuICAgICAgICAgIHN0YXRlLm9iamVjdC5wb3NpdGlvbi5jb3B5KF9wb3NpdGlvbik7XG4gICAgICAgICAgc3RhdGUub2JqZWN0LnF1YXRlcm5pb24uY29weShfcm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IC8vIEdldCBuZXcgcG9zaXRpb25cblxuXG4gICAgICBfbWF0cml4NC5jb21wb3NlKHQsIHJhcGllclF1YXRlcm5pb25Ub1F1YXRlcm5pb24ociksIHN0YXRlLnNjYWxlKS5wcmVtdWx0aXBseShzdGF0ZS5pbnZlcnRlZFdvcmxkTWF0cml4KS5kZWNvbXBvc2UoX3Bvc2l0aW9uLCBfcm90YXRpb24sIF9zY2FsZSk7XG5cbiAgICAgIGlmIChzdGF0ZS5tZXNoVHlwZSA9PSBcImluc3RhbmNlZE1lc2hcIikge1xuICAgICAgICBzdGF0ZS5zZXRNYXRyaXgoX21hdHJpeDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgdG8gbmV3IHBvc2l0aW9uXG4gICAgICAgIHN0YXRlLm9iamVjdC5wb3NpdGlvbi5sZXJwKF9wb3NpdGlvbiwgaW50ZXJwb2xhdGlvbkFscGhhKTtcbiAgICAgICAgc3RhdGUub2JqZWN0LnF1YXRlcm5pb24uc2xlcnAoX3JvdGF0aW9uLCBpbnRlcnBvbGF0aW9uQWxwaGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGV2ZW50UXVldWUuZHJhaW5Db2xsaXNpb25FdmVudHMoKGhhbmRsZTEsIGhhbmRsZTIsIHN0YXJ0ZWQpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZTEgPSBnZXRTb3VyY2VGcm9tQ29sbGlkZXJIYW5kbGUoaGFuZGxlMSk7XG4gICAgICBjb25zdCBzb3VyY2UyID0gZ2V0U291cmNlRnJvbUNvbGxpZGVySGFuZGxlKGhhbmRsZTIpOyAvLyBDb2xsaXNpb24gRXZlbnRzXG5cbiAgICAgIGlmICghKHNvdXJjZTEgIT09IG51bGwgJiYgc291cmNlMSAhPT0gdm9pZCAwICYmIHNvdXJjZTEuY29sbGlkZXIub2JqZWN0KSB8fCAhKHNvdXJjZTIgIT09IG51bGwgJiYgc291cmNlMiAhPT0gdm9pZCAwICYmIHNvdXJjZTIuY29sbGlkZXIub2JqZWN0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbGxpc2lvblBheWxvYWQxID0gZ2V0Q29sbGlzaW9uUGF5bG9hZEZyb21Tb3VyY2Uoc291cmNlMSwgc291cmNlMik7XG4gICAgICBjb25zdCBjb2xsaXNpb25QYXlsb2FkMiA9IGdldENvbGxpc2lvblBheWxvYWRGcm9tU291cmNlKHNvdXJjZTIsIHNvdXJjZTEpO1xuXG4gICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICB3b3JsZC5jb250YWN0UGFpcihzb3VyY2UxLmNvbGxpZGVyLm9iamVjdCwgc291cmNlMi5jb2xsaWRlci5vYmplY3QsIChtYW5pZm9sZCwgZmxpcHBlZCkgPT4ge1xuICAgICAgICAgIHZhciBfc291cmNlMSRyaWdpZEJvZHkkZXYsIF9zb3VyY2UxJHJpZ2lkQm9keSRldjIsIF9zb3VyY2UyJHJpZ2lkQm9keSRldiwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2MiwgX3NvdXJjZTEkY29sbGlkZXIkZXZlLCBfc291cmNlMSRjb2xsaWRlciRldmUyLCBfc291cmNlMiRjb2xsaWRlciRldmUsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTI7XG5cbiAgICAgICAgICAvKiBSaWdpZEJvZHkgZXZlbnRzICovXG4gICAgICAgICAgKF9zb3VyY2UxJHJpZ2lkQm9keSRldiA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2MiA9IF9zb3VyY2UxJHJpZ2lkQm9keSRldi5vbkNvbGxpc2lvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRyaWdpZEJvZHkkZXYyLmNhbGwoX3NvdXJjZTEkcmlnaWRCb2R5JGV2LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDEpLCB7fSwge1xuICAgICAgICAgICAgbWFuaWZvbGQsXG4gICAgICAgICAgICBmbGlwcGVkXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIChfc291cmNlMiRyaWdpZEJvZHkkZXYgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJHJpZ2lkQm9keSRldjIgPSBfc291cmNlMiRyaWdpZEJvZHkkZXYub25Db2xsaXNpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkcmlnaWRCb2R5JGV2Mi5jYWxsKF9zb3VyY2UyJHJpZ2lkQm9keSRldiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQyKSwge30sIHtcbiAgICAgICAgICAgIG1hbmlmb2xkLFxuICAgICAgICAgICAgZmxpcHBlZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICAvKiBDb2xsaWRlciBldmVudHMgKi9cblxuICAgICAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmUgPSBzb3VyY2UxLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkY29sbGlkZXIkZXZlMiA9IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZS5vbkNvbGxpc2lvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRjb2xsaWRlciRldmUyLmNhbGwoX3NvdXJjZTEkY29sbGlkZXIkZXZlLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDEpLCB7fSwge1xuICAgICAgICAgICAgbWFuaWZvbGQsXG4gICAgICAgICAgICBmbGlwcGVkXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmUgPSBzb3VyY2UyLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkY29sbGlkZXIkZXZlMiA9IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZS5vbkNvbGxpc2lvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRjb2xsaWRlciRldmUyLmNhbGwoX3NvdXJjZTIkY29sbGlkZXIkZXZlLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDIpLCB7fSwge1xuICAgICAgICAgICAgbWFuaWZvbGQsXG4gICAgICAgICAgICBmbGlwcGVkXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfc291cmNlMSRyaWdpZEJvZHkkZXYzLCBfc291cmNlMSRyaWdpZEJvZHkkZXY0LCBfc291cmNlMiRyaWdpZEJvZHkkZXYzLCBfc291cmNlMiRyaWdpZEJvZHkkZXY0LCBfc291cmNlMSRjb2xsaWRlciRldmUzLCBfc291cmNlMSRjb2xsaWRlciRldmU0LCBfc291cmNlMiRjb2xsaWRlciRldmUzLCBfc291cmNlMiRjb2xsaWRlciRldmU0O1xuXG4gICAgICAgIChfc291cmNlMSRyaWdpZEJvZHkkZXYzID0gc291cmNlMS5yaWdpZEJvZHkuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXYzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2NCA9IF9zb3VyY2UxJHJpZ2lkQm9keSRldjMub25Db2xsaXNpb25FeGl0KSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXY0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRyaWdpZEJvZHkkZXY0LmNhbGwoX3NvdXJjZTEkcmlnaWRCb2R5JGV2MywgY29sbGlzaW9uUGF5bG9hZDEpO1xuICAgICAgICAoX3NvdXJjZTIkcmlnaWRCb2R5JGV2MyA9IHNvdXJjZTIucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2MyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJHJpZ2lkQm9keSRldjQgPSBfc291cmNlMiRyaWdpZEJvZHkkZXYzLm9uQ29sbGlzaW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2NCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkcmlnaWRCb2R5JGV2NC5jYWxsKF9zb3VyY2UyJHJpZ2lkQm9keSRldjMsIGNvbGxpc2lvblBheWxvYWQyKTtcbiAgICAgICAgKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTMgPSBzb3VyY2UxLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTQgPSBfc291cmNlMSRjb2xsaWRlciRldmUzLm9uQ29sbGlzaW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkY29sbGlkZXIkZXZlNC5jYWxsKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTMsIGNvbGxpc2lvblBheWxvYWQxKTtcbiAgICAgICAgKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTMgPSBzb3VyY2UyLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTQgPSBfc291cmNlMiRjb2xsaWRlciRldmUzLm9uQ29sbGlzaW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkY29sbGlkZXIkZXZlNC5jYWxsKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTMsIGNvbGxpc2lvblBheWxvYWQyKTtcbiAgICAgIH0gLy8gU2Vuc29yIEludGVyc2VjdGlvbnNcblxuXG4gICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICBpZiAod29ybGQuaW50ZXJzZWN0aW9uUGFpcihzb3VyY2UxLmNvbGxpZGVyLm9iamVjdCwgc291cmNlMi5jb2xsaWRlci5vYmplY3QpKSB7XG4gICAgICAgICAgdmFyIF9zb3VyY2UxJHJpZ2lkQm9keSRldjUsIF9zb3VyY2UxJHJpZ2lkQm9keSRldjYsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjUsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjYsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTUsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTYsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTUsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTY7XG5cbiAgICAgICAgICAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2NSA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2NSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJHJpZ2lkQm9keSRldjYgPSBfc291cmNlMSRyaWdpZEJvZHkkZXY1Lm9uSW50ZXJzZWN0aW9uRW50ZXIpID09PSBudWxsIHx8IF9zb3VyY2UxJHJpZ2lkQm9keSRldjYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJHJpZ2lkQm9keSRldjYuY2FsbChfc291cmNlMSRyaWdpZEJvZHkkZXY1LCBjb2xsaXNpb25QYXlsb2FkMSk7XG4gICAgICAgICAgKF9zb3VyY2UyJHJpZ2lkQm9keSRldjUgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRyaWdpZEJvZHkkZXY2ID0gX3NvdXJjZTIkcmlnaWRCb2R5JGV2NS5vbkludGVyc2VjdGlvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMiRyaWdpZEJvZHkkZXY2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRyaWdpZEJvZHkkZXY2LmNhbGwoX3NvdXJjZTIkcmlnaWRCb2R5JGV2NSwgY29sbGlzaW9uUGF5bG9hZDIpO1xuICAgICAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmU1ID0gc291cmNlMS5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRjb2xsaWRlciRldmU2ID0gX3NvdXJjZTEkY29sbGlkZXIkZXZlNS5vbkludGVyc2VjdGlvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmU2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRjb2xsaWRlciRldmU2LmNhbGwoX3NvdXJjZTEkY29sbGlkZXIkZXZlNSwgY29sbGlzaW9uUGF5bG9hZDEpO1xuICAgICAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmU1ID0gc291cmNlMi5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRjb2xsaWRlciRldmU2ID0gX3NvdXJjZTIkY29sbGlkZXIkZXZlNS5vbkludGVyc2VjdGlvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmU2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRjb2xsaWRlciRldmU2LmNhbGwoX3NvdXJjZTIkY29sbGlkZXIkZXZlNSwgY29sbGlzaW9uUGF5bG9hZDIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3NvdXJjZTEkcmlnaWRCb2R5JGV2NywgX3NvdXJjZTEkcmlnaWRCb2R5JGV2OCwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2NywgX3NvdXJjZTIkcmlnaWRCb2R5JGV2OCwgX3NvdXJjZTEkY29sbGlkZXIkZXZlNywgX3NvdXJjZTEkY29sbGlkZXIkZXZlOCwgX3NvdXJjZTIkY29sbGlkZXIkZXZlNywgX3NvdXJjZTIkY29sbGlkZXIkZXZlODtcblxuICAgICAgICAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2NyA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2NyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJHJpZ2lkQm9keSRldjggPSBfc291cmNlMSRyaWdpZEJvZHkkZXY3Lm9uSW50ZXJzZWN0aW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2OCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkcmlnaWRCb2R5JGV2OC5jYWxsKF9zb3VyY2UxJHJpZ2lkQm9keSRldjcsIGNvbGxpc2lvblBheWxvYWQxKTtcbiAgICAgICAgKF9zb3VyY2UyJHJpZ2lkQm9keSRldjcgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRyaWdpZEJvZHkkZXY4ID0gX3NvdXJjZTIkcmlnaWRCb2R5JGV2Ny5vbkludGVyc2VjdGlvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJHJpZ2lkQm9keSRldjguY2FsbChfc291cmNlMiRyaWdpZEJvZHkkZXY3LCBjb2xsaXNpb25QYXlsb2FkMik7XG4gICAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmU3ID0gc291cmNlMS5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRjb2xsaWRlciRldmU4ID0gX3NvdXJjZTEkY29sbGlkZXIkZXZlNy5vbkludGVyc2VjdGlvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTguY2FsbChfc291cmNlMSRjb2xsaWRlciRldmU3LCBjb2xsaXNpb25QYXlsb2FkMSk7XG4gICAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmU3ID0gc291cmNlMi5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRjb2xsaWRlciRldmU4ID0gX3NvdXJjZTIkY29sbGlkZXIkZXZlNy5vbkludGVyc2VjdGlvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTguY2FsbChfc291cmNlMiRjb2xsaWRlciRldmU3LCBjb2xsaXNpb25QYXlsb2FkMik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZXZlbnRRdWV1ZS5kcmFpbkNvbnRhY3RGb3JjZUV2ZW50cyhldmVudCA9PiB7XG4gICAgICB2YXIgX3NvdXJjZTEkcmlnaWRCb2R5JGV2OSwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MTAsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjksIF9zb3VyY2UyJHJpZ2lkQm9keSRldjEwLCBfc291cmNlMSRjb2xsaWRlciRldmU5LCBfc291cmNlMSRjb2xsaWRlciRldmUxMCwgX3NvdXJjZTIkY29sbGlkZXIkZXZlOSwgX3NvdXJjZTIkY29sbGlkZXIkZXZlMTA7XG5cbiAgICAgIGNvbnN0IHNvdXJjZTEgPSBnZXRTb3VyY2VGcm9tQ29sbGlkZXJIYW5kbGUoZXZlbnQuY29sbGlkZXIxKCkpO1xuICAgICAgY29uc3Qgc291cmNlMiA9IGdldFNvdXJjZUZyb21Db2xsaWRlckhhbmRsZShldmVudC5jb2xsaWRlcjIoKSk7IC8vIENvbGxpc2lvbiBFdmVudHNcblxuICAgICAgaWYgKCEoc291cmNlMSAhPT0gbnVsbCAmJiBzb3VyY2UxICE9PSB2b2lkIDAgJiYgc291cmNlMS5jb2xsaWRlci5vYmplY3QpIHx8ICEoc291cmNlMiAhPT0gbnVsbCAmJiBzb3VyY2UyICE9PSB2b2lkIDAgJiYgc291cmNlMi5jb2xsaWRlci5vYmplY3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29sbGlzaW9uUGF5bG9hZDEgPSBnZXRDb2xsaXNpb25QYXlsb2FkRnJvbVNvdXJjZShzb3VyY2UxLCBzb3VyY2UyKTtcbiAgICAgIGNvbnN0IGNvbGxpc2lvblBheWxvYWQyID0gZ2V0Q29sbGlzaW9uUGF5bG9hZEZyb21Tb3VyY2Uoc291cmNlMiwgc291cmNlMSk7XG4gICAgICAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2OSA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2OSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJHJpZ2lkQm9keSRldjEwID0gX3NvdXJjZTEkcmlnaWRCb2R5JGV2OS5vbkNvbnRhY3RGb3JjZSkgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MTAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJHJpZ2lkQm9keSRldjEwLmNhbGwoX3NvdXJjZTEkcmlnaWRCb2R5JGV2OSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQxKSwge30sIHtcbiAgICAgICAgdG90YWxGb3JjZTogZXZlbnQudG90YWxGb3JjZSgpLFxuICAgICAgICB0b3RhbEZvcmNlTWFnbml0dWRlOiBldmVudC50b3RhbEZvcmNlTWFnbml0dWRlKCksXG4gICAgICAgIG1heEZvcmNlRGlyZWN0aW9uOiBldmVudC5tYXhGb3JjZURpcmVjdGlvbigpLFxuICAgICAgICBtYXhGb3JjZU1hZ25pdHVkZTogZXZlbnQubWF4Rm9yY2VNYWduaXR1ZGUoKVxuICAgICAgfSkpO1xuICAgICAgKF9zb3VyY2UyJHJpZ2lkQm9keSRldjkgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRyaWdpZEJvZHkkZXYxMCA9IF9zb3VyY2UyJHJpZ2lkQm9keSRldjkub25Db250YWN0Rm9yY2UpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjEwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRyaWdpZEJvZHkkZXYxMC5jYWxsKF9zb3VyY2UyJHJpZ2lkQm9keSRldjksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb2xsaXNpb25QYXlsb2FkMiksIHt9LCB7XG4gICAgICAgIHRvdGFsRm9yY2U6IGV2ZW50LnRvdGFsRm9yY2UoKSxcbiAgICAgICAgdG90YWxGb3JjZU1hZ25pdHVkZTogZXZlbnQudG90YWxGb3JjZU1hZ25pdHVkZSgpLFxuICAgICAgICBtYXhGb3JjZURpcmVjdGlvbjogZXZlbnQubWF4Rm9yY2VEaXJlY3Rpb24oKSxcbiAgICAgICAgbWF4Rm9yY2VNYWduaXR1ZGU6IGV2ZW50Lm1heEZvcmNlTWFnbml0dWRlKClcbiAgICAgIH0pKTtcbiAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmU5ID0gc291cmNlMS5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRjb2xsaWRlciRldmUxMCA9IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTkub25Db250YWN0Rm9yY2UpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTEwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRjb2xsaWRlciRldmUxMC5jYWxsKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb2xsaXNpb25QYXlsb2FkMSksIHt9LCB7XG4gICAgICAgIHRvdGFsRm9yY2U6IGV2ZW50LnRvdGFsRm9yY2UoKSxcbiAgICAgICAgdG90YWxGb3JjZU1hZ25pdHVkZTogZXZlbnQudG90YWxGb3JjZU1hZ25pdHVkZSgpLFxuICAgICAgICBtYXhGb3JjZURpcmVjdGlvbjogZXZlbnQubWF4Rm9yY2VEaXJlY3Rpb24oKSxcbiAgICAgICAgbWF4Rm9yY2VNYWduaXR1ZGU6IGV2ZW50Lm1heEZvcmNlTWFnbml0dWRlKClcbiAgICAgIH0pKTtcbiAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmU5ID0gc291cmNlMi5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRjb2xsaWRlciRldmUxMCA9IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTkub25Db250YWN0Rm9yY2UpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTEwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRjb2xsaWRlciRldmUxMC5jYWxsKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb2xsaXNpb25QYXlsb2FkMiksIHt9LCB7XG4gICAgICAgIHRvdGFsRm9yY2U6IGV2ZW50LnRvdGFsRm9yY2UoKSxcbiAgICAgICAgdG90YWxGb3JjZU1hZ25pdHVkZTogZXZlbnQudG90YWxGb3JjZU1hZ25pdHVkZSgpLFxuICAgICAgICBtYXhGb3JjZURpcmVjdGlvbjogZXZlbnQubWF4Rm9yY2VEaXJlY3Rpb24oKSxcbiAgICAgICAgbWF4Rm9yY2VNYWduaXR1ZGU6IGV2ZW50Lm1heEZvcmNlTWFnbml0dWRlKClcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICB3b3JsZC5mb3JFYWNoQWN0aXZlUmlnaWRCb2R5KCgpID0+IHtcbiAgICAgIGludmFsaWRhdGUoKTtcbiAgICB9KTtcbiAgfSwgW3BhdXNlZCwgdGltZVN0ZXAsIGludGVycG9sYXRlLCB3b3JsZFByb3h5XSk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcmFwaWVyLFxuICAgIHdvcmxkOiB3b3JsZFByb3h5LFxuICAgIHNldFdvcmxkOiB3b3JsZCA9PiB7XG4gICAgICBzZXRXb3JsZFByb3h5KHdvcmxkKTtcbiAgICB9LFxuICAgIHBoeXNpY3NPcHRpb25zOiB7XG4gICAgICBjb2xsaWRlcnMsXG4gICAgICBncmF2aXR5XG4gICAgfSxcbiAgICByaWdpZEJvZHlTdGF0ZXMsXG4gICAgY29sbGlkZXJTdGF0ZXMsXG4gICAgcmlnaWRCb2R5RXZlbnRzLFxuICAgIGNvbGxpZGVyRXZlbnRzLFxuICAgIGJlZm9yZVN0ZXBDYWxsYmFja3MsXG4gICAgYWZ0ZXJTdGVwQ2FsbGJhY2tzLFxuICAgIGlzUGF1c2VkOiBwYXVzZWQsXG4gICAgaXNEZWJ1ZzogZGVidWcsXG4gICAgc3RlcFxuICB9KSwgW3BhdXNlZCwgc3RlcCwgZGVidWcsIGNvbGxpZGVycywgZ3Jhdml0eV0pO1xuICBjb25zdCBzdGVwQ2FsbGJhY2sgPSB1c2VDYWxsYmFjayhkZWx0YSA9PiB7XG4gICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgIHN0ZXAoZGVsdGEpO1xuICAgIH1cbiAgfSwgW3BhdXNlZCwgc3RlcF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocmFwaWVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZyYW1lU3RlcHBlciQxLCB7XG4gICAgb25TdGVwOiBzdGVwQ2FsbGJhY2ssXG4gICAgdHlwZTogdXBkYXRlTG9vcCxcbiAgICB1cGRhdGVQcmlvcml0eTogdXBkYXRlUHJpb3JpdHlcbiAgfSksIGRlYnVnICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlYnVnLCBudWxsKSwgY2hpbGRyZW4pO1xufTtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIEluaXRpYXRlIGFuIGluc3RhbmNlIGFuZCByZXR1cm4gYSBzYWZlIGdldHRlclxuICovXG5cbmNvbnN0IHVzZUltcGVyYXRpdmVJbnN0YW5jZSA9IChjcmVhdGVGbiwgZGVzdHJveUZuLCBkZXBlbmRlbmN5TGlzdCkgPT4ge1xuICBjb25zdCByZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgZ2V0SW5zdGFuY2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFyZWYuY3VycmVudCkge1xuICAgICAgcmVmLmN1cnJlbnQgPSBjcmVhdGVGbigpO1xuICAgIH1cblxuICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgfSwgZGVwZW5kZW5jeUxpc3QpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNhdmUgdGhlIGRlc3Ryb3kgZnVuY3Rpb24gYW5kIGluc3RhbmNlXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRJbnN0YW5jZSgpO1xuXG4gICAgY29uc3QgZGVzdHJveSA9ICgpID0+IGRlc3Ryb3lGbihpbnN0YW5jZSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVzdHJveSgpO1xuICAgICAgcmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgfSwgW2dldEluc3RhbmNlXSk7XG4gIHJldHVybiBnZXRJbnN0YW5jZTtcbn07XG5cbi8qKlxuICogVGFrZXMgYW4gb2JqZWN0IHJlc2VtYmxpbmcgYSBWZWN0b3IzIGFuZCByZXR1cnMgYSBUaHJlZS5WZWN0b3IzXG4gKiBAY2F0ZWdvcnkgTWF0aCBoZWxwZXJzXG4gKi9cblxuY29uc3QgdmVjMyA9ICh7XG4gIHgsXG4gIHksXG4gIHpcbn0gPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHo6IDBcbn0pID0+IHtcbiAgcmV0dXJuIG5ldyBWZWN0b3IzKHgsIHksIHopO1xufTtcbi8qKlxuICogVGFrZXMgYW4gb2JqZWN0IHJlc2VtYmxpbmcgYSBRdWF0ZXJuaW9uIGFuZCByZXR1cnMgYSBUaHJlZS5RdWF0ZXJuaW9uXG4gKiBAY2F0ZWdvcnkgTWF0aCBoZWxwZXJzXG4gKi9cblxuY29uc3QgcXVhdCA9ICh7XG4gIHgsXG4gIHksXG4gIHosXG4gIHdcbn0gPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHo6IDAsXG4gIHc6IDFcbn0pID0+IHtcbiAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKHgsIHksIHosIHcpO1xufTtcbi8qKlxuICogVGFrZXMgYW4gb2JqZWN0IHJlc2VtYmxpbmcgYW4gRXVsZXIgYW5kIHJldHVycyBhIFRocmVlLkV1bGVyXG4gKiBAY2F0ZWdvcnkgTWF0aCBoZWxwZXJzXG4gKi9cblxuY29uc3QgZXVsZXIgPSAoe1xuICB4LFxuICB5LFxuICB6XG59ID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICB6OiAwXG59KSA9PiB7XG4gIHJldHVybiBuZXcgRXVsZXIoeCwgeSwgeik7XG59O1xuXG5jb25zdCB1c2VGb3J3YXJkZWRSZWYgPSAoZm9yd2FyZGVkUmVmLCBkZWZhdWx0VmFsdWUgPSBudWxsKSA9PiB7XG4gIGNvbnN0IGlubmVyUmVmID0gdXNlUmVmKGRlZmF1bHRWYWx1ZSk7IC8vIFVwZGF0ZSB0aGUgZm9yd2FyZGVkIHJlZiB3aGVuIHRoZSBpbm5lciByZWYgY2hhbmdlc1xuXG4gIGlmIChmb3J3YXJkZWRSZWYgJiYgdHlwZW9mIGZvcndhcmRlZFJlZiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaWYgKCFmb3J3YXJkZWRSZWYuY3VycmVudCkge1xuICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBpbm5lclJlZi5jdXJyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmb3J3YXJkZWRSZWY7XG4gIH1cblxuICByZXR1cm4gaW5uZXJSZWY7XG59O1xuXG4vKipcbiAqIEEgY29sbGlkZXIgaXMgYSBzaGFwZSB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHJpZ2lkIGJvZHkgdG8gZGVmaW5lIGl0cyBwaHlzaWNhbCBwcm9wZXJ0aWVzLlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEFueUNvbGxpZGVyID0gLyojX19QVVJFX18qL21lbW8oIC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBwb3NpdGlvbixcbiAgICByb3RhdGlvbixcbiAgICBxdWF0ZXJuaW9uLFxuICAgIHNjYWxlLFxuICAgIG5hbWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgd29ybGQsXG4gICAgY29sbGlkZXJFdmVudHMsXG4gICAgY29sbGlkZXJTdGF0ZXNcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCByaWdpZEJvZHlDb250ZXh0ID0gdXNlUmlnaWRCb2R5Q29udGV4dCgpO1xuICBjb25zdCBjb2xsaWRlclJlZiA9IHVzZUZvcndhcmRlZFJlZihmb3J3YXJkZWRSZWYpO1xuICBjb25zdCBvYmplY3RSZWYgPSB1c2VSZWYobnVsbCk7IC8vIFdlIHNwcmVhZCB0aGUgcHJvcHMgb3V0IGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHJlZiBpcyB1cGRhdGVkIHdoZW4gdGhlIHByb3BzIGNoYW5nZS5cblxuICBjb25zdCBpbW11dGFibGVQcm9wQXJyYXkgPSBpbW11dGFibGVDb2xsaWRlck9wdGlvbnMuZmxhdE1hcChrZXkgPT4gQXJyYXkuaXNBcnJheShwcm9wc1trZXldKSA/IFsuLi5wcm9wc1trZXldXSA6IHByb3BzW2tleV0pO1xuICBjb25zdCBnZXRJbnN0YW5jZSA9IHVzZUltcGVyYXRpdmVJbnN0YW5jZSgoKSA9PiB7XG4gICAgY29uc3Qgd29ybGRTY2FsZSA9IG9iamVjdFJlZi5jdXJyZW50LmdldFdvcmxkU2NhbGUodmVjMygpKTtcbiAgICBjb25zdCBjb2xsaWRlciA9IGNyZWF0ZUNvbGxpZGVyRnJvbU9wdGlvbnMocHJvcHMsIHdvcmxkLCB3b3JsZFNjYWxlLCByaWdpZEJvZHlDb250ZXh0ID09PSBudWxsIHx8IHJpZ2lkQm9keUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJpZ2lkQm9keUNvbnRleHQuZ2V0UmlnaWRCb2R5KTtcblxuICAgIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yd2FyZGVkUmVmKGNvbGxpZGVyKTtcbiAgICB9XG5cbiAgICBjb2xsaWRlclJlZi5jdXJyZW50ID0gY29sbGlkZXI7XG4gICAgcmV0dXJuIGNvbGxpZGVyO1xuICB9LCBjb2xsaWRlciA9PiB7XG4gICAgaWYgKHdvcmxkLmdldENvbGxpZGVyKGNvbGxpZGVyLmhhbmRsZSkpIHtcbiAgICAgIHdvcmxkLnJlbW92ZUNvbGxpZGVyKGNvbGxpZGVyLCB0cnVlKTtcbiAgICB9XG4gIH0sIFsuLi5pbW11dGFibGVQcm9wQXJyYXksIHJpZ2lkQm9keUNvbnRleHRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb2xsaWRlciA9IGdldEluc3RhbmNlKCk7XG4gICAgY29sbGlkZXJTdGF0ZXMuc2V0KGNvbGxpZGVyLmhhbmRsZSwgY3JlYXRlQ29sbGlkZXJTdGF0ZShjb2xsaWRlciwgb2JqZWN0UmVmLmN1cnJlbnQsIHJpZ2lkQm9keUNvbnRleHQgPT09IG51bGwgfHwgcmlnaWRCb2R5Q29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmlnaWRCb2R5Q29udGV4dC5yZWYuY3VycmVudCkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb2xsaWRlclN0YXRlcy5kZWxldGUoY29sbGlkZXIuaGFuZGxlKTtcbiAgICB9O1xuICB9LCBbZ2V0SW5zdGFuY2VdKTtcbiAgY29uc3QgbWVyZ2VkUHJvcHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNsZWFuUmlnaWRCb2R5UHJvcHNGb3JDb2xsaWRlcihyaWdpZEJvZHlDb250ZXh0ID09PSBudWxsIHx8IHJpZ2lkQm9keUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJpZ2lkQm9keUNvbnRleHQub3B0aW9ucykpLCBwcm9wcyk7XG4gIH0sIFtwcm9wcywgcmlnaWRCb2R5Q29udGV4dCA9PT0gbnVsbCB8fCByaWdpZEJvZHlDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByaWdpZEJvZHlDb250ZXh0Lm9wdGlvbnNdKTtcbiAgdXNlVXBkYXRlQ29sbGlkZXJPcHRpb25zKGdldEluc3RhbmNlLCBtZXJnZWRQcm9wcywgY29sbGlkZXJTdGF0ZXMpO1xuICB1c2VDb2xsaWRlckV2ZW50cyhnZXRJbnN0YW5jZSwgbWVyZ2VkUHJvcHMsIGNvbGxpZGVyRXZlbnRzLCBnZXRBY3RpdmVDb2xsaXNpb25FdmVudHNGcm9tUHJvcHMocmlnaWRCb2R5Q29udGV4dCA9PT0gbnVsbCB8fCByaWdpZEJvZHlDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByaWdpZEJvZHlDb250ZXh0Lm9wdGlvbnMpKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIiwge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgcXVhdGVybmlvbjogcXVhdGVybmlvbixcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgcmVmOiBvYmplY3RSZWYsXG4gICAgbmFtZTogbmFtZVxuICB9LCBjaGlsZHJlbik7XG59KSk7XG5cbi8qKlxuICogQSBjdWJvaWQgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQ3Vib2lkQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHNoYXBlOiBcImN1Ym9pZFwiLFxuICAgIHJlZjogcmVmXG4gIH0pKTtcbn0pO1xuQ3Vib2lkQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIkN1Ym9pZENvbGxpZGVyXCI7XG5cbi8qKlxuICogQSByb3VuZCBjdWJvaWQgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgUm91bmRDdWJvaWRDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcInJvdW5kQ3Vib2lkXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuUm91bmRDdWJvaWRDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiUm91bmRDdWJvaWRDb2xsaWRlclwiO1xuXG4vKipcbiAqIEEgYmFsbCBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBCYWxsQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJiYWxsXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQmFsbENvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJCYWxsQ29sbGlkZXJcIjtcblxuLyoqXG4gKiBBIGNhcHN1bGUgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQ2Fwc3VsZUNvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiY2Fwc3VsZVwiLFxuICByZWY6IHJlZlxufSkpKTtcbkNhcHN1bGVDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiQ2Fwc3VsZUNvbGxpZGVyXCI7XG5cbi8qKlxuICogQSBoZWlnaHRmaWVsZCBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBIZWlnaHRmaWVsZENvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiaGVpZ2h0ZmllbGRcIixcbiAgcmVmOiByZWZcbn0pKSk7XG5IZWlnaHRmaWVsZENvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJIZWlnaHRmaWVsZENvbGxpZGVyXCI7XG5cbi8qKlxuICogQSB0cmltZXNoIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IFRyaW1lc2hDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcInRyaW1lc2hcIixcbiAgcmVmOiByZWZcbn0pKSk7XG5UcmltZXNoQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIlRyaW1lc2hDb2xsaWRlclwiO1xuXG4vKipcbiAqIEEgY29uZSBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBDb25lQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJjb25lXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQ29uZUNvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJDb25lQ29sbGlkZXJcIjtcblxuLyoqXG4gKiBBIHJvdW5kIGN5bGluZGVyIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IFJvdW5kQ29uZUNvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwicm91bmRDb25lXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuUm91bmRDb25lQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIlJvdW5kQ29uZUNvbGxpZGVyXCI7XG5cbi8qKlxuICogQSBjeWxpbmRlciBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBDeWxpbmRlckNvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiY3lsaW5kZXJcIixcbiAgcmVmOiByZWZcbn0pKSk7XG5DeWxpbmRlckNvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJDeWxpbmRlckNvbGxpZGVyXCI7XG5cbi8qKlxuICogQSByb3VuZCBjeWxpbmRlciBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBSb3VuZEN5bGluZGVyQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJyb3VuZEN5bGluZGVyXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQ3lsaW5kZXJDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiUm91bmRDeWxpbmRlckNvbGxpZGVyXCI7XG5cbi8qKlxuICogQSBjb252ZXggaHVsbCBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBDb252ZXhIdWxsQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJjb252ZXhIdWxsXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQ29udmV4SHVsbENvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJDb252ZXhIdWxsQ29sbGlkZXJcIjtcblxuY29uc3QgcmlnaWRCb2R5RGVzY0Zyb21PcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIHZhciBfb3B0aW9ucyRjYW5TbGVlcDtcblxuICBjb25zdCB0eXBlID0gcmlnaWRCb2R5VHlwZUZyb21TdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50eXBlKSB8fCBcImR5bmFtaWNcIik7XG4gIGNvbnN0IGRlc2MgPSBuZXcgUmlnaWRCb2R5RGVzYyh0eXBlKTsgLy8gQXBwbHkgaW1tdXRhYmxlIG9wdGlvbnNcblxuICBkZXNjLmNhblNsZWVwID0gKF9vcHRpb25zJGNhblNsZWVwID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhblNsZWVwKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRjYW5TbGVlcCAhPT0gdm9pZCAwID8gX29wdGlvbnMkY2FuU2xlZXAgOiB0cnVlO1xuICByZXR1cm4gZGVzYztcbn07XG5jb25zdCBjcmVhdGVSaWdpZEJvZHlTdGF0ZSA9ICh7XG4gIHJpZ2lkQm9keSxcbiAgb2JqZWN0LFxuICBzZXRNYXRyaXgsXG4gIGdldE1hdHJpeCxcbiAgd29ybGRTY2FsZSxcbiAgbWVzaFR5cGU6IF9tZXNoVHlwZSA9IFwibWVzaFwiXG59KSA9PiB7XG4gIG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG4gIGNvbnN0IGludmVydGVkV29ybGRNYXRyaXggPSBvYmplY3QucGFyZW50Lm1hdHJpeFdvcmxkLmNsb25lKCkuaW52ZXJ0KCk7XG4gIHJldHVybiB7XG4gICAgb2JqZWN0LFxuICAgIHJpZ2lkQm9keSxcbiAgICBpbnZlcnRlZFdvcmxkTWF0cml4LFxuICAgIHNldE1hdHJpeDogc2V0TWF0cml4ID8gc2V0TWF0cml4IDogbWF0cml4ID0+IHtcbiAgICAgIG9iamVjdC5tYXRyaXguY29weShtYXRyaXgpO1xuICAgIH0sXG4gICAgZ2V0TWF0cml4OiBnZXRNYXRyaXggPyBnZXRNYXRyaXggOiBtYXRyaXggPT4gbWF0cml4LmNvcHkob2JqZWN0Lm1hdHJpeCksXG4gICAgc2NhbGU6IHdvcmxkU2NhbGUgfHwgb2JqZWN0LmdldFdvcmxkU2NhbGUoX3NjYWxlKS5jbG9uZSgpLFxuICAgIGlzU2xlZXBpbmc6IGZhbHNlLFxuICAgIG1lc2hUeXBlOiBfbWVzaFR5cGVcbiAgfTtcbn07XG5jb25zdCBpbW11dGFibGVSaWdpZEJvZHlPcHRpb25zID0gW1wiYXJnc1wiLCBcImNvbGxpZGVyc1wiLCBcImNhblNsZWVwXCJdO1xuY29uc3QgbXV0YWJsZVJpZ2lkQm9keU9wdGlvbnMgPSB7XG4gIGdyYXZpdHlTY2FsZTogKHJiLCB2YWx1ZSkgPT4ge1xuICAgIHJiLnNldEdyYXZpdHlTY2FsZSh2YWx1ZSwgdHJ1ZSk7XG4gIH0sXG5cbiAgYWRkaXRpb25hbFNvbHZlckl0ZXJhdGlvbnMocmIsIHZhbHVlKSB7XG4gICAgcmIuc2V0QWRkaXRpb25hbFNvbHZlckl0ZXJhdGlvbnModmFsdWUpO1xuICB9LFxuXG4gIGxpbmVhckRhbXBpbmc6IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi5zZXRMaW5lYXJEYW1waW5nKHZhbHVlKTtcbiAgfSxcbiAgYW5ndWxhckRhbXBpbmc6IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi5zZXRBbmd1bGFyRGFtcGluZyh2YWx1ZSk7XG4gIH0sXG4gIGRvbWluYW5jZUdyb3VwOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIuc2V0RG9taW5hbmNlR3JvdXAodmFsdWUpO1xuICB9LFxuICBlbmFibGVkUm90YXRpb25zOiAocmIsIFt4LCB5LCB6XSkgPT4ge1xuICAgIHJiLnNldEVuYWJsZWRSb3RhdGlvbnMoeCwgeSwgeiwgdHJ1ZSk7XG4gIH0sXG4gIGVuYWJsZWRUcmFuc2xhdGlvbnM6IChyYiwgW3gsIHksIHpdKSA9PiB7XG4gICAgcmIuc2V0RW5hYmxlZFRyYW5zbGF0aW9ucyh4LCB5LCB6LCB0cnVlKTtcbiAgfSxcbiAgbG9ja1JvdGF0aW9uczogKHJiLCB2YWx1ZSkgPT4ge1xuICAgIHJiLmxvY2tSb3RhdGlvbnModmFsdWUsIHRydWUpO1xuICB9LFxuICBsb2NrVHJhbnNsYXRpb25zOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIubG9ja1RyYW5zbGF0aW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gIH0sXG4gIGFuZ3VsYXJWZWxvY2l0eTogKHJiLCBbeCwgeSwgel0pID0+IHtcbiAgICByYi5zZXRBbmd2ZWwoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6XG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG4gIGxpbmVhclZlbG9jaXR5OiAocmIsIFt4LCB5LCB6XSkgPT4ge1xuICAgIHJiLnNldExpbnZlbCh7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHpcbiAgICB9LCB0cnVlKTtcbiAgfSxcbiAgY2NkOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIuZW5hYmxlQ2NkKHZhbHVlKTtcbiAgfSxcbiAgdXNlckRhdGE6IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi51c2VyRGF0YSA9IHZhbHVlO1xuICB9LFxuXG4gIHR5cGUocmIsIHZhbHVlKSB7XG4gICAgcmIuc2V0Qm9keVR5cGUocmlnaWRCb2R5VHlwZUZyb21TdHJpbmcodmFsdWUpLCB0cnVlKTtcbiAgfSxcblxuICBwb3NpdGlvbjogKCkgPT4ge30sXG4gIHJvdGF0aW9uOiAoKSA9PiB7fSxcbiAgcXVhdGVybmlvbjogKCkgPT4ge30sXG4gIHNjYWxlOiAoKSA9PiB7fVxufTtcbmNvbnN0IG11dGFibGVSaWdpZEJvZHlPcHRpb25LZXlzID0gT2JqZWN0LmtleXMobXV0YWJsZVJpZ2lkQm9keU9wdGlvbnMpO1xuY29uc3Qgc2V0UmlnaWRCb2R5T3B0aW9ucyA9IChyaWdpZEJvZHksIG9wdGlvbnMsIHN0YXRlcywgdXBkYXRlVHJhbnNsYXRpb25zID0gdHJ1ZSkgPT4ge1xuICBpZiAoIXJpZ2lkQm9keSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0gc3RhdGVzLmdldChyaWdpZEJvZHkuaGFuZGxlKTtcblxuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodXBkYXRlVHJhbnNsYXRpb25zKSB7XG4gICAgICBzdGF0ZS5vYmplY3QudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXG4gICAgICBfbWF0cml4NC5jb3B5KHN0YXRlLm9iamVjdC5tYXRyaXhXb3JsZCkuZGVjb21wb3NlKF9wb3NpdGlvbiwgX3JvdGF0aW9uLCBfc2NhbGUpO1xuXG4gICAgICByaWdpZEJvZHkuc2V0VHJhbnNsYXRpb24oX3Bvc2l0aW9uLCBmYWxzZSk7XG4gICAgICByaWdpZEJvZHkuc2V0Um90YXRpb24oX3JvdGF0aW9uLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgbXV0YWJsZVJpZ2lkQm9keU9wdGlvbktleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIG11dGFibGVSaWdpZEJvZHlPcHRpb25zW2tleV0ocmlnaWRCb2R5LCBvcHRpb25zW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuY29uc3QgdXNlVXBkYXRlUmlnaWRCb2R5T3B0aW9ucyA9IChnZXRSaWdpZEJvZHksIHByb3BzLCBzdGF0ZXMsIHVwZGF0ZVRyYW5zbGF0aW9ucyA9IHRydWUpID0+IHtcbiAgLy8gVE9ETzogSW1wcm92ZSB0aGlzLCBzcGxpdCBlYWNoIHByb3AgaW50byBpdHMgb3duIGVmZmVjdFxuICBjb25zdCBtdXRhYmxlUHJvcHNBc0ZsYXRBcnJheSA9IHVzZU1lbW8oKCkgPT4gbXV0YWJsZVJpZ2lkQm9keU9wdGlvbktleXMuZmxhdE1hcChrZXkgPT4ge1xuICAgIHJldHVybiB2ZWN0b3JUb1R1cGxlKHByb3BzW2tleV0pO1xuICB9KSwgW3Byb3BzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgcmlnaWRCb2R5ID0gZ2V0UmlnaWRCb2R5KCk7XG4gICAgc2V0UmlnaWRCb2R5T3B0aW9ucyhyaWdpZEJvZHksIHByb3BzLCBzdGF0ZXMsIHVwZGF0ZVRyYW5zbGF0aW9ucyk7XG4gIH0sIG11dGFibGVQcm9wc0FzRmxhdEFycmF5KTtcbn07XG5jb25zdCB1c2VSaWdpZEJvZHlFdmVudHMgPSAoZ2V0UmlnaWRCb2R5LCBwcm9wcywgZXZlbnRzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvbldha2UsXG4gICAgb25TbGVlcCxcbiAgICBvbkNvbGxpc2lvbkVudGVyLFxuICAgIG9uQ29sbGlzaW9uRXhpdCxcbiAgICBvbkludGVyc2VjdGlvbkVudGVyLFxuICAgIG9uSW50ZXJzZWN0aW9uRXhpdCxcbiAgICBvbkNvbnRhY3RGb3JjZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGV2ZW50SGFuZGxlcnMgPSB7XG4gICAgb25XYWtlLFxuICAgIG9uU2xlZXAsXG4gICAgb25Db2xsaXNpb25FbnRlcixcbiAgICBvbkNvbGxpc2lvbkV4aXQsXG4gICAgb25JbnRlcnNlY3Rpb25FbnRlcixcbiAgICBvbkludGVyc2VjdGlvbkV4aXQsXG4gICAgb25Db250YWN0Rm9yY2VcbiAgfTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCByaWdpZEJvZHkgPSBnZXRSaWdpZEJvZHkoKTtcbiAgICBldmVudHMuc2V0KHJpZ2lkQm9keS5oYW5kbGUsIGV2ZW50SGFuZGxlcnMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMuZGVsZXRlKHJpZ2lkQm9keS5oYW5kbGUpO1xuICAgIH07XG4gIH0sIFtvbldha2UsIG9uU2xlZXAsIG9uQ29sbGlzaW9uRW50ZXIsIG9uQ29sbGlzaW9uRXhpdCwgb25JbnRlcnNlY3Rpb25FbnRlciwgb25JbnRlcnNlY3Rpb25FeGl0LCBvbkNvbnRhY3RGb3JjZV0pO1xufTtcblxuY29uc3QgX2V4Y2x1ZGVkJDEgPSBbXCJjaGlsZHJlblwiLCBcInR5cGVcIiwgXCJwb3NpdGlvblwiLCBcInJvdGF0aW9uXCIsIFwic2NhbGVcIiwgXCJxdWF0ZXJuaW9uXCIsIFwidHJhbnNmb3JtU3RhdGVcIl07XG5jb25zdCBSaWdpZEJvZHlDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmNvbnN0IHVzZVJpZ2lkQm9keUNvbnRleHQgPSAoKSA9PiB1c2VDb250ZXh0KFJpZ2lkQm9keUNvbnRleHQpO1xuXG4vKipcbiAqIEEgcmlnaWQgYm9keSBpcyBhIHBoeXNpY2FsIG9iamVjdCB0aGF0IGNhbiBiZSBzaW11bGF0ZWQgYnkgdGhlIHBoeXNpY3MgZW5naW5lLlxuICogQGNhdGVnb3J5IENvbXBvbmVudHNcbiAqL1xuY29uc3QgUmlnaWRCb2R5ID0gLyojX19QVVJFX18qL21lbW8oIC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICB0eXBlLFxuICAgIHBvc2l0aW9uLFxuICAgIHJvdGF0aW9uLFxuICAgIHNjYWxlLFxuICAgIHF1YXRlcm5pb24sXG4gICAgdHJhbnNmb3JtU3RhdGVcbiAgfSA9IHByb3BzLFxuICAgICAgICBvYmplY3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkJDEpO1xuXG4gIGNvbnN0IG9iamVjdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcmlnaWRCb2R5UmVmID0gdXNlRm9yd2FyZGVkUmVmKGZvcndhcmRlZFJlZik7XG4gIGNvbnN0IHtcbiAgICB3b3JsZCxcbiAgICByaWdpZEJvZHlTdGF0ZXMsXG4gICAgcGh5c2ljc09wdGlvbnMsXG4gICAgcmlnaWRCb2R5RXZlbnRzXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGh5c2ljc09wdGlvbnMpLCBwcm9wcyksIHt9LCB7XG4gICAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0sIFtwaHlzaWNzT3B0aW9ucywgcHJvcHNdKTtcbiAgY29uc3QgaW1tdXRhYmxlUHJvcEFycmF5ID0gaW1tdXRhYmxlUmlnaWRCb2R5T3B0aW9ucy5mbGF0TWFwKGtleSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobWVyZ2VkT3B0aW9uc1trZXldKSA/IFsuLi5tZXJnZWRPcHRpb25zW2tleV1dIDogbWVyZ2VkT3B0aW9uc1trZXldO1xuICB9KTtcbiAgY29uc3QgY2hpbGRDb2xsaWRlclByb3BzID0gdXNlQ2hpbGRDb2xsaWRlclByb3BzKG9iamVjdFJlZiwgbWVyZ2VkT3B0aW9ucyk7IC8vIFByb3ZpZGUgYSB3YXkgdG8gZWFnZXJseSBjcmVhdGUgcmlnaWRib2R5XG5cbiAgY29uc3QgZ2V0UmlnaWRCb2R5ID0gdXNlSW1wZXJhdGl2ZUluc3RhbmNlKCgpID0+IHtcbiAgICBjb25zdCBkZXNjID0gcmlnaWRCb2R5RGVzY0Zyb21PcHRpb25zKG1lcmdlZE9wdGlvbnMpO1xuICAgIGNvbnN0IHJpZ2lkQm9keSA9IHdvcmxkLmNyZWF0ZVJpZ2lkQm9keShkZXNjKTtcblxuICAgIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvcndhcmRlZFJlZihyaWdpZEJvZHkpO1xuICAgIH1cblxuICAgIHJpZ2lkQm9keVJlZi5jdXJyZW50ID0gcmlnaWRCb2R5O1xuICAgIHJldHVybiByaWdpZEJvZHk7XG4gIH0sIHJpZ2lkQm9keSA9PiB7XG4gICAgaWYgKHdvcmxkLmdldFJpZ2lkQm9keShyaWdpZEJvZHkuaGFuZGxlKSkge1xuICAgICAgd29ybGQucmVtb3ZlUmlnaWRCb2R5KHJpZ2lkQm9keSk7XG4gICAgfVxuICB9LCBpbW11dGFibGVQcm9wQXJyYXkpOyAvLyBPbmx5IHByb3ZpZGUgYSBvYmplY3Qgc3RhdGUgYWZ0ZXIgdGhlIHJlZiBoYXMgYmVlbiBzZXRcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHJpZ2lkQm9keSA9IGdldFJpZ2lkQm9keSgpO1xuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlUmlnaWRCb2R5U3RhdGUoe1xuICAgICAgcmlnaWRCb2R5LFxuICAgICAgb2JqZWN0OiBvYmplY3RSZWYuY3VycmVudFxuICAgIH0pO1xuICAgIHJpZ2lkQm9keVN0YXRlcy5zZXQocmlnaWRCb2R5LmhhbmRsZSwgcHJvcHMudHJhbnNmb3JtU3RhdGUgPyBwcm9wcy50cmFuc2Zvcm1TdGF0ZShzdGF0ZSkgOiBzdGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJpZ2lkQm9keVN0YXRlcy5kZWxldGUocmlnaWRCb2R5LmhhbmRsZSk7XG4gICAgfTtcbiAgfSwgW2dldFJpZ2lkQm9keV0pO1xuICB1c2VVcGRhdGVSaWdpZEJvZHlPcHRpb25zKGdldFJpZ2lkQm9keSwgbWVyZ2VkT3B0aW9ucywgcmlnaWRCb2R5U3RhdGVzKTtcbiAgdXNlUmlnaWRCb2R5RXZlbnRzKGdldFJpZ2lkQm9keSwgbWVyZ2VkT3B0aW9ucywgcmlnaWRCb2R5RXZlbnRzKTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZjogb2JqZWN0UmVmLFxuICAgICAgZ2V0UmlnaWRCb2R5OiBnZXRSaWdpZEJvZHksXG4gICAgICBvcHRpb25zOiBtZXJnZWRPcHRpb25zXG4gICAgfTtcbiAgfSwgW2dldFJpZ2lkQm9keV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmlnaWRCb2R5Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3QzRFwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBvYmplY3RSZWZcbiAgfSwgb2JqZWN0UHJvcHMsIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgIHF1YXRlcm5pb246IHF1YXRlcm5pb24sXG4gICAgc2NhbGU6IHNjYWxlXG4gIH0pLCBjaGlsZHJlbiwgY2hpbGRDb2xsaWRlclByb3BzLm1hcCgoY29sbGlkZXJQcm9wcywgaW5kZXgpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBpbmRleFxuICB9LCBjb2xsaWRlclByb3BzKSkpKSk7XG59KSk7XG5SaWdpZEJvZHkuZGlzcGxheU5hbWUgPSBcIlJpZ2lkQm9keVwiO1xuXG4vKipcbiAqIEEgbWVzaCBjb2xsaWRlciBpcyBhIGNvbGxpZGVyIHRoYXQgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZnJvbSB0aGUgZ2VvbWV0cnkgb2YgdGhlIGNoaWxkcmVuLlxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBNZXNoQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovbWVtbyhwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICB0eXBlXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qge1xuICAgIHBoeXNpY3NPcHRpb25zXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3Qgb2JqZWN0ID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgb3B0aW9uc1xuICB9ID0gdXNlUmlnaWRCb2R5Q29udGV4dCgpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwaHlzaWNzT3B0aW9ucyksIG9wdGlvbnMpLCB7fSwge1xuICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZCxcbiAgICAgIGNvbGxpZGVyczogdHlwZVxuICAgIH0pO1xuICB9LCBbcGh5c2ljc09wdGlvbnMsIG9wdGlvbnNdKTtcbiAgY29uc3QgY2hpbGRDb2xsaWRlclByb3BzID0gdXNlQ2hpbGRDb2xsaWRlclByb3BzKG9iamVjdCwgbWVyZ2VkT3B0aW9ucywgZmFsc2UpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3QzRFwiLCB7XG4gICAgcmVmOiBvYmplY3QsXG4gICAgdXNlckRhdGE6IHtcbiAgICAgIHIzUmFwaWVyVHlwZTogXCJNZXNoQ29sbGlkZXJcIlxuICAgIH1cbiAgfSwgY2hpbGRyZW4sIGNoaWxkQ29sbGlkZXJQcm9wcy5tYXAoKGNvbGxpZGVyUHJvcHMsIGluZGV4KSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe1xuICAgIGtleTogaW5kZXhcbiAgfSwgY29sbGlkZXJQcm9wcykpKSk7XG59KTtcbk1lc2hDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiTWVzaENvbGxpZGVyXCI7XG5cbmNvbnN0IF9leGNsdWRlZCA9IFtcImNoaWxkcmVuXCIsIFwiaW5zdGFuY2VzXCIsIFwiY29sbGlkZXJOb2Rlc1wiLCBcInBvc2l0aW9uXCIsIFwicm90YXRpb25cIiwgXCJxdWF0ZXJuaW9uXCIsIFwic2NhbGVcIl07XG5jb25zdCBJbnN0YW5jZWRSaWdpZEJvZGllcyA9IC8qI19fUFVSRV9fKi9tZW1vKCAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCByaWdpZEJvZGllc1JlZiA9IHVzZUZvcndhcmRlZFJlZihmb3J3YXJkZWRSZWYsIFtdKTtcbiAgY29uc3Qgb2JqZWN0UmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBpbnN0YW5jZVdyYXBwZXJSZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgY29uc3Qge1xuICAgIC8vIGluc3RhbmNlZCBwcm9wc1xuICAgIGNoaWxkcmVuLFxuICAgIGluc3RhbmNlcyxcbiAgICBjb2xsaWRlck5vZGVzID0gW10sXG4gICAgLy8gd3JhcHBlciBvYmplY3QgcHJvcHNcbiAgICBwb3NpdGlvbixcbiAgICByb3RhdGlvbixcbiAgICBxdWF0ZXJuaW9uLFxuICAgIHNjYWxlXG4gIH0gPSBwcm9wcyxcbiAgICAgICAgcmlnaWRCb2R5UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCk7XG5cbiAgY29uc3QgY2hpbGRDb2xsaWRlclByb3BzID0gdXNlQ2hpbGRDb2xsaWRlclByb3BzKG9iamVjdFJlZiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHByb3BzKSwge30sIHtcbiAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gIH0pKTtcblxuICBjb25zdCBnZXRJbnN0YW5jZWRNZXNoID0gKCkgPT4ge1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBpbnN0YW5jZVdyYXBwZXJSZWYuY3VycmVudC5jaGlsZHJlblswXTtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIFwiaXNJbnN0YW5jZWRNZXNoXCIgaW4gZmlyc3RDaGlsZCkge1xuICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlZE1lc2ggPSBnZXRJbnN0YW5jZWRNZXNoKCk7XG5cbiAgICBpZiAoaW5zdGFuY2VkTWVzaCkge1xuICAgICAgaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeC5zZXRVc2FnZShEeW5hbWljRHJhd1VzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiSW5zdGFuY2VkUmlnaWRCb2RpZXMgZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCwgd2hpY2ggbXVzdCBiZSBhbiBJbnN0YW5jZWRNZXNoXCIpO1xuICAgIH1cbiAgfSwgW10pOyAvLyBVcGRhdGUgdGhlIFJpZ2lkQm9keVN0YXRlcyB3aGVuZXZlciB0aGUgaW5zdGFuY2VzIGNoYW5nZVxuXG4gIGNvbnN0IGFwcGx5SW5zdGFuY2VkU3RhdGUgPSAoc3RhdGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2VkTWVzaCA9IGdldEluc3RhbmNlZE1lc2goKTtcblxuICAgIGlmIChpbnN0YW5jZWRNZXNoKSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHN0YXRlKSwge30sIHtcbiAgICAgICAgZ2V0TWF0cml4OiBtYXRyaXggPT4ge1xuICAgICAgICAgIGluc3RhbmNlZE1lc2guZ2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCk7XG4gICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TWF0cml4OiBtYXRyaXggPT4ge1xuICAgICAgICAgIGluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCk7XG4gICAgICAgICAgaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG1lc2hUeXBlOiBcImluc3RhbmNlZE1lc2hcIlxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm9iamVjdDNEXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IG9iamVjdFJlZlxuICB9LCByaWdpZEJvZHlQcm9wcywge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgcXVhdGVybmlvbjogcXVhdGVybmlvbixcbiAgICBzY2FsZTogc2NhbGVcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIiwge1xuICAgIHJlZjogaW5zdGFuY2VXcmFwcGVyUmVmXG4gIH0sIGNoaWxkcmVuKSwgaW5zdGFuY2VzID09PSBudWxsIHx8IGluc3RhbmNlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UsIGluZGV4KSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSaWdpZEJvZHksIF9leHRlbmRzKHt9LCByaWdpZEJvZHlQcm9wcywgaW5zdGFuY2UsIHtcbiAgICByZWY6IGJvZHkgPT4gcmlnaWRCb2RpZXNSZWYuY3VycmVudFtpbmRleF0gPSBib2R5LFxuICAgIHRyYW5zZm9ybVN0YXRlOiBzdGF0ZSA9PiBhcHBseUluc3RhbmNlZFN0YXRlKHN0YXRlLCBpbmRleClcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb2xsaWRlck5vZGVzLm1hcCgobm9kZSwgaW5kZXgpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7XG4gICAga2V5OiBpbmRleFxuICB9LCBub2RlKSksIGNoaWxkQ29sbGlkZXJQcm9wcy5tYXAoKGNvbGxpZGVyUHJvcHMsIGNvbGxpZGVySW5kZXgpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBjb2xsaWRlckluZGV4XG4gIH0sIGNvbGxpZGVyUHJvcHMpKSkpKSkpO1xufSkpO1xuSW5zdGFuY2VkUmlnaWRCb2RpZXMuZGlzcGxheU5hbWUgPSBcIkluc3RhbmNlZFJpZ2lkQm9kaWVzXCI7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuY29uc3QgdXNlSW1wdWxzZUpvaW50ID0gKGJvZHkxLCBib2R5MiwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB3b3JsZFxuICB9ID0gdXNlUmFwaWVyKCk7XG4gIGNvbnN0IGpvaW50UmVmID0gdXNlUmVmKCk7XG4gIHVzZUltcGVyYXRpdmVJbnN0YW5jZSgoKSA9PiB7XG4gICAgaWYgKGJvZHkxLmN1cnJlbnQgJiYgYm9keTIuY3VycmVudCkge1xuICAgICAgY29uc3QgbmV3Sm9pbnQgPSB3b3JsZC5jcmVhdGVJbXB1bHNlSm9pbnQocGFyYW1zLCBib2R5MS5jdXJyZW50LCBib2R5Mi5jdXJyZW50LCB0cnVlKTtcbiAgICAgIGpvaW50UmVmLmN1cnJlbnQgPSBuZXdKb2ludDtcbiAgICAgIHJldHVybiBuZXdKb2ludDtcbiAgICB9XG4gIH0sIGpvaW50ID0+IHtcbiAgICBpZiAoam9pbnQpIHtcbiAgICAgIGpvaW50UmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh3b3JsZC5nZXRJbXB1bHNlSm9pbnQoam9pbnQuaGFuZGxlKSkge1xuICAgICAgICB3b3JsZC5yZW1vdmVJbXB1bHNlSm9pbnQoam9pbnQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gam9pbnRSZWY7XG59O1xuLyoqXG4gKiBBIGZpeGVkIGpvaW50IGVuc3VyZXMgdGhhdCB0d28gcmlnaWQtYm9kaWVzIGRvbid0IG1vdmUgcmVsYXRpdmUgdG8gZWFjaCBvdGhlci5cbiAqIEZpeGVkIGpvaW50cyBhcmUgY2hhcmFjdGVyaXplZCBieSBvbmUgbG9jYWwgZnJhbWUgKHJlcHJlc2VudGVkIGJ5IGFuIGlzb21ldHJ5KSBvbiBlYWNoIHJpZ2lkLWJvZHkuXG4gKiBUaGUgZml4ZWQtam9pbnQgbWFrZXMgdGhlc2UgZnJhbWVzIGNvaW5jaWRlIGluIHdvcmxkLXNwYWNlLlxuICpcbiAqIEBjYXRlZ29yeSBIb29rcyAtIEpvaW50c1xuICovXG5cbmNvbnN0IHVzZUZpeGVkSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBbYm9keTFBbmNob3IsIGJvZHkxTG9jYWxGcmFtZSwgYm9keTJBbmNob3IsIGJvZHkyTG9jYWxGcmFtZV0pID0+IHtcbiAgY29uc3Qge1xuICAgIHJhcGllclxuICB9ID0gdXNlUmFwaWVyKCk7XG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCByYXBpZXIuSm9pbnREYXRhLmZpeGVkKHZlY3RvcjNUb1JhcGllclZlY3Rvcihib2R5MUFuY2hvciksIHF1YXRlcm5pb25Ub1JhcGllclF1YXRlcm5pb24oYm9keTFMb2NhbEZyYW1lKSwgdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkyQW5jaG9yKSwgcXVhdGVybmlvblRvUmFwaWVyUXVhdGVybmlvbihib2R5MkxvY2FsRnJhbWUpKSk7XG59O1xuLyoqXG4gKiBUaGUgc3BoZXJpY2FsIGpvaW50IGVuc3VyZXMgdGhhdCB0d28gcG9pbnRzIG9uIHRoZSBsb2NhbC1zcGFjZXMgb2YgdHdvIHJpZ2lkLWJvZGllcyBhbHdheXMgY29pbmNpZGUgKGl0IHByZXZlbnRzIGFueSByZWxhdGl2ZVxuICogdHJhbnNsYXRpb25hbCBtb3Rpb24gYXQgdGhpcyBwb2ludHMpLiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIHRvIHNpbXVsYXRlIHJhZ2RvbGxzIGFybXMsIHBlbmR1bHVtcywgZXRjLlxuICogVGhleSBhcmUgY2hhcmFjdGVyaXplZCBieSBvbmUgbG9jYWwgYW5jaG9yIG9uIGVhY2ggcmlnaWQtYm9keS4gRWFjaCBhbmNob3IgcmVwcmVzZW50cyB0aGUgbG9jYXRpb24gb2YgdGhlXG4gKiBwb2ludHMgdGhhdCBuZWVkIHRvIGNvaW5jaWRlIG9uIHRoZSBsb2NhbC1zcGFjZSBvZiBlYWNoIHJpZ2lkLWJvZHkuXG4gKlxuICogQGNhdGVnb3J5IEhvb2tzIC0gSm9pbnRzXG4gKi9cblxuY29uc3QgdXNlU3BoZXJpY2FsSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBbYm9keTFBbmNob3IsIGJvZHkyQW5jaG9yXSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmFwaWVyXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgcmV0dXJuIHVzZUltcHVsc2VKb2ludChib2R5MSwgYm9keTIsIHJhcGllci5Kb2ludERhdGEuc3BoZXJpY2FsKHZlY3RvcjNUb1JhcGllclZlY3Rvcihib2R5MUFuY2hvciksIHZlY3RvcjNUb1JhcGllclZlY3Rvcihib2R5MkFuY2hvcikpKTtcbn07XG4vKipcbiAqIFRoZSByZXZvbHV0ZSBqb2ludCBwcmV2ZW50cyBhbnkgcmVsYXRpdmUgbW92ZW1lbnQgYmV0d2VlbiB0d28gcmlnaWQtYm9kaWVzLCBleGNlcHQgZm9yIHJlbGF0aXZlXG4gKiByb3RhdGlvbnMgYWxvbmcgb25lIGF4aXMuIFRoaXMgaXMgdHlwaWNhbGx5IHVzZWQgdG8gc2ltdWxhdGUgd2hlZWxzLCBmYW5zLCBldGMuXG4gKiBUaGV5IGFyZSBjaGFyYWN0ZXJpemVkIGJ5IG9uZSBsb2NhbCBhbmNob3IgYXMgd2VsbCBhcyBvbmUgbG9jYWwgYXhpcyBvbiBlYWNoIHJpZ2lkLWJvZHkuXG4gKlxuICogQGNhdGVnb3J5IEhvb2tzIC0gSm9pbnRzXG4gKi9cblxuY29uc3QgdXNlUmV2b2x1dGVKb2ludCA9IChib2R5MSwgYm9keTIsIFtib2R5MUFuY2hvciwgYm9keTJBbmNob3IsIGF4aXMsIGxpbWl0c10pID0+IHtcbiAgY29uc3Qge1xuICAgIHJhcGllclxuICB9ID0gdXNlUmFwaWVyKCk7XG4gIGNvbnN0IHBhcmFtcyA9IHJhcGllci5Kb2ludERhdGEucmV2b2x1dGUodmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkxQW5jaG9yKSwgdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkyQW5jaG9yKSwgdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGF4aXMpKTtcblxuICBpZiAobGltaXRzKSB7XG4gICAgcGFyYW1zLmxpbWl0c0VuYWJsZWQgPSB0cnVlO1xuICAgIHBhcmFtcy5saW1pdHMgPSBsaW1pdHM7XG4gIH1cblxuICByZXR1cm4gdXNlSW1wdWxzZUpvaW50KGJvZHkxLCBib2R5MiwgcGFyYW1zKTtcbn07XG4vKipcbiAqIFRoZSBwcmlzbWF0aWMgam9pbnQgcHJldmVudHMgYW55IHJlbGF0aXZlIG1vdmVtZW50IGJldHdlZW4gdHdvIHJpZ2lkLWJvZGllcywgZXhjZXB0IGZvciByZWxhdGl2ZSB0cmFuc2xhdGlvbnMgYWxvbmcgb25lIGF4aXMuXG4gKiBJdCBpcyBjaGFyYWN0ZXJpemVkIGJ5IG9uZSBsb2NhbCBhbmNob3IgYXMgd2VsbCBhcyBvbmUgbG9jYWwgYXhpcyBvbiBlYWNoIHJpZ2lkLWJvZHkuIEluIDNELCBhbiBvcHRpb25hbFxuICogbG9jYWwgdGFuZ2VudCBheGlzIGNhbiBiZSBzcGVjaWZpZWQgZm9yIGVhY2ggcmlnaWQtYm9keS5cbiAqXG4gKiBAY2F0ZWdvcnkgSG9va3MgLSBKb2ludHNcbiAqL1xuXG5jb25zdCB1c2VQcmlzbWF0aWNKb2ludCA9IChib2R5MSwgYm9keTIsIFtib2R5MUFuY2hvciwgYm9keTJBbmNob3IsIGF4aXMsIGxpbWl0c10pID0+IHtcbiAgY29uc3Qge1xuICAgIHJhcGllclxuICB9ID0gdXNlUmFwaWVyKCk7XG4gIGNvbnN0IHBhcmFtcyA9IHJhcGllci5Kb2ludERhdGEucHJpc21hdGljKHZlY3RvcjNUb1JhcGllclZlY3Rvcihib2R5MUFuY2hvciksIHZlY3RvcjNUb1JhcGllclZlY3Rvcihib2R5MkFuY2hvciksIHZlY3RvcjNUb1JhcGllclZlY3RvcihheGlzKSk7XG5cbiAgaWYgKGxpbWl0cykge1xuICAgIHBhcmFtcy5saW1pdHNFbmFibGVkID0gdHJ1ZTtcbiAgICBwYXJhbXMubGltaXRzID0gbGltaXRzO1xuICB9XG5cbiAgcmV0dXJuIHVzZUltcHVsc2VKb2ludChib2R5MSwgYm9keTIsIHBhcmFtcyk7XG59O1xuLyoqXG4gKiBUaGUgcm9wZSBqb2ludCBsaW1pdHMgdGhlIG1heCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBib2RpZXMuXG4gKiBAY2F0ZWdvcnkgSG9va3MgLSBKb2ludHNcbiAqL1xuXG5jb25zdCB1c2VSb3BlSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBbYm9keTFBbmNob3IsIGJvZHkyQW5jaG9yLCBsZW5ndGhdKSA9PiB7XG4gIGNvbnN0IHtcbiAgICByYXBpZXJcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCB2Qm9keTFBbmNob3IgPSB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTFBbmNob3IpO1xuICBjb25zdCB2Qm9keTJBbmNob3IgPSB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTJBbmNob3IpO1xuICBjb25zdCBwYXJhbXMgPSByYXBpZXIuSm9pbnREYXRhLnJvcGUobGVuZ3RoLCB2Qm9keTFBbmNob3IsIHZCb2R5MkFuY2hvcik7XG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCBwYXJhbXMpO1xufTtcbi8qKlxuICogVGhlIHNwcmluZyBqb2ludCBhcHBsaWVzIGEgZm9yY2UgcHJvcG9ydGlvbmFsIHRvIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBvYmplY3RzLlxuICogQGNhdGVnb3J5IEhvb2tzIC0gSm9pbnRzXG4gKi9cblxuY29uc3QgdXNlU3ByaW5nSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBbYm9keTFBbmNob3IsIGJvZHkyQW5jaG9yLCByZXN0TGVuZ3RoLCBzdGlmZm5lc3MsIGRhbXBpbmddKSA9PiB7XG4gIGNvbnN0IHtcbiAgICByYXBpZXJcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCB2Qm9keTFBbmNob3IgPSB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTFBbmNob3IpO1xuICBjb25zdCB2Qm9keTJBbmNob3IgPSB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTJBbmNob3IpO1xuICBjb25zdCBwYXJhbXMgPSByYXBpZXIuSm9pbnREYXRhLnNwcmluZyhyZXN0TGVuZ3RoLCBzdGlmZm5lc3MsIGRhbXBpbmcsIHZCb2R5MUFuY2hvciwgdkJvZHkyQW5jaG9yKTtcbiAgcmV0dXJuIHVzZUltcHVsc2VKb2ludChib2R5MSwgYm9keTIsIHBhcmFtcyk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYW4gSW50ZXJhY3Rpb25Hcm91cCBiaXRtYXNrIGZvciB1c2UgaW4gdGhlIGBjb2xsaXNpb25Hcm91cHNgIG9yIGBzb2x2ZXJHcm91cHNgXG4gKiBwcm9wZXJ0aWVzIG9mIFJpZ2lkQm9keSBvciBDb2xsaWRlciBjb21wb25lbnRzLiBUaGUgZmlyc3QgYXJndW1lbnQgcmVwcmVzZW50cyBhIGxpc3Qgb2ZcbiAqIGdyb3VwcyB0aGUgZW50aXR5IGlzIGluIChleHByZXNzZWQgYXMgbnVtYmVycyBmcm9tIDAgdG8gMTUpLiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEgbGlzdFxuICogb2YgZ3JvdXBzIHRoYXQgd2lsbCBiZSBmaWx0ZXJlZCBhZ2FpbnN0LiBXaGVuIGl0IGlzIG9taXR0ZWQsIGFsbCBncm91cHMgYXJlIGZpbHRlcmVkIGFnYWluc3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIEEgUmlnaWRCb2R5IHRoYXQgaXMgbWVtYmVyIG9mIGdyb3VwIDAgYW5kIHdpbGwgY29sbGlkZSB3aXRoIGV2ZXJ5dGhpbmcgZnJvbSBncm91cHMgMCBhbmQgMTpcbiAqXG4gKiBgYGB0c3hcbiAqIDxSaWdpZEJvZHkgY29sbGlzaW9uR3JvdXBzPXtpbnRlcmFjdGlvbkdyb3VwcyhbMF0sIFswLCAxXSl9IC8+XG4gKiBgYGBcbiAqXG4gKiBBIFJpZ2lkQm9keSB0aGF0IGlzIG1lbWJlciBvZiBncm91cHMgMCBhbmQgMSBhbmQgd2lsbCBjb2xsaWRlIHdpdGggZXZlcnl0aGluZyBlbHNlOlxuICpcbiAqIGBgYHRzeFxuICogPFJpZ2lkQm9keSBjb2xsaXNpb25Hcm91cHM9e2ludGVyYWN0aW9uR3JvdXBzKFswLCAxXSl9IC8+XG4gKiBgYGBcbiAqXG4gKiBBIFJpZ2lkQm9keSB0aGF0IGlzIG1lbWJlciBvZiBncm91cHMgMCBhbmQgMSBhbmQgd2lsbCBub3QgY29sbGlkZSB3aXRoIGFueXRoaW5nOlxuICpcbiAqIGBgYHRzeFxuICogPFJpZ2lkQm9keSBjb2xsaXNpb25Hcm91cHM9e2ludGVyYWN0aW9uR3JvdXBzKFswLCAxXSwgW10pfSAvPlxuICogYGBgXG4gKlxuICogUGxlYXNlIG5vdGUgdGhhdCBSYXBpZXIgbmVlZHMgaW50ZXJhY3Rpb24gZmlsdGVycyB0byBldmFsdWF0ZSB0byB0cnVlIGJldHdlZW4gX2JvdGhfIGNvbGxpZGluZ1xuICogZW50aXRpZXMgZm9yIGNvbGxpc2lvbiBldmVudHMgdG8gdHJpZ2dlci5cbiAqXG4gKiBAcGFyYW0gbWVtYmVyc2hpcHMgR3JvdXBzIHRoZSBjb2xsaWRlciBpcyBhIG1lbWJlciBvZi4gKFZhbHVlcyBjYW4gcmFuZ2UgZnJvbSAwIHRvIDE1LilcbiAqIEBwYXJhbSBmaWx0ZXJzIEdyb3VwcyB0aGUgaW50ZXJhY3Rpb24gZ3JvdXAgc2hvdWxkIGZpbHRlciBhZ2FpbnN0LiAoVmFsdWVzIGNhbiByYW5nZSBmcm9tIDAgdG8gMTUuKVxuICogQHJldHVybnMgQW4gSW50ZXJhY3Rpb25Hcm91cCBiaXRtYXNrLlxuICovXG5jb25zdCBpbnRlcmFjdGlvbkdyb3VwcyA9IChtZW1iZXJzaGlwcywgZmlsdGVycykgPT4gKGJpdG1hc2sobWVtYmVyc2hpcHMpIDw8IDE2KSArIChmaWx0ZXJzICE9PSB1bmRlZmluZWQgPyBiaXRtYXNrKGZpbHRlcnMpIDogMGIxMTExMTExMTExMTExMTExKTtcblxuY29uc3QgYml0bWFzayA9IGdyb3VwcyA9PiBbZ3JvdXBzXS5mbGF0KCkucmVkdWNlKChhY2MsIGxheWVyKSA9PiBhY2MgfCAxIDw8IGxheWVyLCAwKTtcblxuZXhwb3J0IHsgQW55Q29sbGlkZXIsIEJhbGxDb2xsaWRlciwgQ2Fwc3VsZUNvbGxpZGVyLCBDb25lQ29sbGlkZXIsIENvbnZleEh1bGxDb2xsaWRlciwgQ3Vib2lkQ29sbGlkZXIsIEN5bGluZGVyQ29sbGlkZXIsIEhlaWdodGZpZWxkQ29sbGlkZXIsIEluc3RhbmNlZFJpZ2lkQm9kaWVzLCBNZXNoQ29sbGlkZXIsIFBoeXNpY3MsIFJpZ2lkQm9keSwgUm91bmRDb25lQ29sbGlkZXIsIFJvdW5kQ3Vib2lkQ29sbGlkZXIsIFJvdW5kQ3lsaW5kZXJDb2xsaWRlciwgVHJpbWVzaENvbGxpZGVyLCBldWxlciwgaW50ZXJhY3Rpb25Hcm91cHMsIHF1YXQsIHVzZUFmdGVyUGh5c2ljc1N0ZXAsIHVzZUJlZm9yZVBoeXNpY3NTdGVwLCB1c2VGaXhlZEpvaW50LCB1c2VJbXB1bHNlSm9pbnQsIHVzZVByaXNtYXRpY0pvaW50LCB1c2VSYXBpZXIsIHVzZVJldm9sdXRlSm9pbnQsIHVzZVJvcGVKb2ludCwgdXNlU3BoZXJpY2FsSm9pbnQsIHVzZVNwcmluZ0pvaW50LCB2ZWMzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/rapier/dist/react-three-rapier.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/rapier/node_modules/three-stdlib/types/helpers.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@react-three/rapier/node_modules/three-stdlib/types/helpers.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key) => obj[key];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL3JhcGllci9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qYXdhcmEvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL3JhcGllci9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanM/YmU4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBnZXRXaXRoS2V5ID0gKG9iaiwga2V5KSA9PiBvYmpba2V5XTtcbmV4cG9ydCB7XG4gIGdldFdpdGhLZXlcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/rapier/node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/rapier/node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@react-three/rapier/node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/@react-three/rapier/node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n        const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()];\n  const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.toNonIndexed();\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL3JhcGllci9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1TTtBQUN0SjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpREFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0pBQXNKO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseURBQXNCO0FBQzdELHFDQUFxQyx5REFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQU8sUUFBUSwwQ0FBTyxRQUFRLDBDQUFPO0FBQzFELHVCQUF1QiwwQ0FBTztBQUM5Qix1QkFBdUIsMENBQU87QUFDOUIsdUJBQXVCLDBDQUFPO0FBQzlCLHdCQUF3QiwwQ0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFPO0FBQzlCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrREFBZTtBQUN0Qyx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qYXdhcmEvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL3JhcGllci9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanM/ZDgyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSwgQnVmZmVyQXR0cmlidXRlLCBJbnRlcmxlYXZlZEJ1ZmZlciwgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsIFRyaWFuZ2xlc0RyYXdNb2RlLCBUcmlhbmdsZUZhbkRyYXdNb2RlLCBUcmlhbmdsZVN0cmlwRHJhd01vZGUsIFZlY3RvcjMsIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IGdldFdpdGhLZXkgfSBmcm9tIFwiLi4vdHlwZXMvaGVscGVycy5qc1wiO1xuY29uc3QgbWVyZ2VCdWZmZXJHZW9tZXRyaWVzID0gKGdlb21ldHJpZXMsIHVzZUdyb3VwcykgPT4ge1xuICBjb25zdCBpc0luZGV4ZWQgPSBnZW9tZXRyaWVzWzBdLmluZGV4ICE9PSBudWxsO1xuICBjb25zdCBhdHRyaWJ1dGVzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZ2VvbWV0cmllc1swXS5hdHRyaWJ1dGVzKSk7XG4gIGNvbnN0IG1vcnBoQXR0cmlidXRlc1VzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGdlb21ldHJpZXNbMF0ubW9ycGhBdHRyaWJ1dGVzKSk7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZ2VvbWV0cmllc1swXS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcbiAgY29uc3QgbWVyZ2VkR2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGdlb21ldHJpZXMuZm9yRWFjaCgoZ2VvbSwgaSkgPT4ge1xuICAgIGxldCBhdHRyaWJ1dGVzQ291bnQgPSAwO1xuICAgIGlmIChpc0luZGV4ZWQgIT09IChnZW9tLmluZGV4ICE9PSBudWxsKSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBpbmRleCBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChsZXQgbmFtZSBpbiBnZW9tLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghYXR0cmlidXRlc1VzZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgJy4gQWxsIGdlb21ldHJpZXMgbXVzdCBoYXZlIGNvbXBhdGlibGUgYXR0cmlidXRlczsgbWFrZSBzdXJlIFwiJyArIG5hbWUgKyAnXCIgYXR0cmlidXRlIGV4aXN0cyBhbW9uZyBhbGwgZ2VvbWV0cmllcywgb3IgaW4gbm9uZSBvZiB0aGVtLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlc1tuYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZXNbbmFtZV0ucHVzaChnZW9tLmF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgICAgYXR0cmlidXRlc0NvdW50Kys7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVzQ291bnQgIT09IGF0dHJpYnV0ZXNVc2VkLnNpemUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBNYWtlIHN1cmUgYWxsIGdlb21ldHJpZXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobW9ycGhUYXJnZXRzUmVsYXRpdmUgIT09IGdlb20ubW9ycGhUYXJnZXRzUmVsYXRpdmUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiAubW9ycGhUYXJnZXRzUmVsYXRpdmUgbXVzdCBiZSBjb25zaXN0ZW50IHRocm91Z2hvdXQgYWxsIGdlb21ldHJpZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChsZXQgbmFtZSBpbiBnZW9tLm1vcnBoQXR0cmlidXRlcykge1xuICAgICAgaWYgKCFtb3JwaEF0dHJpYnV0ZXNVc2VkLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiAgLm1vcnBoQXR0cmlidXRlcyBtdXN0IGJlIGNvbnNpc3RlbnQgdGhyb3VnaG91dCBhbGwgZ2VvbWV0cmllcy5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChtb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPT09IHZvaWQgMClcbiAgICAgICAgbW9ycGhBdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgICBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0ucHVzaChnZW9tLm1vcnBoQXR0cmlidXRlc1tuYW1lXSk7XG4gICAgfVxuICAgIG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhID0gbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEgfHwgW107XG4gICAgbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEucHVzaChnZW9tLnVzZXJEYXRhKTtcbiAgICBpZiAodXNlR3JvdXBzKSB7XG4gICAgICBsZXQgY291bnQ7XG4gICAgICBpZiAoZ2VvbS5pbmRleCkge1xuICAgICAgICBjb3VudCA9IGdlb20uaW5kZXguY291bnQ7XG4gICAgICB9IGVsc2UgaWYgKGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvdW50ID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gVGhlIGdlb21ldHJ5IG11c3QgaGF2ZSBlaXRoZXIgYW4gaW5kZXggb3IgYSBwb3NpdGlvbiBhdHRyaWJ1dGVcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG1lcmdlZEdlb21ldHJ5LmFkZEdyb3VwKG9mZnNldCwgY291bnQsIGkpO1xuICAgICAgb2Zmc2V0ICs9IGNvdW50O1xuICAgIH1cbiAgfSk7XG4gIGlmIChpc0luZGV4ZWQpIHtcbiAgICBsZXQgaW5kZXhPZmZzZXQgPSAwO1xuICAgIGNvbnN0IG1lcmdlZEluZGV4ID0gW107XG4gICAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IGdlb20uaW5kZXg7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGV4LmNvdW50OyArK2opIHtcbiAgICAgICAgbWVyZ2VkSW5kZXgucHVzaChpbmRleC5nZXRYKGopICsgaW5kZXhPZmZzZXQpO1xuICAgICAgfVxuICAgICAgaW5kZXhPZmZzZXQgKz0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuICAgIH0pO1xuICAgIG1lcmdlZEdlb21ldHJ5LnNldEluZGV4KG1lcmdlZEluZGV4KTtcbiAgfVxuICBmb3IgKGxldCBuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGUgPSBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgaWYgKCFtZXJnZWRBdHRyaWJ1dGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aGlsZSB0cnlpbmcgdG8gbWVyZ2UgdGhlIFwiICsgbmFtZSArIFwiIGF0dHJpYnV0ZS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtZXJnZWRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUobmFtZSwgbWVyZ2VkQXR0cmlidXRlKTtcbiAgfVxuICBmb3IgKGxldCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcykge1xuICAgIGNvbnN0IG51bU1vcnBoVGFyZ2V0cyA9IG1vcnBoQXR0cmlidXRlc1tuYW1lXVswXS5sZW5ndGg7XG4gICAgaWYgKG51bU1vcnBoVGFyZ2V0cyA9PT0gMClcbiAgICAgIGJyZWFrO1xuICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyA9IG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyB8fCB7fTtcbiAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgKytpKSB7XG4gICAgICBjb25zdCBtb3JwaEF0dHJpYnV0ZXNUb01lcmdlID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1vcnBoQXR0cmlidXRlc1tuYW1lXS5sZW5ndGg7ICsraikge1xuICAgICAgICBtb3JwaEF0dHJpYnV0ZXNUb01lcmdlLnB1c2gobW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdW2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lcmdlZE1vcnBoQXR0cmlidXRlID0gbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UpO1xuICAgICAgaWYgKCFtZXJnZWRNb3JwaEF0dHJpYnV0ZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aGlsZSB0cnlpbmcgdG8gbWVyZ2UgdGhlIFwiICsgbmFtZSArIFwiIG1vcnBoQXR0cmlidXRlLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdLnB1c2gobWVyZ2VkTW9ycGhBdHRyaWJ1dGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkR2VvbWV0cnk7XG59O1xuY29uc3QgbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXMpID0+IHtcbiAgbGV0IFR5cGVkQXJyYXkgPSB2b2lkIDA7XG4gIGxldCBpdGVtU2l6ZSA9IHZvaWQgMDtcbiAgbGV0IG5vcm1hbGl6ZWQgPSB2b2lkIDA7XG4gIGxldCBhcnJheUxlbmd0aCA9IDA7XG4gIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgIGlmIChUeXBlZEFycmF5ID09PSB2b2lkIDApIHtcbiAgICAgIFR5cGVkQXJyYXkgPSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBpZiAoVHlwZWRBcnJheSAhPT0gYXR0ci5hcnJheS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUuYXJyYXkgbXVzdCBiZSBvZiBjb25zaXN0ZW50IGFycmF5IHR5cGVzIGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpdGVtU2l6ZSA9PT0gdm9pZCAwKVxuICAgICAgaXRlbVNpemUgPSBhdHRyLml0ZW1TaXplO1xuICAgIGlmIChpdGVtU2l6ZSAhPT0gYXR0ci5pdGVtU2l6ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUgbXVzdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkID09PSB2b2lkIDApXG4gICAgICBub3JtYWxpemVkID0gYXR0ci5ub3JtYWxpemVkO1xuICAgIGlmIChub3JtYWxpemVkICE9PSBhdHRyLm5vcm1hbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLm5vcm1hbGl6ZWQgbXVzdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFycmF5TGVuZ3RoICs9IGF0dHIuYXJyYXkubGVuZ3RoO1xuICB9KTtcbiAgaWYgKFR5cGVkQXJyYXkgJiYgaXRlbVNpemUpIHtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGFycmF5TGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgIGFycmF5LnNldChhdHRyLmFycmF5LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGF0dHIuYXJyYXkubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG4gIH1cbn07XG5jb25zdCBpbnRlcmxlYXZlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzKSA9PiB7XG4gIGxldCBUeXBlZEFycmF5ID0gdm9pZCAwO1xuICBsZXQgYXJyYXlMZW5ndGggPSAwO1xuICBsZXQgc3RyaWRlID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgaWYgKFR5cGVkQXJyYXkgPT09IHZvaWQgMClcbiAgICAgIFR5cGVkQXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3I7XG4gICAgaWYgKFR5cGVkQXJyYXkgIT09IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkF0dHJpYnV0ZUJ1ZmZlcnMgb2YgZGlmZmVyZW50IHR5cGVzIGNhbm5vdCBiZSBpbnRlcmxlYXZlZFwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhcnJheUxlbmd0aCArPSBhdHRyaWJ1dGUuYXJyYXkubGVuZ3RoO1xuICAgIHN0cmlkZSArPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gIH1cbiAgY29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXIobmV3IFR5cGVkQXJyYXkoYXJyYXlMZW5ndGgpLCBzdHJpZGUpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGNvbnN0IGdldHRlcnMgPSBbXCJnZXRYXCIsIFwiZ2V0WVwiLCBcImdldFpcIiwgXCJnZXRXXCJdO1xuICBjb25zdCBzZXR0ZXJzID0gW1wic2V0WFwiLCBcInNldFlcIiwgXCJzZXRaXCIsIFwic2V0V1wiXTtcbiAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal07XG4gICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgY29uc3QgY291bnQgPSBhdHRyaWJ1dGUuY291bnQ7XG4gICAgY29uc3QgaWJhID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0LCBhdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgcmVzLnB1c2goaWJhKTtcbiAgICBvZmZzZXQgKz0gaXRlbVNpemU7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb3VudDsgYysrKSB7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gZ2V0V2l0aEtleShpYmEsIHNldHRlcnNba10pO1xuICAgICAgICBjb25zdCBnZXQgPSBnZXRXaXRoS2V5KGF0dHJpYnV0ZSwgZ2V0dGVyc1trXSk7XG4gICAgICAgIHNldChjLCBnZXQoYykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmZ1bmN0aW9uIGVzdGltYXRlQnl0ZXNVc2VkKGdlb21ldHJ5KSB7XG4gIGxldCBtZW0gPSAwO1xuICBmb3IgKGxldCBuYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIG1lbSArPSBhdHRyLmNvdW50ICogYXR0ci5pdGVtU2l6ZSAqIGF0dHIuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gIH1cbiAgY29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gIG1lbSArPSBpbmRpY2VzID8gaW5kaWNlcy5jb3VudCAqIGluZGljZXMuaXRlbVNpemUgKiBpbmRpY2VzLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UIDogMDtcbiAgcmV0dXJuIG1lbTtcbn1cbmZ1bmN0aW9uIG1lcmdlVmVydGljZXMoZ2VvbWV0cnksIHRvbGVyYW5jZSA9IDFlLTQpIHtcbiAgdG9sZXJhbmNlID0gTWF0aC5tYXgodG9sZXJhbmNlLCBOdW1iZXIuRVBTSUxPTik7XG4gIGNvbnN0IGhhc2hUb0luZGV4ID0ge307XG4gIGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICBjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKTtcbiAgY29uc3QgdmVydGV4Q291bnQgPSBpbmRpY2VzID8gaW5kaWNlcy5jb3VudCA6IHBvc2l0aW9ucy5jb3VudDtcbiAgbGV0IG5leHRJbmRleCA9IDA7XG4gIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMoZ2VvbWV0cnkuYXR0cmlidXRlcyk7XG4gIGNvbnN0IGF0dHJBcnJheXMgPSB7fTtcbiAgY29uc3QgbW9ycGhBdHRyc0FycmF5cyA9IHt9O1xuICBjb25zdCBuZXdJbmRpY2VzID0gW107XG4gIGNvbnN0IGdldHRlcnMgPSBbXCJnZXRYXCIsIFwiZ2V0WVwiLCBcImdldFpcIiwgXCJnZXRXXCJdO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICBhdHRyQXJyYXlzW25hbWVdID0gW107XG4gICAgY29uc3QgbW9ycGhBdHRyID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdO1xuICAgIGlmIChtb3JwaEF0dHIpIHtcbiAgICAgIG1vcnBoQXR0cnNBcnJheXNbbmFtZV0gPSBuZXcgQXJyYXkobW9ycGhBdHRyLmxlbmd0aCkuZmlsbCgwKS5tYXAoKCkgPT4gW10pO1xuICAgIH1cbiAgfVxuICBjb25zdCBkZWNpbWFsU2hpZnQgPSBNYXRoLmxvZzEwKDEgLyB0b2xlcmFuY2UpO1xuICBjb25zdCBzaGlmdE11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgZGVjaW1hbFNoaWZ0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgaW5kZXggPSBpbmRpY2VzID8gaW5kaWNlcy5nZXRYKGkpIDogaTtcbiAgICBsZXQgaGFzaCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tqXTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgIGhhc2ggKz0gYCR7fn4oYXR0cmlidXRlW2dldHRlcnNba11dKGluZGV4KSAqIHNoaWZ0TXVsdGlwbGllcil9LGA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNoIGluIGhhc2hUb0luZGV4KSB7XG4gICAgICBuZXdJbmRpY2VzLnB1c2goaGFzaFRvSW5kZXhbaGFzaF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbal07XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgY29uc3QgbW9ycGhBdHRyID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgICAgY29uc3QgbmV3YXJyYXkgPSBhdHRyQXJyYXlzW25hbWVdO1xuICAgICAgICBjb25zdCBuZXdNb3JwaEFycmF5cyA9IG1vcnBoQXR0cnNBcnJheXNbbmFtZV07XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICAgIGNvbnN0IGdldHRlckZ1bmMgPSBnZXR0ZXJzW2tdO1xuICAgICAgICAgIG5ld2FycmF5LnB1c2goYXR0cmlidXRlW2dldHRlckZ1bmNdKGluZGV4KSk7XG4gICAgICAgICAgaWYgKG1vcnBoQXR0cikge1xuICAgICAgICAgICAgZm9yIChsZXQgbSA9IDAsIG1sID0gbW9ycGhBdHRyLmxlbmd0aDsgbSA8IG1sOyBtKyspIHtcbiAgICAgICAgICAgICAgbmV3TW9ycGhBcnJheXNbbV0ucHVzaChtb3JwaEF0dHJbbV1bZ2V0dGVyRnVuY10oaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhc2hUb0luZGV4W2hhc2hdID0gbmV4dEluZGV4O1xuICAgICAgbmV3SW5kaWNlcy5wdXNoKG5leHRJbmRleCk7XG4gICAgICBuZXh0SW5kZXgrKztcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gZ2VvbWV0cnkuY2xvbmUoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbaV07XG4gICAgY29uc3Qgb2xkQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBvbGRBdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IoYXR0ckFycmF5c1tuYW1lXSk7XG4gICAgY29uc3QgYXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShidWZmZXIsIG9sZEF0dHJpYnV0ZS5pdGVtU2l6ZSwgb2xkQXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgIHJlc3VsdC5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cmlidXRlKTtcbiAgICBpZiAobmFtZSBpbiBtb3JwaEF0dHJzQXJyYXlzKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1vcnBoQXR0cnNBcnJheXNbbmFtZV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qgb2xkTW9ycGhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal07XG4gICAgICAgIGNvbnN0IGJ1ZmZlcjIgPSBuZXcgb2xkTW9ycGhBdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IobW9ycGhBdHRyc0FycmF5c1tuYW1lXVtqXSk7XG4gICAgICAgIGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShidWZmZXIyLCBvbGRNb3JwaEF0dHJpYnV0ZS5pdGVtU2l6ZSwgb2xkTW9ycGhBdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgICAgIHJlc3VsdC5tb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal0gPSBtb3JwaEF0dHJpYnV0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzdWx0LnNldEluZGV4KG5ld0luZGljZXMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9UcmlhbmdsZXNEcmF3TW9kZShnZW9tZXRyeSwgZHJhd01vZGUpIHtcbiAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZXNEcmF3TW9kZSkge1xuICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBHZW9tZXRyeSBhbHJlYWR5IGRlZmluZWQgYXMgdHJpYW5nbGVzLlwiKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZUZhbkRyYXdNb2RlIHx8IGRyYXdNb2RlID09PSBUcmlhbmdsZVN0cmlwRHJhd01vZGUpIHtcbiAgICBsZXQgaW5kZXggPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICAgIGlmIChpbmRleCA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKTtcbiAgICAgIGlmIChwb3NpdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb24uY291bnQ7IGkrKykge1xuICAgICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICBnZW9tZXRyeS5zZXRJbmRleChpbmRpY2VzKTtcbiAgICAgICAgaW5kZXggPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmRlZmluZWQgcG9zaXRpb24gYXR0cmlidXRlLiBQcm9jZXNzaW5nIG5vdCBwb3NzaWJsZS5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG51bWJlck9mVHJpYW5nbGVzID0gaW5kZXguY291bnQgLSAyO1xuICAgIGNvbnN0IG5ld0luZGljZXMgPSBbXTtcbiAgICBpZiAoaW5kZXgpIHtcbiAgICAgIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBudW1iZXJPZlRyaWFuZ2xlczsgaSsrKSB7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoMCkpO1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkpKTtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mVHJpYW5nbGVzOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMikpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld0luZGljZXMubGVuZ3RoIC8gMyAhPT0gbnVtYmVyT2ZUcmlhbmdsZXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5hYmxlIHRvIGdlbmVyYXRlIGNvcnJlY3QgYW1vdW50IG9mIHRyaWFuZ2xlcy5cIik7XG4gICAgfVxuICAgIGNvbnN0IG5ld0dlb21ldHJ5ID0gZ2VvbWV0cnkuY2xvbmUoKTtcbiAgICBuZXdHZW9tZXRyeS5zZXRJbmRleChuZXdJbmRpY2VzKTtcbiAgICBuZXdHZW9tZXRyeS5jbGVhckdyb3VwcygpO1xuICAgIHJldHVybiBuZXdHZW9tZXRyeTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVua25vd24gZHJhdyBtb2RlOlwiLCBkcmF3TW9kZSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlTW9ycGhlZEF0dHJpYnV0ZXMob2JqZWN0KSB7XG4gIGlmIChvYmplY3QuZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSAhPT0gdHJ1ZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiBHZW9tZXRyeSBpcyBub3Qgb2YgdHlwZSBCdWZmZXJHZW9tZXRyeS5cIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgX3ZBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3ZCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3ZDID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3RlbXBBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3RlbXBCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3RlbXBDID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhDID0gbmV3IFZlY3RvcjMoKTtcbiAgZnVuY3Rpb24gX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKG9iamVjdDIsIG1hdGVyaWFsMiwgYXR0cmlidXRlLCBtb3JwaEF0dHJpYnV0ZSwgbW9ycGhUYXJnZXRzUmVsYXRpdmUyLCBhMiwgYjIsIGMyLCBtb2RpZmllZEF0dHJpYnV0ZUFycmF5KSB7XG4gICAgX3ZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBhMik7XG4gICAgX3ZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBiMik7XG4gICAgX3ZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBjMik7XG4gICAgY29uc3QgbW9ycGhJbmZsdWVuY2VzID0gb2JqZWN0Mi5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG4gICAgaWYgKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbWF0ZXJpYWwyLm1vcnBoVGFyZ2V0cyAmJiBtb3JwaEF0dHJpYnV0ZSAmJiBtb3JwaEluZmx1ZW5jZXNcbiAgICApIHtcbiAgICAgIF9tb3JwaEEuc2V0KDAsIDAsIDApO1xuICAgICAgX21vcnBoQi5zZXQoMCwgMCwgMCk7XG4gICAgICBfbW9ycGhDLnNldCgwLCAwLCAwKTtcbiAgICAgIGZvciAobGV0IGkyID0gMCwgaWwyID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpMiA8IGlsMjsgaTIrKykge1xuICAgICAgICBjb25zdCBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbaTJdO1xuICAgICAgICBjb25zdCBtb3JwaCA9IG1vcnBoQXR0cmlidXRlW2kyXTtcbiAgICAgICAgaWYgKGluZmx1ZW5jZSA9PT0gMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgX3RlbXBBLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGgsIGEyKTtcbiAgICAgICAgX3RlbXBCLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGgsIGIyKTtcbiAgICAgICAgX3RlbXBDLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGgsIGMyKTtcbiAgICAgICAgaWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlMikge1xuICAgICAgICAgIF9tb3JwaEEuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhCLmFkZFNjYWxlZFZlY3RvcihfdGVtcEIsIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQy5hZGRTY2FsZWRWZWN0b3IoX3RlbXBDLCBpbmZsdWVuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9tb3JwaEEuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQS5zdWIoX3ZBKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhCLmFkZFNjYWxlZFZlY3RvcihfdGVtcEIuc3ViKF92QiksIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQy5hZGRTY2FsZWRWZWN0b3IoX3RlbXBDLnN1YihfdkMpLCBpbmZsdWVuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfdkEuYWRkKF9tb3JwaEEpO1xuICAgICAgX3ZCLmFkZChfbW9ycGhCKTtcbiAgICAgIF92Qy5hZGQoX21vcnBoQyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QyLmlzU2tpbm5lZE1lc2gpIHtcbiAgICAgIG9iamVjdDIuYm9uZVRyYW5zZm9ybShhMiwgX3ZBKTtcbiAgICAgIG9iamVjdDIuYm9uZVRyYW5zZm9ybShiMiwgX3ZCKTtcbiAgICAgIG9iamVjdDIuYm9uZVRyYW5zZm9ybShjMiwgX3ZDKTtcbiAgICB9XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAwXSA9IF92QS54O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMV0gPSBfdkEueTtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDJdID0gX3ZBLno7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAwXSA9IF92Qi54O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMV0gPSBfdkIueTtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDJdID0gX3ZCLno7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAwXSA9IF92Qy54O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMV0gPSBfdkMueTtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDJdID0gX3ZDLno7XG4gIH1cbiAgY29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG4gIGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuICBsZXQgYSwgYiwgYztcbiAgY29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgY29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBtb3JwaFBvc2l0aW9uID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuICBjb25zdCBub3JtYWxBdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcbiAgY29uc3QgbW9ycGhOb3JtYWwgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcbiAgY29uc3QgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlO1xuICBsZXQgaSwgaiwgaWwsIGpsO1xuICBsZXQgZ3JvdXAsIGdyb3VwTWF0ZXJpYWw7XG4gIGxldCBzdGFydCwgZW5kO1xuICBjb25zdCBtb2RpZmllZFBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCAqIHBvc2l0aW9uQXR0cmlidXRlLml0ZW1TaXplKTtcbiAgY29uc3QgbW9kaWZpZWROb3JtYWwgPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbEF0dHJpYnV0ZS5jb3VudCAqIG5vcm1hbEF0dHJpYnV0ZS5pdGVtU2l6ZSk7XG4gIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgZm9yIChpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuICAgICAgICBzdGFydCA9IE1hdGgubWF4KGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihncm91cC5zdGFydCArIGdyb3VwLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgICBmb3IgKGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzKSB7XG4gICAgICAgICAgYSA9IGluZGV4LmdldFgoaik7XG4gICAgICAgICAgYiA9IGluZGV4LmdldFgoaiArIDEpO1xuICAgICAgICAgIGMgPSBpbmRleC5nZXRYKGogKyAyKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICBlbmQgPSBNYXRoLm1pbihpbmRleC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMpIHtcbiAgICAgICAgYSA9IGluZGV4LmdldFgoaSk7XG4gICAgICAgIGIgPSBpbmRleC5nZXRYKGkgKyAxKTtcbiAgICAgICAgYyA9IGluZGV4LmdldFgoaSArIDIpO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICApO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChwb3NpdGlvbkF0dHJpYnV0ZSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICAgIGZvciAoaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcbiAgICAgICAgICBhID0gajtcbiAgICAgICAgICBiID0gaiArIDE7XG4gICAgICAgICAgYyA9IGogKyAyO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgIGVuZCA9IE1hdGgubWluKHBvc2l0aW9uQXR0cmlidXRlLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuICAgICAgICBhID0gaTtcbiAgICAgICAgYiA9IGkgKyAxO1xuICAgICAgICBjID0gaSArIDI7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IG1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG1vZGlmaWVkUG9zaXRpb24sIDMpO1xuICBjb25zdCBtb3JwaGVkTm9ybWFsQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobW9kaWZpZWROb3JtYWwsIDMpO1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICBtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgbW9ycGhlZE5vcm1hbEF0dHJpYnV0ZVxuICB9O1xufVxuZnVuY3Rpb24gdG9DcmVhc2VkTm9ybWFscyhnZW9tZXRyeSwgY3JlYXNlQW5nbGUgPSBNYXRoLlBJIC8gMykge1xuICBjb25zdCBjcmVhc2VEb3QgPSBNYXRoLmNvcyhjcmVhc2VBbmdsZSk7XG4gIGNvbnN0IGhhc2hNdWx0aXBsaWVyID0gKDEgKyAxZS0xMCkgKiAxMDA7XG4gIGNvbnN0IHZlcnRzID0gW25ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKCldO1xuICBjb25zdCB0ZW1wVmVjMSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBWZWMyID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcE5vcm0gPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wTm9ybTIgPSBuZXcgVmVjdG9yMygpO1xuICBmdW5jdGlvbiBoYXNoVmVydGV4KHYpIHtcbiAgICBjb25zdCB4ID0gfn4odi54ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIGNvbnN0IHkgPSB+fih2LnkgKiBoYXNoTXVsdGlwbGllcik7XG4gICAgY29uc3QgeiA9IH5+KHYueiAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICByZXR1cm4gYCR7eH0sJHt5fSwke3p9YDtcbiAgfVxuICBjb25zdCByZXN1bHRHZW9tZXRyeSA9IGdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpO1xuICBjb25zdCBwb3NBdHRyID0gcmVzdWx0R2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgdmVydGV4TWFwID0ge307XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpMyA9IDMgKiBpO1xuICAgIGNvbnN0IGEgPSB2ZXJ0c1swXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMCk7XG4gICAgY29uc3QgYiA9IHZlcnRzWzFdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAxKTtcbiAgICBjb25zdCBjID0gdmVydHNbMl0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDIpO1xuICAgIHRlbXBWZWMxLnN1YlZlY3RvcnMoYywgYik7XG4gICAgdGVtcFZlYzIuc3ViVmVjdG9ycyhhLCBiKTtcbiAgICBjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyh0ZW1wVmVjMSwgdGVtcFZlYzIpLm5vcm1hbGl6ZSgpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgMzsgbisrKSB7XG4gICAgICBjb25zdCB2ZXJ0ID0gdmVydHNbbl07XG4gICAgICBjb25zdCBoYXNoID0gaGFzaFZlcnRleCh2ZXJ0KTtcbiAgICAgIGlmICghKGhhc2ggaW4gdmVydGV4TWFwKSkge1xuICAgICAgICB2ZXJ0ZXhNYXBbaGFzaF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHZlcnRleE1hcFtoYXNoXS5wdXNoKG5vcm1hbCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5vcm1hbEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShwb3NBdHRyLmNvdW50ICogMyk7XG4gIGNvbnN0IG5vcm1BdHRyID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShub3JtYWxBcnJheSwgMywgZmFsc2UpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBvc0F0dHIuY291bnQgLyAzOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgaTMgPSAzICogaTtcbiAgICBjb25zdCBhID0gdmVydHNbMF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDApO1xuICAgIGNvbnN0IGIgPSB2ZXJ0c1sxXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMSk7XG4gICAgY29uc3QgYyA9IHZlcnRzWzJdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAyKTtcbiAgICB0ZW1wVmVjMS5zdWJWZWN0b3JzKGMsIGIpO1xuICAgIHRlbXBWZWMyLnN1YlZlY3RvcnMoYSwgYik7XG4gICAgdGVtcE5vcm0uY3Jvc3NWZWN0b3JzKHRlbXBWZWMxLCB0ZW1wVmVjMikubm9ybWFsaXplKCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuKyspIHtcbiAgICAgIGNvbnN0IHZlcnQgPSB2ZXJ0c1tuXTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoVmVydGV4KHZlcnQpO1xuICAgICAgY29uc3Qgb3RoZXJOb3JtYWxzID0gdmVydGV4TWFwW2hhc2hdO1xuICAgICAgdGVtcE5vcm0yLnNldCgwLCAwLCAwKTtcbiAgICAgIGZvciAobGV0IGsgPSAwLCBsayA9IG90aGVyTm9ybWFscy5sZW5ndGg7IGsgPCBsazsgaysrKSB7XG4gICAgICAgIGNvbnN0IG90aGVyTm9ybSA9IG90aGVyTm9ybWFsc1trXTtcbiAgICAgICAgaWYgKHRlbXBOb3JtLmRvdChvdGhlck5vcm0pID4gY3JlYXNlRG90KSB7XG4gICAgICAgICAgdGVtcE5vcm0yLmFkZChvdGhlck5vcm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wTm9ybTIubm9ybWFsaXplKCk7XG4gICAgICBub3JtQXR0ci5zZXRYWVooaTMgKyBuLCB0ZW1wTm9ybTIueCwgdGVtcE5vcm0yLnksIHRlbXBOb3JtMi56KTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0R2VvbWV0cnkuc2V0QXR0cmlidXRlKFwibm9ybWFsXCIsIG5vcm1BdHRyKTtcbiAgcmV0dXJuIHJlc3VsdEdlb21ldHJ5O1xufVxuZXhwb3J0IHtcbiAgY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzLFxuICBlc3RpbWF0ZUJ5dGVzVXNlZCxcbiAgaW50ZXJsZWF2ZUF0dHJpYnV0ZXMsXG4gIG1lcmdlQnVmZmVyQXR0cmlidXRlcyxcbiAgbWVyZ2VCdWZmZXJHZW9tZXRyaWVzLFxuICBtZXJnZVZlcnRpY2VzLFxuICB0b0NyZWFzZWROb3JtYWxzLFxuICB0b1RyaWFuZ2xlc0RyYXdNb2RlXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/rapier/node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ })

};
;